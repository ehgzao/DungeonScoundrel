<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1024, initial-scale=1.0, user-scalable=yes">
    <title>🎴 Dungeon Scoundrel - Roguelike Card Game</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="A dark medieval roguelike card game. Explore dungeons, fight monsters, collect powerful relics and prove your skill in this challenging card game! 4 difficulties, 50 achievements, permanent unlock system.">
    <meta name="keywords" content="roguelike, card game, medieval, dungeon crawler, RPG, strategy, browser game, HTML5 game, dark fantasy, atmospheric">
    <meta name="author" content="Dungeon Scoundrel Team">
    <meta name="theme-color" content="#2c2416">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://dungeonscoundrel.com/">
    <meta property="og:title" content="🎴 Dungeon Scoundrel - Dark Medieval Roguelike Card Game">
    <meta property="og:description" content="A challenging medieval roguelike card game. Explore dungeons, collect relics, defeat monsters! 4 difficulties, 50 achievements. Play now in your browser!">
    <meta property="og:image" content="https://dungeonscoundrel.com/favicon.svg">
    <meta property="og:locale" content="en_US">
    <meta property="og:site_name" content="Dungeon Scoundrel">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://dungeonscoundrel.com/">
    <meta property="twitter:title" content="🎴 Dungeon Scoundrel - Dark Medieval Roguelike">
    <meta property="twitter:description" content="A challenging medieval roguelike card game. Explore dungeons, collect relics, defeat monsters! Play now!">
    <meta property="twitter:image" content="https://dungeonscoundrel.com/favicon.svg">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.svg">
    <link rel="mask-icon" href="favicon.svg" color="#d4af37">
    <link rel="apple-touch-icon" href="favicon.svg">
    
    <!-- Web App Manifest -->
    <link rel="manifest" href="site.webmanifest">
    
    <!-- Medieval Fonts from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;900&family=Cinzel+Decorative:wght@700;900&family=MedievalSharp&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="src/styles/styles.css">

</head>
<body>

    <!-- ============================================ -->
    <!-- WELCOME SCREEN
    <!-- ============================================ -->
    <div class="welcome-screen" id="welcomeScreen" style="
        background: url('assets/dungeon-bg.jpg') center center / cover no-repeat, linear-gradient(180deg, #1a1410 0%, #0d0a08 50%, #000000 100%);
        position: relative;
        overflow: hidden;
    ">
        <!-- Dark Overlay for Readability -->
        <div style="position: absolute; inset: 0; background: rgba(0, 0, 0, 0.65); pointer-events: none; z-index: 1;"></div>
        
        <!-- Vignette Effect -->
        <div style="position: absolute; inset: 0; background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.85) 100%); pointer-events: none; z-index: 2;"></div>
        
        <!-- Noise Texture Overlay -->
        <div style="position: absolute; inset: 0; background: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,0,0,0.03) 2px, rgba(0,0,0,0.03) 4px); pointer-events: none; z-index: 3; opacity: 0.5;"></div>
        
        <!-- Content Container -->
        <div style="position: relative; z-index: 4; width: 100%; height: 100%; display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 40px 20px;">
        
        <!-- Title Logo Image -->
        <div style="text-align: center; margin-bottom: 15px;">
            <img src="assets/title-logo.png" alt="Dungeon Scoundrel" style="
                max-width: min(90vw, 900px);
                height: auto;
                display: block;
                margin: 0 auto;
                filter: drop-shadow(0 0 20px rgba(201, 169, 97, 0.5))
                        drop-shadow(0 8px 30px rgba(0, 0, 0, 0.9));
                image-rendering: crisp-edges;
                -webkit-user-drag: none;
            ">
        </div>
        
        <!-- Subtitle -->
        <p style="
            font-family: 'Cinzel', serif;
            font-size: clamp(0.75em, 2vw, 1em);
            color: #8b7355;
            text-transform: uppercase;
            letter-spacing: 0.25em;
            margin: 10px 0 40px 0;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.8);
            font-weight: 600;
        ">A Roguelike Card Game</p>
        <!-- Menu Buttons Container -->
        <div style="display: flex; flex-direction: column; gap: 12px; width: 100%; max-width: 420px; margin-bottom: 30px;">
            <button id="btnWelcomeStart" style="
                font-family: 'Cinzel', serif;
                font-size: clamp(0.95em, 2.5vw, 1.1em);
                font-weight: 600;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                padding: 16px 24px;
                background: linear-gradient(180deg, #c9a961 0%, #a68948 100%);
                border: 2px solid #d4af37;
                box-shadow: 
                    0 0 0 1px #8b7355,
                    inset 0 1px 0 rgba(255, 255, 255, 0.2),
                    inset 0 -1px 0 rgba(0, 0, 0, 0.5),
                    0 4px 12px rgba(0, 0, 0, 0.6);
                color: #1a1410;
                cursor: pointer;
                transition: all 0.2s ease;
                text-shadow: 0 1px 0 rgba(255, 255, 255, 0.3);
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 0 0 1px #8b7355, inset 0 1px 0 rgba(255,255,255,0.3), 0 6px 16px rgba(0,0,0,0.8)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 0 0 1px #8b7355, inset 0 1px 0 rgba(255,255,255,0.2), inset 0 -1px 0 rgba(0,0,0,0.5), 0 4px 12px rgba(0,0,0,0.6)'"><span style="font-size: 1.2em;">⚔️</span> Start Quest</button>
            
            <button id="btnPlayTutorial" class="menu-btn-secondary" style="
                font-family: 'Cinzel', serif;
                font-size: clamp(0.85em, 2.2vw, 1em);
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.08em;
                padding: 14px 20px;
                background: linear-gradient(180deg, #3d3328 0%, #2a2318 100%);
                border: 1px solid #5a4a38;
                box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 2px 8px rgba(0, 0, 0, 0.5);
                color: #c9a961;
                cursor: pointer;
                transition: all 0.2s ease;
            " onmouseover="this.style.background='linear-gradient(180deg, #4a3d2f 0%, #342820 100%)'; this.style.borderColor='#6b5a48'" onmouseout="this.style.background='linear-gradient(180deg, #3d3328 0%, #2a2318 100%)'; this.style.borderColor='#5a4a38'"><span style="font-size: 1.1em;">🎮</span> Play Tutorial</button>
            
            <button id="btnWelcomeTutorial" class="menu-btn-secondary" style="
                font-family: 'Cinzel', serif;
                font-size: clamp(0.85em, 2.2vw, 1em);
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.08em;
                padding: 14px 20px;
                background: linear-gradient(180deg, #3d3328 0%, #2a2318 100%);
                border: 1px solid #5a4a38;
                box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 2px 8px rgba(0, 0, 0, 0.5);
                color: #c9a961;
                cursor: pointer;
                transition: all 0.2s ease;
            " onmouseover="this.style.background='linear-gradient(180deg, #4a3d2f 0%, #342820 100%)'; this.style.borderColor='#6b5a48'" onmouseout="this.style.background='linear-gradient(180deg, #3d3328 0%, #2a2318 100%)'; this.style.borderColor='#5a4a38'"><span style="font-size: 1.1em;">📜</span> Read Guide</button>
            
            <button id="btnWelcomeLeaderboard" class="menu-btn-secondary" style="
                font-family: 'Cinzel', serif;
                font-size: clamp(0.85em, 2.2vw, 1em);
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.08em;
                padding: 14px 20px;
                background: linear-gradient(180deg, #3d3328 0%, #2a2318 100%);
                border: 1px solid #5a4a38;
                box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 2px 8px rgba(0, 0, 0, 0.5);
                color: #c9a961;
                cursor: pointer;
                transition: all 0.2s ease;
            " onmouseover="this.style.background='linear-gradient(180deg, #4a3d2f 0%, #342820 100%)'; this.style.borderColor='#6b5a48'" onmouseout="this.style.background='linear-gradient(180deg, #3d3328 0%, #2a2318 100%)'; this.style.borderColor='#5a4a38'"><span style="font-size: 1.1em;">🏆</span> Hall of Fame</button>
            
            <button id="btnWelcomeSoundboard" class="menu-btn-secondary" style="
                font-family: 'Cinzel', serif;
                font-size: clamp(0.85em, 2.2vw, 1em);
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.08em;
                padding: 14px 20px;
                background: linear-gradient(180deg, #3d3328 0%, #2a2318 100%);
                border: 1px solid #5a4a38;
                box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 2px 8px rgba(0, 0, 0, 0.5);
                color: #c9a961;
                cursor: pointer;
                transition: all 0.2s ease;
            " onmouseover="this.style.background='linear-gradient(180deg, #4a3d2f 0%, #342820 100%)'; this.style.borderColor='#6b5a48'" onmouseout="this.style.background='linear-gradient(180deg, #3d3328 0%, #2a2318 100%)'; this.style.borderColor='#5a4a38'"><span style="font-size: 1.1em;">🎼</span> Music Chamber</button>
            
            <button id="btnWelcomeUnlocks" class="menu-btn-secondary" style="
                font-family: 'Cinzel', serif;
                font-size: clamp(0.85em, 2.2vw, 1em);
                font-weight: 500;
                text-transform: uppercase;
                letter-spacing: 0.08em;
                padding: 14px 20px;
                background: linear-gradient(180deg, #3d3328 0%, #2a2318 100%);
                border: 1px solid #5a4a38;
                box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 2px 8px rgba(0, 0, 0, 0.5);
                color: #c9a961;
                cursor: pointer;
                transition: all 0.2s ease;
            " onmouseover="this.style.background='linear-gradient(180deg, #4a3d2f 0%, #342820 100%)'; this.style.borderColor='#6b5a48'" onmouseout="this.style.background='linear-gradient(180deg, #3d3328 0%, #2a2318 100%)'; this.style.borderColor='#5a4a38'"><span style="font-size: 1.1em;">🗝️</span> Upgrades</button>
        </div>
        
        <!-- Music Controls (Minimalist) -->
        <div style="width: 100%; max-width: 420px;">
            <div id="nowPlayingDisplay" style="
                text-align: center;
                color: #8b7355;
                font-size: clamp(0.75em, 2vw, 0.9em);
                margin-bottom: 12px;
                font-family: 'Cinzel', serif;
                text-transform: uppercase;
                letter-spacing: 0.1em;
                opacity: 0.8;
            ">🎵 Dark Awakening</div>
            <div style="display: flex; gap: 10px; justify-content: center; align-items: center;">
                <button id="btnWelcomeMusicToggle" title="Play/Pause Music" style="
                    font-size: 1.3em;
                    padding: 8px 16px;
                    background: linear-gradient(180deg, #3d3328 0%, #2a2318 100%);
                    border: 1px solid #5a4a38;
                    color: #c9a961;
                    cursor: pointer;
                    box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.05), 0 2px 8px rgba(0, 0, 0, 0.5);
                    transition: all 0.2s ease;
                ">⏯️</button>
                <input type="range" id="welcomeMusicVolume" min="0" max="100" value="15" title="Music Volume" style="
                    width: 140px;
                    height: 6px;
                    cursor: pointer;
                    -webkit-appearance: none;
                    appearance: none;
                    border-radius: 3px;
                    outline: none;
                    border: 1px solid #5a4a38;
                ">
            </div>
        </div>
        
        </div> <!-- Close content container -->
    </div>

    <!-- ============================================ -->
    <!-- MAIN GAME WRAPPER (HIDDEN)
    <!-- ============================================ -->
    <div class="game-wrapper" id="gameWrapper">

        <!-- TOP BAR (STATS, GOLD, SETTINGS) -->
        <div class="top-bar">
            <div class="stats-group">
                <div class="stat-display" id="top-bar-health" title="Current / Max Health">
                    ❤️ <span class="stat-value" id="health">20</span>
                </div>
                <div class="stat-display" id="top-bar-gold" title="Gold">
                    🪙 <span class="stat-value" id="goldAmount">0</span>
                </div>
                 <!-- Score removed from here -->
                <div class="stat-display" id="top-bar-dungeon" title="Cards left in Dungeon">
                    🏰 <span class="stat-value" id="dungeonCount">0</span>
                </div>
                <div class="stat-display" id="top-bar-rooms" title="Rooms Cleared">
                    🚪 <span class="stat-value" id="statRooms">0</span>
                </div>
            </div>
            
            <!-- CENTER GROUP: Timer + Achievements -->
            <div style="display: flex; gap: 20px; align-items: center; justify-content: center; flex: 1;">
                <div class="stat-display" id="gameTimer" title="Elapsed Time" style="font-size: 1.1em; font-weight: bold; color: #ffd700;">
                    ⏱️ <span class="stat-value">00:00</span>
                </div>
                <div class="achievements-compact" id="achievementsCompact" title="Click to view all achievements">
                    🏆 <span class="achievement-counter" id="achievementCounter">0/50</span>
                </div>
            </div>
            
            <div class="settings-group">
                <button class="settings-btn" id="btnTopSound" title="Toggle Sound (SFX)">🔊</button>
                
                <div class="music-controls">
                    <button class="settings-btn" id="btnMusicToggle" title="Play/Pause Music">⏯️</button>
                    <input type="range" id="musicVolume" min="0" max="100" value="15" title="Music Volume" 
                           style="width: 80px; height: 20px; vertical-align: middle; margin: 0 5px; cursor: pointer;">
                </div>
                
                <button class="settings-btn" id="btnTopTutorial" title="Open Tutorial">📖</button>
                <button class="settings-btn" id="btnTopLeaderboard" title="Open Leaderboard">📊</button>
                <button class="settings-btn btn-highlight" id="btnTopUnlocks" title="Open Unlocks">🔓</button>
                <button class="settings-btn btn-danger-style" id="btnTopGiveUp" title="Give Up Run">🏳️</button>
            </div>
        </div>

        <!-- CENTER AREA (RELICS, STAGE, HOLD) -->
        <div class="center-area">
            
            <!-- LEFT PANEL (PLAYER, RELICS, SHOP) -->
            <div class="left-sidebar">
                <!-- Player Class Info - REDESIGNED -->
                <div style="
                    background: linear-gradient(135deg, rgba(201,169,97,0.2) 0%, rgba(42,35,24,0.9) 100%);
                    border: 3px solid #d4af37;
                    border-radius: 15px;
                    padding: 20px 15px;
                    margin-bottom: 15px;
                    box-shadow: 0 6px 20px rgba(212,175,55,0.5);
                    text-align: center;
                ">
                    <!-- Large Avatar -->
                    <img id="playerAvatar" src="" alt="Avatar" style="
                        width: 130px;
                        height: 130px;
                        border-radius: 12px;
                        border: 4px solid #ffd700;
                        object-fit: cover;
                        box-shadow: 0 2px 10px rgba(255,215,0,0.4);
                        margin: 0 auto 12px auto;
                        display: block;
                    ">
                    
                    <!-- Player Info -->
                    <div id="playerNameDisplay" style="
                        color: #ffd700;
                        font-weight: bold;
                        font-size: 1.3em;
                        font-family: 'Cinzel', serif;
                        text-shadow: 0 2px 6px rgba(0,0,0,0.9);
                        margin-bottom: 5px;
                    "></div>
                    <div id="playerClassDisplay" style="
                        color: #d4af37;
                        font-size: 0.9em;
                        text-transform: uppercase;
                        letter-spacing: 2px;
                        font-weight: 700;
                        margin-bottom: 12px;
                    "></div>
                    
                    <!-- Passive Icons Display -->
                    <div id="passiveIconsDisplay" style="
                        display: flex;
                        gap: 6px;
                        flex-wrap: wrap;
                        justify-content: center;
                        padding-top: 12px;
                        border-top: 2px solid rgba(212,175,55,0.5);
                    ">
                        <!-- Passive icons will be added here dynamically -->
                    </div>
                </div>
                
                <div class="relics-panel" id="relicsPanel">
                    <div class="sidebar-label">Relics</div>
                    <div id="relicsList">
                        <div class="empty-slot">No Relics Yet</div>
                    </div>
                </div>
                <div class="sidebar-action">
                    <button class="btn-shop" id="btnOpenShop">🏺 Merchant</button>
                </div>
            </div>

            <!-- CENTER STAGE (WEAPON, MESSAGES, CONTROLS) -->
            <div class="center-stage">
                
                <div id="messageArea">
                    <!-- Messages appear here -->
                </div>

                <!-- NEW SCORE DISPLAY -->
                <div class="score-display" id="mainScoreDisplay">
                    <div class="score-label">SCORE</div>
                    <div class="score-value" id="mainScoreValue">0</div>
                </div>

                <div id="center-stage-weapon">
                    <div class="center-stage-label">Equipped Weapon</div>
                    <div class="cards-row" id="equippedWeapon">
                        <div class="empty-slot">No Weapon</div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn btn-primary" id="btnDrawRoom" disabled>⚔️ Enter Chamber</button>
                    <button class="btn btn-success" id="btnAvoidRoom" disabled>🛡️ Evade</button>
                    <button class="btn btn-warning" id="btnUndo" disabled style="display: none;">↩️ Undo Last Move</button>
                </div>
            </div>

            <!-- RIGHT PANEL (ABILITY, HOLD, DISCARD, TIMER) -->
            <div class="right-sidebar">
                <!-- Class Ability Button - COMPACT -->
                <div style="
                    margin-bottom: 15px;
                    background: linear-gradient(135deg, rgba(201,169,97,0.1) 0%, rgba(42,35,24,0.6) 100%);
                    border: 2px solid #d4af37;
                    border-radius: 10px;
                    padding: 10px;
                    box-shadow: 0 3px 12px rgba(212,175,55,0.3);
                ">
                    <button id="btnClassAbility" class="btn btn-primary" style="
                        width: 100%;
                        padding: 10px 8px;
                        font-size: 0.9em;
                        font-family: 'Cinzel', serif;
                        background: linear-gradient(180deg, #ffd700 0%, #c9a961 100%);
                        border: 2px solid #d4af37;
                        color: #1a1410;
                        font-weight: bold;
                        position: relative;
                        border-radius: 8px;
                        box-shadow: 0 3px 8px rgba(255,215,0,0.4);
                        transition: all 0.3s ease;
                        cursor: pointer;
                    " 
                    onmouseover="if(!this.disabled) { this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 12px rgba(255,215,0,0.6)'; }"
                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 3px 8px rgba(255,215,0,0.4)';"
                    title="Class special ability">
                        <span id="abilityIcon" style="font-size: 1.3em; margin-right: 5px;">✨</span>
                        <span id="abilityName" style="font-size: 0.85em;">Ability</span>
                        <div id="abilityCooldownDisplay" style="
                            position: absolute;
                            top: 3px;
                            right: 3px;
                            font-size: 0.6em;
                            background: rgba(255,107,107,0.95);
                            padding: 2px 6px;
                            border-radius: 10px;
                            color: #fff;
                            font-weight: bold;
                            box-shadow: 0 1px 3px rgba(0,0,0,0.5);
                        "></div>
                    </button>
                    <div id="abilityDescription" style="
                        font-size: 0.65em;
                        color: #d4af37;
                        text-align: center;
                        margin-top: 6px;
                        padding: 6px;
                        background: rgba(0,0,0,0.4);
                        border-radius: 5px;
                        line-height: 1.3;
                        border: 1px solid rgba(201,169,97,0.2);
                    "></div>
                </div>
                
                <div class="hold-area">
                    <div class="sidebar-label hold-label">Held Card</div>
                    <div id="holdAreaContainer">
                        <div class="empty-slot" id="holdSlotPlaceholder" style="font-size: 0.85em; line-height: 1.3;">Tap & hold any card<br>to save for later</div>
                    </div>
                </div>
                
                <div class="sidebar-label discard-label">Discard</div>
                <div id="discardPilePreview">
                    <!-- Discard mini-cards -->
                </div>
                
                <!-- Timer moved to top-bar -->
            </div>

        </div>

        <!-- BOTTOM BAR (ROOM / "HAND") -->
        <div class="bottom-bar" id="room">
            <!-- The 4 room cards appear here -->
            <div class="empty-slot">Click "Enter Dungeon" to start</div>
        </div>
    </div>


    <!-- ============================================ -->
    <!-- MODALS
    <!-- ============================================ -->

    <!-- Modal: New Game -->
    <div class="modal-overlay" id="newGameModal">
        <div class="modal-content" style="max-width: 600px !important; max-height: 90vh; overflow-y: auto;">
            <h2>✨ New Game</h2>
            <div class="form-group">
                <label for="playerNameInput">👤 Player Name (3-10 characters) *</label>
                <input type="text" id="playerNameInput" placeholder="Enter your name" minlength="3" maxlength="10" required>
                <div id="nameError" style="display: none; color: #ff6b6b; font-size: 0.9em; margin-top: 5px; font-weight: bold;"></div>
                <small style="color: #aaa; font-size: 0.85em;">Minimum 3, maximum 10 characters</small>
            </div>
            <div class="form-group">
                <label>🔥 Difficulty</label>
                <div class="difficulty-selector" id="difficultySelector">
                    <button class="difficulty-btn easy" data-difficulty="easy">
                        🟢 Easy<br><small>20 HP | 30 🪙</small>
                    </button>
                    <button class="difficulty-btn normal selected" data-difficulty="normal">
                        🟡 Normal<br><small>15 HP | 15 🪙</small>
                    </button>
                    <button class="difficulty-btn hard" data-difficulty="hard">
                        🔴 Hard<br><small>10 HP | 0 🪙</small>
                    </button>
                    <button class="difficulty-btn endless" data-difficulty="endless">
                        ♾️ Endless<br><small>15 HP | 15 🪙</small>
                    </button>
                </div>
                <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin-top: 10px; font-size: 0.9em; color: #ddd; line-height: 1.5;">
                    <strong>⚔️ Weapon Durability:</strong> Easy: 3 | Normal: 2 | Hard: 1 | Endless: 2
                    <br><br><strong>💎 Gold & Events:</strong>
                    <br>• <strong>🟢 Easy:</strong> More gold & events (40%)
                    <br>• <strong>🟡 Normal:</strong> Balanced (30%)
                    <br>• <strong>🔴 Hard:</strong> Less gold & events (20%)
                    <br><br><strong>↩️ Undo:</strong> Available on Easy & Normal only
                    <br><br><strong>👹 Boss Battles:</strong> Every 10 rooms!
                    <br><br><strong>Higher difficulty = Bigger score multiplier!</strong>
                </div>
            </div>
            <div class="modal-controls">
                <button class="btn btn-success" id="btnStartGameModal">⚔️ Start Quest!</button>
                <button class="btn btn-secondary" id="btnCancelStart">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Modal: Class Selection -->
    <div class="modal-overlay" id="classSelectionModal">
        <div class="modal-content" style="max-width: 1000px !important; width: 90vw !important; padding: 40px 30px !important;">
            <h2 id="classSelectionTitle" style="text-align: center; font-family: 'Cinzel', serif; color: #c9a961; margin-bottom: 10px;">⚔️ SELECT YOUR HERO</h2>
            <p id="classSelectionSubtitle" style="text-align: center; color: #8b7355; font-size: 0.9em; margin-bottom: 20px; min-height: 20px;"></p>
            
            <!-- Class Avatars (Horizontal) -->
            <div style="display: flex; gap: 20px; margin-bottom: 25px; justify-content: center; flex-wrap: wrap;">
                <!-- Scoundrel -->
                <div class="class-card" data-class="scoundrel" style="
                    background: linear-gradient(180deg, #2a2318 0%, #1a1410 100%);
                    border: 2px solid #5a4a38;
                    border-radius: 8px;
                    padding: 10px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: center;
                    flex: 0 0 auto;
                    width: 240px;
                    box-sizing: border-box;
                " onmouseover="this.style.borderColor='#c9a961'; this.style.transform='translateY(-5px)'" onmouseout="if(!this.classList.contains('selected')) { this.style.borderColor='#5a4a38'; this.style.transform='translateY(0)' }">
                    <div style="width: 216px; height: 324px; overflow: hidden; border-radius: 4px; border: 2px solid #5a4a38; margin: 0 auto 8px auto;">
                        <img src="assets/avatar-scoundrel.jpg" alt="Scoundrel" style="width: 100%; height: 100%; object-fit: cover; display: block;">
                    </div>
                    <h3 style="color: #c9a961; font-family: 'Cinzel', serif; margin: 0; font-size: 1em;">SCOUNDREL</h3>
                </div>
                
                <!-- Knight -->
                <div class="class-card" data-class="knight" style="
                    background: linear-gradient(180deg, #2a2318 0%, #1a1410 100%);
                    border: 2px solid #5a4a38;
                    border-radius: 8px;
                    padding: 10px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: center;
                    flex: 0 0 auto;
                    width: 240px;
                    box-sizing: border-box;
                " onmouseover="this.style.borderColor='#c9a961'; this.style.transform='translateY(-5px)'" onmouseout="if(!this.classList.contains('selected')) { this.style.borderColor='#5a4a38'; this.style.transform='translateY(0)' }">
                    <div style="width: 216px; height: 324px; overflow: hidden; border-radius: 4px; border: 2px solid #5a4a38; margin: 0 auto 8px auto;">
                        <img src="assets/avatar-knight.jpg" alt="Knight" style="width: 100%; height: 100%; object-fit: cover; display: block;">
                    </div>
                    <h3 style="color: #c9a961; font-family: 'Cinzel', serif; margin: 0; font-size: 1em;">KNIGHT</h3>
                </div>
                
                <!-- Rogue -->
                <div class="class-card" data-class="rogue" style="
                    background: linear-gradient(180deg, #2a2318 0%, #1a1410 100%);
                    border: 2px solid #5a4a38;
                    border-radius: 8px;
                    padding: 10px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: center;
                    flex: 0 0 auto;
                    width: 240px;
                    box-sizing: border-box;
                " onmouseover="this.style.borderColor='#c9a961'; this.style.transform='translateY(-5px)'" onmouseout="if(!this.classList.contains('selected')) { this.style.borderColor='#5a4a38'; this.style.transform='translateY(0)' }">
                    <div style="width: 216px; height: 324px; overflow: hidden; border-radius: 4px; border: 2px solid #5a4a38; margin: 0 auto 8px auto;">
                        <img src="assets/avatar-rogue.jpg" alt="Rogue" style="width: 100%; height: 100%; object-fit: cover; display: block;">
                    </div>
                    <h3 style="color: #c9a961; font-family: 'Cinzel', serif; margin: 0; font-size: 1em;">ROGUE</h3>
                </div>
                
                <!-- Dancer -->
                <div class="class-card" data-class="dancer" style="
                    background: linear-gradient(180deg, #2a2318 0%, #1a1410 100%);
                    border: 2px solid #5a4a38;
                    border-radius: 8px;
                    padding: 10px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: center;
                    flex: 0 0 auto;
                    width: 240px;
                    box-sizing: border-box;
                " onmouseover="this.style.borderColor='#c9a961'; this.style.transform='translateY(-5px)'" onmouseout="if(!this.classList.contains('selected')) { this.style.borderColor='#5a4a38'; this.style.transform='translateY(0)' }">
                    <div style="width: 216px; height: 324px; overflow: hidden; border-radius: 4px; border: 2px solid #5a4a38; margin: 0 auto 8px auto;">
                        <img src="assets/avatar-dancer.jpg" alt="Dancer" style="width: 100%; height: 100%; object-fit: cover; display: block;">
                    </div>
                    <h3 style="color: #c9a961; font-family: 'Cinzel', serif; margin: 0; font-size: 1em;">DANCER</h3>
                </div>
                
                <!-- Berserker -->
                <div class="class-card" data-class="berserker" style="
                    background: linear-gradient(180deg, #2a2318 0%, #1a1410 100%);
                    border: 2px solid #5a4a38;
                    border-radius: 8px;
                    padding: 10px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: center;
                    flex: 0 0 auto;
                    width: 240px;
                    box-sizing: border-box;
                " onmouseover="this.style.borderColor='#c9a961'; this.style.transform='translateY(-5px)'" onmouseout="if(!this.classList.contains('selected')) { this.style.borderColor='#5a4a38'; this.style.transform='translateY(0)' }">
                    <div style="width: 216px; height: 324px; overflow: hidden; border-radius: 4px; border: 2px solid #5a4a38; margin: 0 auto 8px auto;">
                        <img src="assets/avatar-berserker.jpg" alt="Berserker" style="width: 100%; height: 100%; object-fit: cover; display: block;">
                    </div>
                    <h3 style="color: #c9a961; font-family: 'Cinzel', serif; margin: 0; font-size: 1em;">BERSERKER</h3>
                </div>
                
                <!-- Priest -->
                <div class="class-card" data-class="priest" style="
                    background: linear-gradient(180deg, #2a2318 0%, #1a1410 100%);
                    border: 2px solid #5a4a38;
                    border-radius: 8px;
                    padding: 10px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                    text-align: center;
                    flex: 0 0 auto;
                    width: 240px;
                    box-sizing: border-box;
                " onmouseover="this.style.borderColor='#c9a961'; this.style.transform='translateY(-5px)'" onmouseout="if(!this.classList.contains('selected')) { this.style.borderColor='#5a4a38'; this.style.transform='translateY(0)' }">
                    <div style="width: 216px; height: 324px; overflow: hidden; border-radius: 4px; border: 2px solid #5a4a38; margin: 0 auto 8px auto;">
                        <img src="assets/avatar-priest.jpg" alt="Priest" style="width: 100%; height: 100%; object-fit: cover; display: block;">
                    </div>
                    <h3 style="color: #c9a961; font-family: 'Cinzel', serif; margin: 0; font-size: 1em;">PRIEST</h3>
                </div>
            </div>
            
            <!-- Class Description -->
            <div id="classDescription" style="
                background: rgba(0,0,0,0.4);
                border: 1px solid #5a4a38;
                border-radius: 8px;
                padding: 20px;
                min-height: 150px;
                margin-bottom: 20px;
                display: none;
            ">
                <h3 id="classDescTitle" style="color: #c9a961; font-family: 'Cinzel', serif; margin-top: 0;"></h3>
                <p id="classDescMotivation" style="color: #d4af37; font-style: italic; margin-bottom: 15px;"></p>
                <p id="classDescMechanics" style="color: #ddd; line-height: 1.6;"></p>
            </div>
            
            <div class="modal-controls">
                <button class="btn btn-success" id="btnConfirmClass" disabled>⚔️ Begin Adventure!</button>
                <button class="btn btn-secondary" id="btnCancelClass">Back</button>
            </div>
        </div>
    </div>
    
    <!-- Modal: Interactive Tutorial -->
    <div class="modal-overlay" id="interactiveTutorialModal">
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <h2 id="tutorialStepTitle">🎮 Interactive Tutorial</h2>
            <div id="tutorialStepContent" style="min-height: 300px; padding: 20px; background: rgba(0,0,0,0.3); border-radius: 8px; margin: 20px 0;">
                <!-- Dynamic content here -->
            </div>
            <div style="display: flex; gap: 15px; justify-content: center; margin-top: 20px;">
                <button class="btn btn-secondary" id="btnTutorialPrev" disabled>⬅️ Previous</button>
                <button class="btn btn-primary" id="btnTutorialNext">➡️ Next</button>
                <button class="btn btn-secondary" id="btnTutorialSkip">⏩ Skip Tutorial</button>
            </div>
            <div style="text-align: center; margin-top: 15px; color: #aaa; font-size: 0.9em;">
                Step <span id="tutorialCurrentStep">1</span> of <span id="tutorialTotalSteps">8</span>
            </div>
        </div>
    </div>
    
    <!-- Modal: Tutorial (Read Guide) -->
    <div class="modal-overlay" id="tutorialModal">
        <div class="modal-content">
            <h2>📜 How to Play</h2>
            
            <div class="tutorial-section">
                <h3>🎯 Objective</h3>
                <p>Clear all cards from the Dungeon deck without your health reaching zero!</p>
            </div>

            <div class="tutorial-section">
                <h3>🎮 Gameplay</h3>
                <p><strong>1. Start the Action:</strong></p>
                <p>• Choose <strong>"Enter Dungeon"</strong> (draws 4 cards) or <strong>"Avoid Dungeon"</strong> (discards 3 cards from the top). You cannot avoid two dungeons in a row.</p>
                <p><strong>2. Clear the Dungeon:</strong></p>
                <p>• You must use or discard all 4 cards from the dungeon (in the bottom bar) to advance.</p>
            </div>

            <div class="tutorial-section">
                <h3>🃏 Card Types</h3>
                <p>
                    <span class="tutorial-card-demo monster">♠️ ♣️ Monsters (Spades & Clubs)</span>
                    <br>Click to fight. You take damage = (Monster Value) - (Your Weapon Value). If your weapon is stronger, you take no damage.
                </p>
                <p>
                    <span class="tutorial-card-demo weapon">♦️ Weapons (Diamonds)</span>
                    <br>Click to equip. Replaces your current weapon.
                </p>
                <p>
                    <span class="tutorial-card-demo potion">♥️ Potions (Hearts)</span>
                    <br>Click to heal. Limit of 1 potion per dungeon!
                </p>
            </div>

            <div class="tutorial-section">
                <h3>📌 "Hold" System</h3>
                <p><strong>Tap & hold</strong> (or <strong>right-click</strong> on desktop) cards in the room (bottom bar) to save them in the "Held" area (right sidebar).</p>
                <p>• <strong>Can hold:</strong> Weapons ⚔️, Potions 💊, and Specials ✨</p>
                <p>• <strong>Cannot hold:</strong> Monsters 👹 (must be fought immediately!)</p>
                <p>• Only 1 card can be held at a time.</p>
                <p>• Tap the held card to use it immediately (returns to room).</p>
                <p>• <strong>Strategy:</strong> Hold a weapon to skip it now and equip later, or hold a potion for when you need it most!</p>
            </div>
            
            <div class="tutorial-section">
                <h3>⚠️ Weapon Durability</h3>
                <p>Weapons break after use! Easy: 3 uses | Normal: 2 | Hard: 1</p>
                <p>• Colored bar shows durability (🟢 good, 🟡 medium, 🔴 low)</p>
                <p>• Repair in shop or find 🔨 Durable Weapons relic for infinite durability</p>
                <p>• <strong>⛔ Warning:</strong> Equipping a new weapon breaks your combo!</p>
            </div>
            
            <div class="tutorial-section">
                <h3>🔥 Combo System</h3>
                <p><strong>Build combos by killing monsters without taking damage!</strong></p>
                <p>• <strong>Combo increases:</strong> Perfect kills (no damage taken)</p>
                <p>• <strong>Combo persists:</strong> Between rooms - keep it going!</p>
                <p>• <strong>Combo breaks:</strong> Taking damage OR equipping a weapon</p>
                <p>• <strong>Potions don't break combo</strong> - use them strategically!</p>
                <p>• <strong>Visual rewards:</strong> 5x = GREAT!, 7x = AMAZING!, 10x = LEGENDARY!</p>
                <p>• <strong>Score bonus:</strong> Max combo x10 points in final score</p>
            </div>
            
            <div class="tutorial-section">
                <h3>👹 Boss Battles</h3>
                <p><strong>Every 10th room is a BOSS ROOM!</strong></p>
                <p>• Bosses have <strong>15 HP</strong> and require multiple hits</p>
                <p>• <strong>HP bar</strong> shows boss health (🟢→🟡→🔴)</p>
                <p>• <strong>⚠️ Critical:</strong> If you fight a boss <strong>WITHOUT a weapon</strong>:</p>
                <p>&nbsp;&nbsp;&nbsp;• Boss attacks once and flees</p>
                <p>&nbsp;&nbsp;&nbsp;• You take full damage (15 HP!)</p>
                <p>&nbsp;&nbsp;&nbsp;• <strong>NO GOLD REWARD</strong></p>
                <p>• <strong>💡 Strategy:</strong> Always have a weapon before room 10, 20, 30...</p>
            </div>
            
            <div class="tutorial-section">
                <h3>💰 Gold & Economy</h3>
                <p>• <strong>Gold varies by difficulty:</strong> Easy = More | Normal = Balanced | Hard = Much less</p>
                <p>• Get gold from: Monsters, rooms, relics, events</p>
                <p>• <strong>💡 Tip:</strong> On Hard mode, every coin counts!</p>
            </div>
            
            <div class="tutorial-section">
                <h3>🏺 Merchant & 🔮 Relics</h3>
                <p>• <strong>Merchant:</strong> Click 🏺 MERCHANT to spend gold on heals, relics, and upgrades.</p>
                <p>• <strong>Relics by Rarity:</strong></p>
                <p>&nbsp;&nbsp;&nbsp;⚪ Common (25🪙) - Basic bonuses</p>
                <p>&nbsp;&nbsp;&nbsp;🟢 Uncommon (50🪙) - Moderate bonuses</p>
                <p>&nbsp;&nbsp;&nbsp;🔵 Rare (100🪙) - Powerful bonuses</p>
                <p>&nbsp;&nbsp;&nbsp;🟠 Legendary (200🪙) - Game-changing!</p>
                <p>• <strong>⚠️ Shop Penalty:</strong> Each shop visit costs -50 points in final score</p>
                <p>• <strong>Events:</strong> 🎲 Random encounters after clearing rooms. Make choices!</p>
                <p>• <strong>Unlocks:</strong> 🔓 Permanent progress that carries over between runs!</p>
            </div>
            
            <div class="tutorial-section">
                <h3>🏆 Score System</h3>
                <p><strong>Victory score is calculated from multiple factors:</strong></p>
                <p>• <strong>Base Bonuses:</strong></p>
                <p>&nbsp;&nbsp;&nbsp;🎯 Win Bonus: +1000</p>
                <p>&nbsp;&nbsp;&nbsp;❤️ Health: HP x 20</p>
                <p>&nbsp;&nbsp;&nbsp;💰 Gold: Total earned x 5</p>
                <p>&nbsp;&nbsp;&nbsp;🔥 Combo: Max combo x 10</p>
                <p>&nbsp;&nbsp;&nbsp;⚔️ Monsters: Slain x 2</p>
                <p>• <strong>Special Bonuses:</strong></p>
                <p>&nbsp;&nbsp;&nbsp;⚡ Speedrun: +500 (<5 min) or +250 (<10 min)</p>
                <p>&nbsp;&nbsp;&nbsp;🏆 Perfect Run: +1000 (no damage taken!)</p>
                <p>• <strong>Penalties:</strong></p>
                <p>&nbsp;&nbsp;&nbsp;⏱️ Time: -2 points per second</p>
                <p>&nbsp;&nbsp;&nbsp;🏺 Shop: -50 per visit</p>
                <p>• <strong>Difficulty Multiplier:</strong> Easy x1, Normal x1.5, Hard x2.5</p>
            </div>
            
            <div class="tutorial-section" style="background: rgba(255, 215, 0, 0.1); border: 2px solid #ffd700; padding: 15px; border-radius: 8px;">
                <h3>💡 Pro Tips</h3>
                <p>• <strong>Combo strategy:</strong> Don't equip weapons mid-combo unless absolutely necessary</p>
                <p>• <strong>Boss prep:</strong> Always check your weapon before room 10, 20, 30...</p>
                <p>• <strong>Shop discipline:</strong> Each shop visit costs score - use it wisely!</p>
                <p>• <strong>Speedrun tip:</strong> <5 minutes = +500 bonus points!</p>
                <p>• <strong>Perfect run:</strong> Take zero damage for +1000 bonus!</p>
                <p>• <strong>Hold system:</strong> Save healing potions for emergencies</p>
            </div>
            
            <button class="close-modal-btn" id="btnCloseTutorial">Got it!</button>
        </div>
    </div>
    
    <!-- Modal: Leaderboard -->
    <div class="modal-overlay" id="leaderboardModal">
        <div class="modal-content" style="max-width: 700px;">
            <h2>🏆 Hall of Fame (Top 10)</h2>
            
            <!-- Difficulty Tabs -->
            <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
                <button class="difficulty-tab active" data-difficulty="easy" onclick="switchLeaderboardDifficulty('easy')">
                    🟢 Easy
                </button>
                <button class="difficulty-tab" data-difficulty="normal" onclick="switchLeaderboardDifficulty('normal')">
                    🟡 Normal
                </button>
                <button class="difficulty-tab" data-difficulty="hard" onclick="switchLeaderboardDifficulty('hard')">
                    🔴 Hard
                </button>
                <button class="difficulty-tab" data-difficulty="endless" onclick="switchLeaderboardDifficulty('endless')">
                    ♾️ Endless
                </button>
            </div>
            
            <div id="leaderboardList" style="max-height: 400px; overflow-y: auto; padding-right: 10px;">
                <p style="text-align: center; color: #aaa;">Loading scores...</p>
            </div>
            <button class="close-modal-btn" id="btnCloseLeaderboard">Close</button>
        </div>
    </div>
    
    <!-- Other Modals (Shop, Event, Unlocks) - Identical structure -->
    <div class="modal-overlay" id="shopModal">
        <div class="modal-content">
            <h2>🏺 Merchant's Wares</h2>
            <p style="text-align: center; color: #aaa; margin-bottom: 20px;">
                Spend your gold wisely! (Gold: <span id="shopGoldAmount">0</span>)
            </p>
            <div id="shopItems" style="max-height: 400px; overflow-y: auto; padding-right: 10px;"></div>
            <button class="close-modal-btn" id="btnCloseShop">Leave Shop</button>
        </div>
    </div>

    <div class="modal-overlay" id="eventModal">
        <div class="modal-content">
            <h2 id="eventTitle">🎲 Event</h2>
            <div class="event-text" id="eventText"></div>
            <div id="eventChoices"></div>
            <!-- Close button not needed, choice closes modal -->
        </div>
    </div>

    <div class="modal-overlay" id="unlocksModal">
        <div class="modal-content">
            <h2>🗝️ Permanent Upgrades</h2>
            <p style="text-align: center; color: #aaa; margin-bottom: 20px;">
                Progress that continues between runs!
            </p>
            <div id="unlocksList" style="max-height: 400px; overflow-y: auto; padding-right: 10px;"></div>
            <button class="close-modal-btn" id="btnCloseUnlocks">Close</button>
        </div>
    </div>
    
    <!-- Modal: Give Up Confirmation -->
    <div class="modal-overlay" id="giveUpModal">
        <div class="modal-content">
            <h2>🏳️ Give Up?</h2>
            <p class="event-text" style="text-align: center;">Are you sure you want to end this run? Your progress will be lost and your score will be 0.</p>
            <div class="modal-controls" style="flex-direction: row; justify-content: center;">
                <button class="btn btn-secondary" id="btnCancelGiveUp">Cancel</button>
                <button class="btn btn-danger" id="btnConfirmGiveUp">Give Up</button>
            </div>
        </div>
    </div>
    
    <!-- Modal: Achievements -->
    <div class="modal-overlay" id="achievementsModal">
        <div class="modal-content" style="max-width: 900px;">
            <h2>🏆 Achievements</h2>
            <p style="text-align: center; color: #aaa; margin-bottom: 20px;">
                <span id="achievementStats">0/50 Unlocked</span> | 
                🥉 <span id="bronzeCount">0/25</span> | 
                🥈 <span id="silverCount">0/15</span> | 
                🥇 <span id="goldCount">0/9</span> | 
                💎 <span id="platinumCount">0/1</span>
            </p>
            <div id="achievementsList" class="achievements-grid"></div>
            <button class="close-modal-btn" id="btnCloseAchievements">Close</button>
        </div>
    </div>
    
    <!-- Modal: Soundboard -->
    <div class="modal-overlay" id="soundboardModal">
        <div class="modal-content" style="max-width: 600px;">
            <h2>🎵 Soundboard - Dark Atmospheric Music</h2>
            <p style="color: #aaa; margin-bottom: 20px;">Preview all atmospheric tracks from the game!</p>
            
            <div style="display: grid; gap: 15px;">
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 2px solid #8b7355;">
                    <h3 style="color: #d4af37; margin-bottom: 10px;">🏰 Dark Awakening</h3>
                    <p style="color: #bbb; font-size: 0.9em; margin-bottom: 10px;">Menu Theme - Mysterious, inviting, dark</p>
                    <button class="btn btn-primary" id="btnPlayMenu" style="width: 100%;">▶️ Play</button>
                </div>
                
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 2px solid #8b7355;">
                    <h3 style="color: #d4af37; margin-bottom: 10px;">⚔️ Into the Depths</h3>
                    <p style="color: #bbb; font-size: 0.9em; margin-bottom: 10px;">Gameplay Theme - Tense, adventurous</p>
                    <button class="btn btn-primary" id="btnPlayGameplay" style="width: 100%;">▶️ Play</button>
                </div>
                
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 2px solid #8b7355;">
                    <h3 style="color: #d4af37; margin-bottom: 10px;">🛍️ Merchant's Shadow</h3>
                    <p style="color: #bbb; font-size: 0.9em; margin-bottom: 10px;">Shop Theme - Calm but mysterious</p>
                    <button class="btn btn-primary" id="btnPlayShop" style="width: 100%;">▶️ Play</button>
                </div>
                
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 2px solid #8b7355;">
                    <h3 style="color: #d4af37; margin-bottom: 10px;">👑 Triumph in Darkness</h3>
                    <p style="color: #bbb; font-size: 0.9em; margin-bottom: 10px;">Victory Theme - Epic, celebratory</p>
                    <button class="btn btn-primary" id="btnPlayVictory" style="width: 100%;">▶️ Play</button>
                </div>
                
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 2px solid #8b7355;">
                    <h3 style="color: #d4af37; margin-bottom: 10px;">💀 The Final Darkness</h3>
                    <p style="color: #bbb; font-size: 0.9em; margin-bottom: 10px;">Defeat Theme - Dark, respectful</p>
                    <button class="btn btn-primary" id="btnPlayDefeat" style="width: 100%;">▶️ Play</button>
                </div>
            </div>
            
            <button class="close-modal-btn" id="btnCloseSoundboard" style="margin-top: 20px;">Close</button>
        </div>
    </div>
    
    <!-- Modal: Give Up -->
    <div class="modal-overlay" id="giveUpModal">
        <div class="modal-content" style="max-width: 500px; border: 3px solid #ff6b6b;">
            <h2 style="color: #ff6b6b;">🏳️ GIVE UP?</h2>
            <p style="text-align: center; color: #ddd; font-size: 1.1em; margin: 20px 0;">
                Are you sure you want to end this run?<br>
                Your progress will be lost and your score will be 0.
            </p>
            <div class="modal-controls" style="gap: 15px;">
                <button class="btn btn-secondary" id="btnCancelGiveUp">Cancel</button>
                <button class="btn btn-danger" id="btnConfirmGiveUp" style="background: #ff6b6b; border-color: #ff6b6b;">Give Up</button>
            </div>
        </div>
    </div>
    
    <!-- Game Over Overlay (will be created via JS) -->
    
    <!-- ============================================ -->
    <!-- FIREBASE CONFIG (Load before main script)
    <!-- ============================================ -->
    <script src="src/config/firebase-config.js"></script>
    
    <!-- ============================================ -->
    <!-- GAME SCRIPT
    <!-- ============================================ -->
    <script type="module">
        // ============================================
        // FIREBASE IMPORTS
        // ============================================
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, collection, query, getDocs, limit, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ============================================
        // FIREBASE INITIALIZATION
        // ============================================
        let db, auth, appId, userId;

        try {
            // __firebase_config and __app_id are injected by the environment
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // setLogLevel('debug'); // Useful for debugging
            
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    console.log("Firebase Auth: User signed in:", userId);
                } else {
                    try {
                        const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                        if (token) {
                            await signInWithCustomToken(auth, token);
                        } else {
                            await signInAnonymously(auth);
                        }
                        userId = auth.currentUser?.uid || crypto.randomUUID();
                        console.log("Firebase Auth: New user session:", userId);
                    } catch (error) {
                        console.error("Firebase Auth Error:", error);
                        userId = crypto.randomUUID(); // Fallback
                    }
                }
            });
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            // The game continues offline if Firebase fails
        }
        
        // ============================================
        // OPTIMIZATION HELPERS
        // ============================================
        
        // Storage Cache - Optimizes localStorage operations with error handling
        class StorageCache {
            constructor() {
                this.cache = {};
                this.storageAvailable = this.checkStorageAvailability();
            }
            
            checkStorageAvailability() {
                try {
                    const test = '__storage_test__';
                    localStorage.setItem(test, test);
                    localStorage.removeItem(test);
                    return true;
                } catch(e) {
                    console.warn('LocalStorage not available:', e);
                    return false;
                }
            }
            
            get(key, defaultValue = {}) {
                if (!this.storageAvailable) return defaultValue;
                
                if (this.cache[key] === undefined) {
                    try {
                        const data = localStorage.getItem(key);
                        this.cache[key] = data ? JSON.parse(data) : defaultValue;
                    } catch(e) {
                        console.error(`Error reading ${key}:`, e);
                        this.cache[key] = defaultValue;
                    }
                }
                return this.cache[key];
            }
            
            set(key, value) {
                if (!this.storageAvailable) {
                    console.warn('Storage not available, using cache only');
                    this.cache[key] = value;
                    return false;
                }
                
                this.cache[key] = value;
                try {
                    localStorage.setItem(key, JSON.stringify(value));
                    return true;
                } catch(e) {
                    if (e.name === 'QuotaExceededError') {
                        console.error('Storage quota exceeded');
                        // Try to clear old data
                        this.clearOldData();
                    } else {
                        console.error(`Error saving ${key}:`, e);
                    }
                    return false;
                }
            }
            
            update(key, updater) {
                const current = this.get(key);
                const updated = updater(current);
                this.set(key, updated);
                return updated;
            }
            
            invalidate(key) {
                delete this.cache[key];
            }
            
            clearCache() {
                this.cache = {};
            }
            
            clearOldData() {
                // Clear non-essential data if quota exceeded
                try {
                    const keysToPreserve = ['scoundrel_lifetime_stats', 'scoundrel_unlocks'];
                    for (let i = 0; i < localStorage.length; i++) {
                        const key = localStorage.key(i);
                        if (key && !keysToPreserve.includes(key)) {
                            localStorage.removeItem(key);
                            delete this.cache[key];
                        }
                    }
                } catch(e) {
                    console.error('Error clearing old data:', e);
                }
            }
        }
        
        const storage = new StorageCache();
        
        // DOM Helpers - Optimizes DOM manipulations
        function createElementFromHTML(html) {
            const template = document.createElement('template');
            template.innerHTML = html.trim();
            return template.content.firstChild;
        }
        
        function createElementsFragment(items, createItemHTML, attachHandlers = null) {
            const fragment = document.createDocumentFragment();
            
            items.forEach(item => {
                const html = createItemHTML(item);
                const element = createElementFromHTML(html);
                
                if (attachHandlers) {
                    attachHandlers(element, item);
                }
                
                fragment.appendChild(element);
            });
            
            return fragment;
        }
        
        function updateList(container, items, createItemHTML, attachHandlers = null) {
            const fragment = createElementsFragment(items, createItemHTML, attachHandlers);
            container.innerHTML = '';
            container.appendChild(fragment);
        }
        
        // Modal Manager - Simplified modal management
        const modalManager = {
            open(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) modal.classList.add('active');
            },
            close(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) modal.classList.remove('active');
            },
            toggle(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) modal.classList.toggle('active');
            }
        };
        
        console.log('✅ Optimization helpers loaded!');
        
        // ============================================
        // DOM ELEMENTS (NEW STRUCTURE)
        // ============================================
        
        // Screens
        const welcomeScreen = document.getElementById('welcomeScreen');
        const gameWrapper = document.getElementById('gameWrapper');
        
        // Welcome Buttons
        const btnWelcomeStart = document.getElementById('btnWelcomeStart');
        const btnPlayTutorial = document.getElementById('btnPlayTutorial');
        const btnWelcomeTutorial = document.getElementById('btnWelcomeTutorial');
        const btnWelcomeLeaderboard = document.getElementById('btnWelcomeLeaderboard');
        const btnWelcomeUnlocks = document.getElementById('btnWelcomeUnlocks');
        
        // Interactive Tutorial Elements
        const interactiveTutorialModal = document.getElementById('interactiveTutorialModal');
        const tutorialStepTitle = document.getElementById('tutorialStepTitle');
        const tutorialStepContent = document.getElementById('tutorialStepContent');
        const btnTutorialPrev = document.getElementById('btnTutorialPrev');
        const btnTutorialNext = document.getElementById('btnTutorialNext');
        const btnTutorialSkip = document.getElementById('btnTutorialSkip');
        const tutorialCurrentStep = document.getElementById('tutorialCurrentStep');
        const tutorialTotalSteps = document.getElementById('tutorialTotalSteps');
        
        // New Game Modal
        const newGameModal = document.getElementById('newGameModal');
        const playerNameInput = document.getElementById('playerNameInput');
        const difficultySelector = document.getElementById('difficultySelector');
        const btnStartGameModal = document.getElementById('btnStartGameModal');
        const btnCancelStart = document.getElementById('btnCancelStart');

        // Game Bars
        const topBar = document.querySelector('.top-bar');
        const centerArea = document.querySelector('.center-area');
        const bottomBar = document.getElementById('room'); // Bottom bar is the room
        
        // Side Panels
        const relicsPanel = document.getElementById('relicsPanel');
        const relicsList = document.getElementById('relicsList');
        const btnOpenShop = document.getElementById('btnOpenShop');
        const holdAreaContainer = document.getElementById('holdAreaContainer');
        const discardPilePreview = document.getElementById('discardPilePreview');
        const gameTimer = document.getElementById('gameTimer');
        
        // Center Stage
        const messageArea = document.getElementById('messageArea');
        const equippedWeaponEl = document.getElementById('equippedWeapon');
        const btnDrawRoom = document.getElementById('btnDrawRoom');
        const btnAvoidRoom = document.getElementById('btnAvoidRoom');
        const mainScoreValue = document.getElementById('mainScoreValue'); // New Score Element
        
        // Top Bar Stats
        const healthEl = document.getElementById('health');
        const goldEl = document.getElementById('goldAmount');
        // scoreEl removed
        const dungeonCountEl = document.getElementById('dungeonCount');
        const statRoomsEl = document.getElementById('statRooms');
        
        // Achievements
        const achievementsCompact = document.getElementById('achievementsCompact');
        const achievementCounter = document.getElementById('achievementCounter');
        const achievementsModal = document.getElementById('achievementsModal');
        const achievementsList = document.getElementById('achievementsList');
        
        // Top Bar Buttons
        const btnTopSound = document.getElementById('btnTopSound');
        const btnMusicPrev = document.getElementById('btnMusicPrev');
        const btnMusicToggle = document.getElementById('btnMusicToggle');
        const btnMusicNext = document.getElementById('btnMusicNext');
        const btnTopTutorial = document.getElementById('btnTopTutorial');
        const btnTopLeaderboard = document.getElementById('btnTopLeaderboard');
        const btnTopUnlocks = document.getElementById('btnTopUnlocks');
        const btnTopGiveUp = document.getElementById('btnTopGiveUp'); // Give Up Button

        // Modals
        const tutorialModal = document.getElementById('tutorialModal');
        const leaderboardModal = document.getElementById('leaderboardModal');
        const shopModal = document.getElementById('shopModal');
        const eventModal = document.getElementById('eventModal');
        const unlocksModal = document.getElementById('unlocksModal');
        const giveUpModal = document.getElementById('giveUpModal'); // Give Up Modal
        
        // Modal Elements
        const shopGoldAmount = document.getElementById('shopGoldAmount');
        const shopItems = document.getElementById('shopItems');
        const eventTitle = document.getElementById('eventTitle');
        const eventText = document.getElementById('eventText');
        const eventChoices = document.getElementById('eventChoices');
        const btnCancelGiveUp = document.getElementById('btnCancelGiveUp'); // Give Up Modal Buttons
        const btnConfirmGiveUp = document.getElementById('btnConfirmGiveUp');
        
        // Close Modals
        document.getElementById('btnCloseTutorial').onclick = () => tutorialModal.classList.remove('active');
        document.getElementById('btnCloseLeaderboard').onclick = () => leaderboardModal.classList.remove('active');
        document.getElementById('btnCloseShop').onclick = () => closeShop(); // Use wrapper
        document.getElementById('btnCloseUnlocks').onclick = () => unlocksModal.classList.remove('active');
        document.getElementById('btnCloseAchievements').onclick = () => achievementsModal.classList.remove('active');
        
        // Open Achievements Modal
        achievementsCompact.onclick = () => {
            updateAchievementsDisplay();
            achievementsModal.classList.add('active');
        };
        
        // ============================================
        // INTERACTIVE TUTORIAL SYSTEM
        // ============================================
        let tutorialStep = 0;
        const tutorialSteps = [
            {
                title: "🎴 Welcome to Dungeon Scoundrel!",
                content: `
                    <div style="text-align: center; padding: 20px;">
                        <h3 style="color: #ffd700; margin-bottom: 20px;">Your Quest Begins!</h3>
                        <p style="font-size: 1.1em; line-height: 1.8; margin-bottom: 20px;">
                            You are a <strong>scoundrel</strong> exploring dark medieval dungeons filled with monsters, treasures, and ancient relics.
                        </p>
                        <div style="background: rgba(0,0,0,0.4); padding: 20px; border-radius: 8px; margin: 20px 0;">
                            <p style="font-size: 1.2em; color: #6bcf7f;"><strong>🎯 Goal:</strong> Clear all 50 cards from the dungeon deck without dying!</p>
                        </div>
                        <img src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 100'%3E%3Crect fill='%232c2416' width='200' height='100'/%3E%3Ctext x='100' y='55' text-anchor='middle' fill='%23d4af37' font-size='40' font-family='serif'%3E🎴🗡️🏰%3C/text%3E%3C/svg%3E" alt="Game Preview" style="width: 100%; max-width: 300px; margin: 20px auto; border-radius: 8px;">
                    </div>
                `
            },
            {
                title: "🃏 Card Types",
                content: `
                    <div style="padding: 20px;">
                        <h3 style="color: #ffd700; margin-bottom: 20px; text-align: center;">Learn the Cards</h3>
                        <div style="display: grid; gap: 20px;">
                            <div style="background: rgba(0,0,0,0.4); padding: 20px; border-left: 4px solid #ff6b6b; border-radius: 8px;">
                                <h4 style="color: #ff6b6b; margin-bottom: 10px;">♠️ ♣️ MONSTERS (Spades & Clubs)</h4>
                                <p><strong>Click to fight!</strong> Damage = Monster Value - Your Weapon Value</p>
                                <p style="margin-top: 10px; color: #aaa; font-size: 0.9em;">💡 Tip: Always have a weapon equipped before fighting!</p>
                            </div>
                            <div style="background: rgba(0,0,0,0.4); padding: 20px; border-left: 4px solid #ffd93d; border-radius: 8px;">
                                <h4 style="color: #ffd93d; margin-bottom: 10px;">♦️ WEAPONS (Diamonds)</h4>
                                <p><strong>Click to equip!</strong> Replaces your current weapon</p>
                                <p style="margin-top: 10px; color: #aaa; font-size: 0.9em;">⚠️ Warning: Equipping breaks your combo!</p>
                            </div>
                            <div style="background: rgba(0,0,0,0.4); padding: 20px; border-left: 4px solid #6bcf7f; border-radius: 8px;">
                                <h4 style="color: #6bcf7f; margin-bottom: 10px;">♥️ POTIONS (Hearts)</h4>
                                <p><strong>Click to heal!</strong> Limit: 1 per room</p>
                                <p style="margin-top: 10px; color: #aaa; font-size: 0.9em;">💊 Potions DON'T break combo!</p>
                            </div>
                        </div>
                    </div>
                `
            },
            {
                title: "📌 Hold System",
                content: `
                    <div style="padding: 20px;">
                        <h3 style="color: #ffd700; margin-bottom: 20px; text-align: center;">Save Cards for Later</h3>
                        <div style="background: rgba(0,0,0,0.4); padding: 25px; border-radius: 8px; text-align: center;">
                            <p style="font-size: 1.2em; margin-bottom: 20px;"><strong>Right-click</strong> or <strong>tap & hold</strong> cards to save them!</p>
                            <div style="margin: 20px 0; padding: 20px; background: rgba(255, 215, 0, 0.1); border: 2px solid #ffd700; border-radius: 8px;">
                                <p style="color: #ffd700; font-size: 1.1em; margin-bottom: 10px;"><strong>✅ CAN HOLD:</strong></p>
                                <p>Weapons ⚔️ | Potions 💊 | Specials ✨</p>
                            </div>
                            <div style="margin: 20px 0; padding: 20px; background: rgba(255, 107, 107, 0.1); border: 2px solid #ff6b6b; border-radius: 8px;">
                                <p style="color: #ff6b6b; font-size: 1.1em; margin-bottom: 10px;"><strong>❌ CANNOT HOLD:</strong></p>
                                <p>Monsters 👹 (must fight immediately!)</p>
                            </div>
                            <p style="margin-top: 20px; color: #aaa;">💡 Strategy: Hold potions for emergencies or weapons for later!</p>
                        </div>
                    </div>
                `
            },
            {
                title: "🔥 Combo System",
                content: `
                    <div style="padding: 20px;">
                        <h3 style="color: #ffd700; margin-bottom: 20px; text-align: center;">Build Epic Combos!</h3>
                        <div style="background: rgba(0,0,0,0.4); padding: 25px; border-radius: 8px;">
                            <p style="font-size: 1.1em; text-align: center; margin-bottom: 20px;">Kill monsters without taking damage to build combos!</p>
                            <div style="display: grid; gap: 15px; margin: 20px 0;">
                                <div style="padding: 15px; background: rgba(107, 207, 127, 0.1); border-left: 4px solid #6bcf7f; border-radius: 8px;">
                                    <strong style="color: #6bcf7f;">✅ COMBO INCREASES:</strong>
                                    <p style="margin-top: 8px;">Perfect kills (no damage taken)</p>
                                </div>
                                <div style="padding: 15px; background: rgba(255, 107, 107, 0.1); border-left: 4px solid #ff6b6b; border-radius: 8px;">
                                    <strong style="color: #ff6b6b;">❌ COMBO BREAKS:</strong>
                                    <p style="margin-top: 8px;">Taking damage OR equipping a weapon</p>
                                </div>
                            </div>
                            <div style="text-align: center; margin-top: 20px; padding: 20px; background: rgba(255, 215, 0, 0.1); border-radius: 8px;">
                                <p style="font-size: 0.9em; color: #ffd93d;"><strong>Rewards:</strong></p>
                                <p style="margin-top: 10px;">5x = GREAT! | 7x = AMAZING! | 10x = LEGENDARY!</p>
                                <p style="margin-top: 10px; color: #aaa; font-size: 0.9em;">Max combo × 10 = bonus points!</p>
                            </div>
                        </div>
                    </div>
                `
            },
            {
                title: "👹 Boss Battles",
                content: `
                    <div style="padding: 20px;">
                        <h3 style="color: #ffd700; margin-bottom: 20px; text-align: center;">Face the Bosses!</h3>
                        <div style="background: rgba(0,0,0,0.4); padding: 25px; border-radius: 8px;">
                            <p style="font-size: 1.2em; text-align: center; margin-bottom: 20px; color: #ff6b6b;"><strong>Every 10th room = BOSS ROOM!</strong></p>
                            <div style="margin: 20px 0;">
                                <p style="margin-bottom: 10px;">• Bosses have <strong>15 HP</strong></p>
                                <p style="margin-bottom: 10px;">• Requires multiple hits to defeat</p>
                                <p style="margin-bottom: 10px;">• HP bar shows boss health</p>
                            </div>
                            <div style="margin: 30px 0; padding: 20px; background: rgba(255, 107, 107, 0.2); border: 2px solid #ff6b6b; border-radius: 8px;">
                                <h4 style="color: #ff6b6b; margin-bottom: 15px; text-align: center;">⚠️ CRITICAL WARNING!</h4>
                                <p style="text-align: center; font-size: 1.1em;"><strong>Fight boss WITHOUT weapon:</strong></p>
                                <p style="text-align: center; margin-top: 10px;">• Boss attacks once (15 HP damage!)</p>
                                <p style="text-align: center;">• Boss FLEES immediately</p>
                                <p style="text-align: center;">• <strong style="color: #ff6b6b;">NO GOLD REWARD!</strong></p>
                            </div>
                            <p style="text-align: center; color: #ffd93d; font-size: 1.1em; margin-top: 20px;">💡 Always have a weapon before room 10, 20, 30...</p>
                        </div>
                    </div>
                `
            },
            {
                title: "💰 Shop & Economy",
                content: `
                    <div style="padding: 20px;">
                        <h3 style="color: #ffd700; margin-bottom: 20px; text-align: center;">Spend Wisely!</h3>
                        <div style="background: rgba(0,0,0,0.4); padding: 25px; border-radius: 8px;">
                            <p style="text-align: center; font-size: 1.1em; margin-bottom: 20px;">Click 🏺 MERCHANT button to open shop</p>
                            <div style="margin: 20px 0; padding: 20px; background: rgba(78, 205, 196, 0.1); border: 2px solid #4ecdc4; border-radius: 8px;">
                                <h4 style="color: #4ecdc4; margin-bottom: 15px; text-align: center;">💎 Shop Features:</h4>
                                <p>• Buy healing potions</p>
                                <p>• Upgrade weapons</p>
                                <p>• Purchase relics (4 rarities)</p>
                                <p>• Increase max HP</p>
                            </div>
                            <div style="margin: 20px 0; padding: 20px; background: rgba(255, 107, 107, 0.2); border: 2px solid #ff6b6b; border-radius: 8px;">
                                <h4 style="color: #ff6b6b; margin-bottom: 15px; text-align: center;">⚠️ Shop Penalties:</h4>
                                <p style="text-align: center;">• Each visit = <strong>-50 score points</strong></p>
                                <p style="text-align: center; margin-top: 10px;">• Prices increase <strong>15%</strong> per purchase (anti-exploit!)</p>
                            </div>
                            <p style="text-align: center; color: #ffd93d; margin-top: 20px;">💡 Use shop strategically to maximize score!</p>
                        </div>
                    </div>
                `
            },
            {
                title: "🏆 Score System",
                content: `
                    <div style="padding: 20px;">
                        <h3 style="color: #ffd700; margin-bottom: 20px; text-align: center;">How Scoring Works</h3>
                        <div style="background: rgba(0,0,0,0.4); padding: 25px; border-radius: 8px; font-size: 0.95em;">
                            <div style="margin-bottom: 20px; padding: 15px; background: rgba(107, 207, 127, 0.1); border-radius: 8px;">
                                <h4 style="color: #6bcf7f; margin-bottom: 10px;">✅ BONUSES:</h4>
                                <p>🎯 Win: +1000</p>
                                <p>❤️ Health: HP × 20</p>
                                <p>💰 Gold: Total × 5</p>
                                <p>🔥 Combo: Max × 10</p>
                                <p>⚔️ Monsters: Slain × 2</p>
                                <p style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(107, 207, 127, 0.3);">
                                    ⚡ <strong>Speedrun:</strong> +500 (&lt;5min) or +250 (&lt;10min)<br>
                                    🏆 <strong>Perfect Run:</strong> +1000 (no damage!)
                                </p>
                            </div>
                            <div style="margin-bottom: 20px; padding: 15px; background: rgba(255, 107, 107, 0.1); border-radius: 8px;">
                                <h4 style="color: #ff6b6b; margin-bottom: 10px;">❌ PENALTIES:</h4>
                                <p>⏱️ Time: -2 per second</p>
                                <p>🏺 Shop: -50 per visit</p>
                            </div>
                            <div style="text-align: center; padding: 15px; background: rgba(255, 215, 0, 0.1); border-radius: 8px;">
                                <p style="color: #ffd93d;"><strong>Difficulty Multiplier:</strong></p>
                                <p>Easy × 1 | Normal × 1.5 | Hard × 2.5</p>
                            </div>
                        </div>
                    </div>
                `
            },
            {
                title: "⌨️ Keyboard Shortcuts",
                content: `
                    <div style="padding: 20px;">
                        <h3 style="color: #ffd700; margin-bottom: 20px; text-align: center;">Master the Keyboard!</h3>
                        <div style="background: rgba(0,0,0,0.4); padding: 25px; border-radius: 8px;">
                            <p style="text-align: center; font-size: 1.1em; margin-bottom: 25px; color: #6bcf7f;">
                                <strong>🖥️ Desktop players can use keyboard shortcuts for faster gameplay!</strong>
                            </p>
                            
                            <div style="display: grid; gap: 12px; margin: 20px 0;">
                                <div style="padding: 12px 20px; background: rgba(102, 126, 234, 0.15); border-left: 4px solid #667eea; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <span style="color: #ffd93d;"><strong>Space</strong> or <strong>D</strong></span>
                                    <span style="color: #ddd;">→ Draw Room</span>
                                </div>
                                
                                <div style="padding: 12px 20px; background: rgba(102, 126, 234, 0.15); border-left: 4px solid #667eea; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <span style="color: #ffd93d;"><strong>A</strong></span>
                                    <span style="color: #ddd;">→ Avoid Room</span>
                                </div>
                                
                                <div style="padding: 12px 20px; background: rgba(102, 126, 234, 0.15); border-left: 4px solid #667eea; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <span style="color: #ffd93d;"><strong>Q</strong></span>
                                    <span style="color: #ddd;">→ Use Class Ability</span>
                                </div>
                                
                                <div style="padding: 12px 20px; background: rgba(102, 126, 234, 0.15); border-left: 4px solid #667eea; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <span style="color: #ffd93d;"><strong>U</strong></span>
                                    <span style="color: #ddd;">→ Undo Last Move</span>
                                </div>
                                
                                <div style="padding: 12px 20px; background: rgba(102, 126, 234, 0.15); border-left: 4px solid #667eea; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <span style="color: #ffd93d;"><strong>S</strong></span>
                                    <span style="color: #ddd;">→ Open Shop</span>
                                </div>
                                
                                <div style="padding: 12px 20px; background: rgba(107, 207, 127, 0.15); border-left: 4px solid #6bcf7f; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <span style="color: #ffd93d;"><strong>1, 2, 3, 4, 5</strong></span>
                                    <span style="color: #ddd;">→ Click cards in room</span>
                                </div>
                                
                                <div style="padding: 12px 20px; background: rgba(255, 107, 107, 0.15); border-left: 4px solid #ff6b6b; border-radius: 8px; display: flex; justify-content: space-between; align-items: center;">
                                    <span style="color: #ffd93d;"><strong>ESC</strong></span>
                                    <span style="color: #ddd;">→ Close any modal</span>
                                </div>
                            </div>
                            
                            <div style="margin-top: 25px; padding: 20px; background: rgba(255, 215, 0, 0.1); border: 2px solid #ffd700; border-radius: 8px; text-align: center;">
                                <p style="color: #ffd93d; font-size: 1.1em; margin-bottom: 10px;"><strong>⚡ Pro Tip:</strong></p>
                                <p style="color: #ddd;">Use keyboard shortcuts to play 3x faster!</p>
                                <p style="color: #aaa; font-size: 0.9em; margin-top: 10px;">No need to move your mouse constantly!</p>
                            </div>
                        </div>
                    </div>
                `
            },
            {
                title: "🎮 Ready to Play!",
                content: `
                    <div style="text-align: center; padding: 40px 20px;">
                        <h3 style="color: #ffd700; font-size: 2em; margin-bottom: 20px;">You're Ready!</h3>
                        <p style="font-size: 1.2em; margin-bottom: 30px;">You now know everything to become a legendary scoundrel!</p>
                        <div style="background: rgba(0,0,0,0.4); padding: 30px; border-radius: 8px; margin: 30px 0;">
                            <p style="font-size: 1.1em; color: #6bcf7f; margin-bottom: 15px;"><strong>Quick Recap:</strong></p>
                            <p style="margin: 10px 0;">⚔️ Fight monsters with weapons</p>
                            <p style="margin: 10px 0;">💊 Use potions wisely</p>
                            <p style="margin: 10px 0;">🔥 Build combos for bonus points</p>
                            <p style="margin: 10px 0;">👹 Always bring weapons to bosses</p>
                            <p style="margin: 10px 0;">💰 Use shop strategically</p>
                            <p style="margin: 10px 0;">⌨️ Use keyboard shortcuts for speed</p>
                        </div>
                        <p style="font-size: 1.3em; color: #ffd93d; margin-top: 30px;"><strong>Close this tutorial and click "⚔️ Start Quest" to begin!</strong></p>
                        <p style="margin-top: 20px; color: #aaa; font-size: 0.9em;">You can always re-read the guide from the main menu.</p>
                    </div>
                `
            }
        ];
        
        function startInteractiveTutorial() {
            tutorialStep = 0;
            updateTutorialStep();
            interactiveTutorialModal.classList.add('active');
        }
        
        function updateTutorialStep() {
            const step = tutorialSteps[tutorialStep];
            tutorialStepTitle.textContent = step.title;
            tutorialStepContent.innerHTML = step.content;
            tutorialCurrentStep.textContent = tutorialStep + 1;
            tutorialTotalSteps.textContent = tutorialSteps.length;
            
            // Update buttons
            btnTutorialPrev.disabled = tutorialStep === 0;
            btnTutorialNext.textContent = tutorialStep === tutorialSteps.length - 1 ? '✅ Finish' : '➡️ Next';
        }
        
        btnTutorialNext.onclick = () => {
            if (tutorialStep < tutorialSteps.length - 1) {
                tutorialStep++;
                updateTutorialStep();
            } else {
                // Finish tutorial
                interactiveTutorialModal.classList.remove('active');
            }
        };
        
        btnTutorialPrev.onclick = () => {
            if (tutorialStep > 0) {
                tutorialStep--;
                updateTutorialStep();
            }
        };
        
        btnTutorialSkip.onclick = () => {
            interactiveTutorialModal.classList.remove('active');
        };

        // ============================================
        // GAME STATE
        // ============================================
        const game = {
            deck: [],
            relics: [],
            heldCard: null,
            discardPile: [],
            lastActionWasAvoid: false,
            gameOver: false,
            gameTimerInterval: null,
            gameStartTime: null,
            undoAvailable: false,
            lastGameState: null,
            potionsUsed: 0,
            gameOver: false,
            difficulty: 'normal',
            combo: 0,
            score: 0,
            health: 20,
            maxHealth: 20,
            equippedWeapon: null,
            dungeon: [],
            room: [],
            gameStartTime: 0,
            gameTimerInterval: null,
            lastActionWasAvoid: false,
            gold: 0,
            totalGoldEarned: 0,
            relics: [],
            stats: {},
            settings: {
                soundEnabled: true,
                musicEnabled: false
            },
            dodgeActive: false,
            doubleDamage: false,
            berserkStacks: 0,
            mirrorShield: 0,
            obliterateMode: false,
        };

        // Permanent Stats (LocalStorage)
        let permanentStats = {};
        
        // ============================================
        // INITIALIZATION AND SCREEN FLOW LOGIC
        // ============================================

        function showWelcomeScreen() {
            welcomeScreen.style.display = 'flex';
            gameWrapper.classList.remove('active');
            newGameModal.classList.remove('active');
        }

        function showNewGameModal() {
            newGameModal.classList.add('active');
        }

        function showGameUI() {
            welcomeScreen.style.display = 'none';
            newGameModal.classList.remove('active');
            gameWrapper.classList.add('active');
        }
        
        // Welcome Screen Hooks
        btnWelcomeStart.onclick = showNewGameModal;
        btnPlayTutorial.onclick = startInteractiveTutorial;
        btnWelcomeTutorial.onclick = showTutorial;
        btnWelcomeLeaderboard.onclick = showLeaderboard;
        btnWelcomeUnlocks.onclick = openUnlocks;
        
        // Soundboard will be hooked later after music is created
        
        // New Game Modal Hooks
        const nameError = document.getElementById('nameError');
        
        // Sanitize player name input (XSS prevention)
        function sanitizePlayerName(input) {
            return input
                .trim()
                .replace(/[<>'"&]/g, '') // Remove dangerous chars
                .replace(/\s+/g, ' ')     // Collapse multiple spaces
                .substring(0, 10);         // Max 10 chars
        }
        
        // Clear error on input
        playerNameInput.oninput = () => {
            nameError.style.display = 'none';
            playerNameInput.style.borderColor = '#667eea';
        };
        
        btnStartGameModal.onclick = () => {
            const name = sanitizePlayerName(playerNameInput.value);
            
            if (name.length < 3) {
                nameError.textContent = '❌ Name must have at least 3 characters!';
                nameError.style.display = 'block';
                playerNameInput.style.borderColor = '#ff6b6b';
                playerNameInput.focus();
                return;
            }
            if (name.length > 10) {
                nameError.textContent = '❌ Name must have maximum 10 characters!';
                nameError.style.display = 'block';
                playerNameInput.style.borderColor = '#ff6b6b';
                playerNameInput.focus();
                return;
            }
            
            // Update input with sanitized value
            playerNameInput.value = name;
            
            // Open class selection instead of starting game directly
            showClassSelection();
        };
        btnCancelStart.onclick = () => {
            newGameModal.classList.remove('active');
            nameError.style.display = 'none';
            playerNameInput.style.borderColor = '#667eea';
        };
        
        // ============================================
        // CLASS SELECTION SYSTEM
        // ============================================
        const classSelectionModal = document.getElementById('classSelectionModal');
        const classCards = document.querySelectorAll('.class-card');
        const classDescription = document.getElementById('classDescription');
        const classDescTitle = document.getElementById('classDescTitle');
        const classDescMotivation = document.getElementById('classDescMotivation');
        const classDescMechanics = document.getElementById('classDescMechanics');
        const btnConfirmClass = document.getElementById('btnConfirmClass');
        const btnCancelClass = document.getElementById('btnCancelClass');
        const classSelectionTitle = document.getElementById('classSelectionTitle');
        const classSelectionSubtitle = document.getElementById('classSelectionSubtitle');
        
        let selectedClass = null;
        
        // Class definitions
        const CLASSES = {
            scoundrel: {
                name: 'SCOUNDREL',
                motivation: '"I have no honor, no glory, only survival in the dark."',
                mechanics: '<strong>⚔️ Passive:</strong> None - Pure skill and luck<br><br><strong>✨ Active:</strong> None - Just you and your wits<br><br><em style="color: #8b7355; font-size: 0.9em;">This is the baseline class. Master the basics before seeking power.</em>',
                icon: '🎭',
                unlocked: true,
                unlockRequirement: 'Always available',
                passive: {},
                active: null
            },
            knight: {
                name: 'KNIGHT',
                motivation: '"Honor and steel shall guide my path through the darkness."',
                mechanics: '<strong>🛡️ Passive:</strong> +5 Max HP | Weapons have +1 durability<br><br><strong>⚔️ Active (Shield Bash):</strong> Deal damage equal to your weapon value to the first monster in the room. Cooldown: 3 rooms.',
                icon: '🛡️',
                unlocked: false,
                unlockRequirement: 'Win on Easy difficulty',
                passive: { maxHpBonus: 5, weaponDurabilityBonus: 1 },
                active: {
                    name: 'Shield Bash',
                    description: 'Deal weapon damage to first monster',
                    cooldown: 3,
                    icon: '🛡️'
                }
            },
            rogue: {
                name: 'ROGUE',
                motivation: '"In shadows I thrive, through cunning I survive."',
                mechanics: '<strong>🗡️ Passive:</strong> Can hold 2 cards instead of 1 | Start with 1 extra gold per room<br><br><strong>🔪 Active (Shadow Strike):</strong> Next monster takes double weapon damage and doesn\'t break combo. Cooldown: 4 rooms.',
                icon: '🗡️',
                unlocked: false,
                unlockRequirement: 'Win on Normal difficulty',
                passive: { maxHoldCards: 2, bonusGoldPerRoom: 1 },
                active: {
                    name: 'Shadow Strike',
                    description: 'Next monster: 2x damage, combo safe',
                    cooldown: 4,
                    icon: '🔪'
                }
            },
            dancer: {
                name: 'DANCER',
                motivation: '"Grace in motion, life in every step, death in every turn."',
                mechanics: '<strong>💃 Passive:</strong> Potions heal +3 HP | Can use 2 potions per room | Higher event chance (luck)<br><br><strong>✨ Active (Healing Dance):</strong> Heal 5 HP and gain +2 weapon damage for next 2 monsters. Cooldown: 5 rooms.',
                icon: '💃',
                unlocked: false,
                unlockRequirement: 'Win on Hard difficulty',
                passive: { potionHealBonus: 3, maxPotionsPerRoom: 2, eventChanceBonus: 15 },
                active: {
                    name: 'Healing Dance',
                    description: 'Heal 5 HP + damage buff',
                    cooldown: 5,
                    icon: '✨'
                }
            },
            berserker: {
                name: 'BERSERKER',
                motivation: '"Through pain I find power. Through fury I find victory."',
                mechanics: '<strong>💢 Passive (Bloodlust):</strong> Damage increases as HP decreases<br>• +1 damage at ≤70% HP<br>• +2 damage at ≤50% HP<br>• +3 damage at ≤30% HP<br><br><strong>⚔️ Active (Rage Strike):</strong> Sacrifice 5 HP for triple damage (3x) on next attack. Breaks combo. Cooldown: 4 rooms.<br><em style="color: #ff6b6b; font-size: 0.9em;">⚠️ Cannot use if HP ≤ 5</em>',
                icon: '💢',
                unlocked: false,
                unlockRequirement: 'Win on Hard + Kill 5 bosses total',
                passive: { bloodlust: true },
                active: {
                    name: 'Rage Strike',
                    description: 'Sacrifice 5 HP: 3x damage, breaks combo',
                    cooldown: 4,
                    icon: '⚔️'
                }
            },
            priest: {
                name: 'PRIEST',
                motivation: '"The light protects me. The divine guides me. Chaos shall be purified."',
                mechanics: '<strong>🕊️ Passive (Divine Blessing):</strong> 15% chance to negate damage completely | Potions heal +1 HP | Start with +2 Max HP<br><br><strong>📿 Active (Purification):</strong> Permanently remove the strongest monster from current dungeon OR transform a monster into a potion. Cooldown: 6 rooms.<br><em style="color: #ffd700; font-size: 0.9em;">✨ Strategic: Eliminate threats before facing them</em>',
                icon: '📿',
                unlocked: false,
                unlockRequirement: 'Collect 20 relics + 10 events + 5 wins total',
                passive: { divineBlessing: true, potionHealBonus: 1, startMaxHpBonus: 2 },
                active: {
                    name: 'Purification',
                    description: 'Remove strongest monster or convert to potion',
                    cooldown: 6,
                    icon: '📿'
                }
            }
        };
        
        // Function to check class unlocks based on wins
        function checkClassUnlocks() {
            const stats = storage.get('scoundrel_lifetime_stats', {});
            
            // Knight unlocks after Easy win
            if (stats.easyWins >= 1) {
                CLASSES.knight.unlocked = true;
            }
            
            // Rogue unlocks after Normal win
            if (stats.normalWins >= 1) {
                CLASSES.rogue.unlocked = true;
            }
            
            // Dancer unlocks after Hard win
            if (stats.hardWins >= 1) {
                CLASSES.dancer.unlocked = true;
            }
            
            // Berserker unlocks after Hard win + 5 bosses killed
            if (stats.hardWins >= 1 && (stats.bossesKilled || 0) >= 5) {
                CLASSES.berserker.unlocked = true;
            }
            
            // Priest unlocks after 20 relics + 10 events + 5 wins
            const totalRelics = stats.totalRelicsCollected || 0;
            const totalEvents = stats.eventsTriggered || 0;
            const totalWins = stats.gamesWon || 0;
            
            if (totalRelics >= 20 && totalEvents >= 10 && totalWins >= 5) {
                CLASSES.priest.unlocked = true;
            }
        }
        
        function showClassSelection() {
            newGameModal.classList.remove('active');
            classSelectionModal.classList.add('active');
            selectedClass = null;
            btnConfirmClass.disabled = true;
            classDescription.style.display = 'none';
            classSelectionTitle.textContent = 'SELECT YOUR HERO';
            classSelectionSubtitle.textContent = '';
            
            // Check unlocks before showing
            checkClassUnlocks();
            
            // Reset all class cards and apply lock states
            classCards.forEach(card => {
                const className = card.dataset.class;
                const classData = CLASSES[className];
                const isLocked = !classData.unlocked;
                
                card.classList.remove('selected');
                card.style.borderColor = '#5a4a38';
                card.style.transform = 'translateY(0)';
                
                // Apply locked visual state
                if (isLocked) {
                    card.style.opacity = '0.4';
                    card.style.filter = 'grayscale(80%)';
                    card.style.cursor = 'not-allowed';
                    
                    // Add lock icon overlay
                    if (!card.querySelector('.lock-overlay')) {
                        const lockOverlay = document.createElement('div');
                        lockOverlay.className = 'lock-overlay';
                        lockOverlay.style.cssText = `
                            position: absolute;
                            top: 50%;
                            left: 50%;
                            transform: translate(-50%, -50%);
                            font-size: 3em;
                            z-index: 10;
                            pointer-events: none;
                        `;
                        lockOverlay.textContent = '🔒';
                        card.style.position = 'relative';
                        card.appendChild(lockOverlay);
                    }
                } else {
                    card.style.opacity = '1';
                    card.style.filter = 'none';
                    card.style.cursor = 'pointer';
                    
                    // Remove lock overlay if exists
                    const lockOverlay = card.querySelector('.lock-overlay');
                    if (lockOverlay) {
                        lockOverlay.remove();
                    }
                }
            });
        }
        
        // Class card click handlers
        classCards.forEach(card => {
            card.onclick = () => {
                const className = card.dataset.class;
                const classData = CLASSES[className];
                
                // Check if locked
                if (!classData.unlocked) {
                    // Show lock message
                    classSelectionTitle.textContent = classData.name + ' 🔒';
                    classSelectionSubtitle.textContent = 'LOCKED';
                    classDescTitle.textContent = classData.name + ' (LOCKED)';
                    classDescMotivation.textContent = '';
                    classDescMechanics.innerHTML = `
                        <div style="text-align: center; padding: 20px;">
                            <div style="font-size: 3em; margin-bottom: 15px;">🔒</div>
                            <div style="color: #ff6b6b; font-weight: bold; font-size: 1.2em; margin-bottom: 10px;">
                                CLASS LOCKED
                            </div>
                            <div style="color: #ffd700; font-size: 1.1em;">
                                ${classData.unlockRequirement}
                            </div>
                        </div>
                    `;
                    classDescription.style.display = 'block';
                    btnConfirmClass.disabled = true;
                    playSound('error');
                    return;
                }
                
                selectedClass = className;
                
                // Update UI
                classCards.forEach(c => {
                    c.classList.remove('selected');
                    if (CLASSES[c.dataset.class].unlocked) {
                        c.style.borderColor = '#5a4a38';
                    }
                });
                card.classList.add('selected');
                card.style.borderColor = '#c9a961';
                card.style.transform = 'translateY(-5px)';
                
                // Show description
                classSelectionTitle.textContent = classData.name;
                classSelectionSubtitle.textContent = 'Your chosen hero';
                classDescTitle.textContent = classData.name;
                classDescMotivation.textContent = classData.motivation;
                classDescMechanics.innerHTML = classData.mechanics;
                classDescription.style.display = 'block';
                
                btnConfirmClass.disabled = false;
                playSound('cardFlip');
            };
        });
        
        btnConfirmClass.onclick = () => {
            if (!selectedClass) return;
            classSelectionModal.classList.remove('active');
            startGameWithClass(selectedClass);
        };
        
        btnCancelClass.onclick = () => {
            classSelectionModal.classList.remove('active');
            newGameModal.classList.add('active');
        };
        
        // Store class in game object
        function startGameWithClass(className) {
            game.playerClass = className;
            game.classData = CLASSES[className];
            game.classAbilityCooldown = 0; // Tracks rooms until ability is ready
            game.classAbilityActive = false; // For buffs like Shadow Strike
            game.classAbilityCounter = 0; // For counting buff duration
            startGame();
        }
        
        // FIXED HOOK: Difficulty Selector
        difficultySelector.addEventListener('click', (e) => {
            const target = e.target.closest('.difficulty-btn');
            if (!target) return;
            
            // Remove 'selected' class from all
            difficultySelector.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // Add 'selected' class to the clicked one
            target.classList.add('selected');
        });

        // Top Bar Hooks
        btnTopTutorial.onclick = showTutorial;
        btnTopLeaderboard.onclick = showLeaderboard;
        btnTopUnlocks.onclick = openUnlocks;
        btnOpenShop.onclick = openShop;
        
        // Give Up Hooks
        btnTopGiveUp.onclick = () => {
            if (game.gameOver || game.gameStartTime === 0) return; // Don't show if game not running
            giveUpModal.classList.add('active');
        };
        btnCancelGiveUp.onclick = () => giveUpModal.classList.remove('active');
        btnConfirmGiveUp.onclick = () => {
            giveUpModal.classList.remove('active');
            endGame('death', true); // true = gave up
        };
        
        // FIXED HOOKS: Action Buttons
        btnDrawRoom.onclick = drawRoom;
        btnAvoidRoom.onclick = avoidRoom;
        
        // Undo Button Hook
        const btnUndo = document.getElementById('btnUndo');
        if (btnUndo) {
            btnUndo.onclick = undoLastMove;
        }
        
        // Class Ability Button Hook
        const btnClassAbility = document.getElementById('btnClassAbility');
        if (btnClassAbility) {
            btnClassAbility.onclick = useClassAbility;
        }
        
        // ============================================
        // KEYBOARD SHORTCUTS (Desktop Optimization)
        // ============================================
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            // Ignore if modal is open (except ESC)
            const modalOpen = document.querySelector('.modal-overlay.active');
            if (modalOpen && e.key !== 'Escape') return;
            
            // ESC - Close modals
            if (e.key === 'Escape') {
                const modal = document.querySelector('.modal-overlay.active');
                if (modal) {
                    modal.classList.remove('active');
                    playSound('cardFlip');
                    return;
                }
            }
            
            // Only in-game shortcuts below
            if (!gameWrapper.classList.contains('active') || game.gameOver) return;
            
            switch(e.key.toLowerCase()) {
                case ' ': // Space - Draw Room
                case 'd':
                    e.preventDefault();
                    if (!btnDrawRoom.disabled) {
                        btnDrawRoom.click();
                    }
                    break;
                    
                case 'a': // A - Avoid Room
                    e.preventDefault();
                    if (!btnAvoidRoom.disabled) {
                        btnAvoidRoom.click();
                    }
                    break;
                    
                case 'q': // Q - Class Ability
                    e.preventDefault();
                    if (btnClassAbility && !btnClassAbility.disabled) {
                        btnClassAbility.click();
                    }
                    break;
                    
                case 'u': // U - Undo
                    e.preventDefault();
                    const btnUndo = document.getElementById('btnUndo');
                    if (btnUndo && !btnUndo.disabled) {
                        btnUndo.click();
                    }
                    break;
                    
                case 's': // S - Shop
                    e.preventDefault();
                    if (btnOpenShop && !btnOpenShop.disabled) {
                        btnOpenShop.click();
                    }
                    break;
                    
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                    e.preventDefault();
                    const cardIndex = parseInt(e.key) - 1;
                    const cards = bottomBar.querySelectorAll('.card');
                    if (cards[cardIndex]) {
                        cards[cardIndex].click();
                    }
                    break;
            }
        });
        
        console.log('✅ Keyboard shortcuts loaded! D=Draw | A=Avoid | Q=Ability | 1-5=Cards | U=Undo | S=Shop | ESC=Close');
        
        // ============================================
        // ALL GAME CODE (STARTGAME, HANDLECLICK, ETC)
        // ============================================
        
        // Game State (minimum re-declaration)
        game.stats = {
            monstersSlain: 0,
            totalDamage: 0,
            totalHealing: 0,
            roomsCleared: 0,
            weaponsEquipped: 0,
            potionsUsed: 0,
            maxCombo: 0,
            specialsUsed: 0,
            cardsHeld: 0,
            roomsAvoided: 0,
            gamesWon: 0,
            hardWins: 0,
            minimalistWin: false,
            onePunch: false,
            musicWasOn: false
        };
        
        // Special Cards Types
        const specialCards = [
            { id: 'dodge', name: '🛡️ Dodge', description: 'Avoid next damage', effect: () => { game.dodgeActive = true; showMessage('🛡️ Dodge active!', 'success'); createParticles(window.innerWidth / 2, window.innerHeight / 2, '#4ecdc4', 20); } },
            { id: 'double_damage', name: '⚡ Power', description: 'Weapon 2x stronger', effect: () => { game.doubleDamage = true; showMessage('⚡ Power Strike!', 'success'); createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd93d', 25); } },
            { id: 'super_heal', name: '💊 Super Potion', description: 'Heal to full HP', effect: () => { const healed = game.maxHealth - game.health; game.health = game.maxHealth; showDamageNumber(healed, 'heal'); showMessage('💊 HP Full!', 'success'); createParticles(window.innerWidth / 2, window.innerHeight / 2, '#6bcf7f', 30); } },
            { id: 'treasure', name: '💰 Treasure', description: '+5 Max HP', effect: () => { game.maxHealth += 5; game.health += 5; showDamageNumber('+5 MAX', 'heal'); showMessage('💰 Max HP increased!', 'success'); createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd700', 35); } },
            
            // 🆕 NOVAS CARTAS ESPECIAIS
            { id: 'berserker', name: '🔥 Berserk', description: 'Next 3 attacks +5 damage', effect: () => { 
                game.berserkStacks = 3; 
                showMessage('🔥 BERSERK MODE! Next 3 attacks +5 damage!', 'success'); 
                playSound('special');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff6b6b', 40);
                
                // Track berserk use for achievement
                const saved = localStorage.getItem('scoundrel_lifetime_stats');
                let lifetimeStats = saved ? JSON.parse(saved) : {};
                lifetimeStats.berserkUses = (lifetimeStats.berserkUses || 0) + 1;
                localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
            } },
            { id: 'time_warp', name: '⏰ Time Warp', description: 'Draw 2 extra cards this room', effect: () => {
                if (game.dungeon.length >= 2) {
                    const extraCards = game.dungeon.splice(0, 2);
                    game.room.push(...extraCards);
                    showMessage('⏰ Time Warp! +2 cards drawn!', 'success');
                    playSound('cardDraw');
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, '#a8edea', 30);
                    updateUI();
                    
                    // Track time warp use for achievement
                    const saved = localStorage.getItem('scoundrel_lifetime_stats');
                    let lifetimeStats = saved ? JSON.parse(saved) : {};
                    lifetimeStats.timeWarps = (lifetimeStats.timeWarps || 0) + 1;
                    localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
                } else {
                    showMessage('⏰ Time Warp! Not enough cards in deck!', 'warning');
                }
            } },
            { id: 'card_destroy', name: '💥 Obliterate', description: 'Remove a card permanently', effect: () => {
                if (game.room.length > 0) {
                    showMessage('💥 Choose a card to OBLITERATE (left-click)!', 'warning');
                    game.obliterateMode = true;
                    playSound('special');
                } else {
                    showMessage('💥 No cards to obliterate!', 'warning');
                }
            } },
            { id: 'lucky_draw', name: '🎲 Lucky Draw', description: 'Draw until you get a weapon', effect: () => {
                let drawnCards = [];
                let foundWeapon = false;
                let attempts = 0;
                const maxAttempts = Math.min(10, game.dungeon.length);
                
                while (!foundWeapon && attempts < maxAttempts && game.dungeon.length > 0) {
                    const card = game.dungeon.shift();
                    drawnCards.push(card);
                    attempts++;
                    if (card.suitName === 'diamonds') {
                        foundWeapon = true;
                    }
                }
                
                game.room.push(...drawnCards);
                
                if (foundWeapon) {
                    showMessage(`🎲 Lucky Draw! Found weapon in ${attempts} cards!`, 'success');
                    earnGold(5);
                } else {
                    showMessage('🎲 Lucky Draw! No weapon found, but +10 gold!', 'info');
                    earnGold(10);
                }
                
                playSound('cardDraw');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd93d', 25);
                updateUI();
            } },
            { id: 'mirror_shield', name: '🪞 Mirror', description: 'Reflect next 10 damage (this dungeon only)', effect: () => {
                game.mirrorShield = 10;
                showMessage('🪞 Mirror Shield! Next 10 damage reflected!', 'success');
                playSound('special');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#a8edea', 35);
            } },
            { id: 'gamble', name: '🎰 Gamble', description: '50% chance: +10 HP or -5 HP', effect: () => {
                const win = Math.random() < 0.5;
                if (win) {
                    const heal = Math.min(10, game.maxHealth - game.health);
                    game.health = Math.min(game.maxHealth, game.health + 10);
                    showDamageNumber(heal, 'heal');
                    showMessage('🎰 JACKPOT! +10 HP!', 'success');
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, '#6bcf7f', 50);
                } else {
                    game.health = Math.max(1, game.health - 5);
                    showDamageNumber(5, 'damage');
                    showMessage('🎰 Bad luck... -5 HP!', 'danger');
                    screenShake();
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff6b6b', 30);
                }
                playSound('special');
                updateUI();
                
                // Track gamble use for achievement
                const saved = localStorage.getItem('scoundrel_lifetime_stats');
                let lifetimeStats = saved ? JSON.parse(saved) : {};
                lifetimeStats.gambleCards = (lifetimeStats.gambleCards || 0) + 1;
                localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
            } }
        ];
        
        // Card suits and values
        const suits = {'♠': 'spades', '♣': 'clubs', '♥': 'hearts', '♦': 'diamonds'};
        const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10'];

        // ===== 50 ACHIEVEMENTS SYSTEM =====
        const ACHIEVEMENTS = [
            // 🥉 BRONZE (25) - Fáceis
            { id: 'first_blood', tier: 'bronze', icon: '⚔️', title: 'First Blood', description: 'Defeat your first monster', check: () => getLifetimeStat('monstersSlain') >= 1 },
            { id: 'baby_steps', tier: 'bronze', icon: '👶', title: 'Baby Steps', description: 'Clear your first room', check: () => getLifetimeStat('roomsCleared') >= 1 },
            { id: 'armed', tier: 'bronze', icon: '🗡️', title: 'Armed & Ready', description: 'Equip your first weapon', check: () => getLifetimeStat('weaponsEquipped') >= 1 },
            { id: 'healer', tier: 'bronze', icon: '💊', title: 'Healer', description: 'Use your first potion', check: () => getLifetimeStat('potionsUsed') >= 1 },
            { id: 'gold_digger', tier: 'bronze', icon: '💰', title: 'Gold Digger', description: 'Earn 100 gold (lifetime)', check: () => getLifetimeStat('totalGoldEarned') >= 100 },
            { id: 'shopper', tier: 'bronze', icon: '🛒', title: 'Window Shopper', description: 'Open the shop for the first time', check: () => getLifetimeStat('shopsVisited') >= 1 },
            { id: 'combo_starter', tier: 'bronze', icon: '🔥', title: 'Combo Starter', description: 'Get a 3x combo', check: () => getLifetimeStat('maxCombo') >= 3 },
            { id: 'monster_slayer', tier: 'bronze', icon: '⚔️', title: 'Monster Slayer', description: 'Defeat 10 monsters', check: () => getLifetimeStat('monstersSlain') >= 10 },
            { id: 'room_clearer', tier: 'bronze', icon: '🏰', title: 'Room Clearer', description: 'Clear 5 rooms', check: () => getLifetimeStat('roomsCleared') >= 5 },
            { id: 'warrior', tier: 'bronze', icon: '⚔️', title: 'Warrior', description: 'Equip 5 different weapons', check: () => getLifetimeStat('weaponsEquipped') >= 5 },
            { id: 'healthy', tier: 'bronze', icon: '💚', title: 'Healthy', description: 'Use 5 potions (lifetime)', check: () => getLifetimeStat('potionsUsed') >= 5 },
            { id: 'rich', tier: 'bronze', icon: '💎', title: 'Getting Rich', description: 'Earn 500 gold (lifetime)', check: () => getLifetimeStat('totalGoldEarned') >= 500 },
            { id: 'special_user', tier: 'bronze', icon: '✨', title: 'Special Forces', description: 'Use 3 special cards', check: () => getLifetimeStat('specialsUsed') >= 3 },
            { id: 'survivor', tier: 'bronze', icon: '❤️', title: 'Survivor', description: 'Complete a run with less than 5 HP', check: () => false }, // Checked during game
            { id: 'avoidance', tier: 'bronze', icon: '🚪', title: 'Avoidance', description: 'Avoid 3 dungeons (lifetime)', check: () => getLifetimeStat('roomsAvoided') >= 3 },
            { id: 'collector', tier: 'bronze', icon: '🔮', title: 'Collector', description: 'Have 3 relics in a single run', check: () => false }, // Checked during game
            { id: 'hoarder', tier: 'bronze', icon: '📌', title: 'Card Hoarder', description: 'Use hold mechanic 10 times', check: () => getLifetimeStat('cardsHeld') >= 10 },
            { id: 'easy_win', tier: 'bronze', icon: '🟢', title: 'Easy Victory', description: 'Win a game on Easy difficulty', check: () => getLifetimeStat('easyWins') >= 1 },
            { id: 'first_win', tier: 'bronze', icon: '🏆', title: 'First Victory', description: 'Win your first game', check: () => getLifetimeStat('gamesWon') >= 1 },
            { id: 'adventurer', tier: 'bronze', icon: '🗺️', title: 'Adventurer', description: 'Clear 20 rooms (lifetime)', check: () => getLifetimeStat('roomsCleared') >= 20 },
            { id: 'music_lover', tier: 'bronze', icon: '🎵', title: 'Music Lover', description: 'Win a game with music ON', check: () => false }, // Checked during game
            { id: 'gambler', tier: 'bronze', icon: '🎰', title: 'Gambler', description: 'Use the Gamble card 5 times', check: () => getLifetimeStat('gambleCards') >= 5 },
            { id: 'destroyer', tier: 'bronze', icon: '💥', title: 'Destroyer', description: 'Obliterate 3 cards (lifetime)', check: () => getLifetimeStat('cardsObliterated') >= 3 },
            { id: 'time_traveler', tier: 'bronze', icon: '⏰', title: 'Time Traveler', description: 'Use Time Warp card', check: () => getLifetimeStat('timeWarps') >= 1 },
            { id: 'berserker', tier: 'bronze', icon: '🔥', title: 'Berserker', description: 'Use Berserk mode 3 times', check: () => getLifetimeStat('berserkUses') >= 3 },
            
            // 🥈 SILVER (15) - Médias
            { id: 'veteran', tier: 'silver', icon: '🎖️', title: 'Veteran', description: 'Win 5 games', check: () => getLifetimeStat('gamesWon') >= 5 },
            { id: 'massacre', tier: 'silver', icon: '⚔️', title: 'Massacre', description: 'Defeat 50 monsters', check: () => getLifetimeStat('monstersSlain') >= 50 },
            { id: 'dungeon_master', tier: 'silver', icon: '🏰', title: 'Dungeon Master', description: 'Clear 50 rooms', check: () => getLifetimeStat('roomsCleared') >= 50 },
            { id: 'normal_win', tier: 'silver', icon: '🟡', title: 'Normal Victory', description: 'Win on Normal difficulty', check: () => getLifetimeStat('normalWins') >= 1 },
            { id: 'combo_master', tier: 'silver', icon: '🔥', title: 'Combo Master', description: 'Get a 7x combo', check: () => getLifetimeStat('maxCombo') >= 7 },
            { id: 'wealthy', tier: 'silver', icon: '💰', title: 'Wealthy', description: 'Earn 2000 gold (lifetime)', check: () => getLifetimeStat('totalGoldEarned') >= 2000 },
            { id: 'relic_hunter', tier: 'silver', icon: '🔮', title: 'Relic Hunter', description: 'Have 5 relics in a single run', check: () => false }, // Checked during game
            { id: 'arsenal', tier: 'silver', icon: '⚔️', title: 'Arsenal', description: 'Equip 25 weapons (lifetime)', check: () => getLifetimeStat('weaponsEquipped') >= 25 },
            { id: 'pharmacist', tier: 'silver', icon: '💊', title: 'Pharmacist', description: 'Use 25 potions (lifetime)', check: () => getLifetimeStat('potionsUsed') >= 25 },
            { id: 'special_ops', tier: 'silver', icon: '✨', title: 'Special Ops', description: 'Use 15 special cards', check: () => getLifetimeStat('specialsUsed') >= 15 },
            { id: 'speedrun', tier: 'silver', icon: '⏱️', title: 'Speedrunner', description: 'Win a game in under 10 minutes', check: () => false }, // Checked during game
            { id: 'iron_will', tier: 'silver', icon: '💪', title: 'Iron Will', description: 'Win with exactly 1 HP', check: () => false }, // Checked during game
            { id: 'perfect_run', tier: 'silver', icon: '✨', title: 'Perfect Run', description: 'Clear 10 rooms with 10x combo', check: () => false }, // Checked during game
            { id: 'shopaholic', tier: 'silver', icon: '🛍️', title: 'Shopaholic', description: 'Buy 30 items from shop (lifetime)', check: () => getLifetimeStat('itemsBought') >= 30 },
            { id: 'event_master', tier: 'silver', icon: '🎲', title: 'Event Master', description: 'Complete 20 events', check: () => getLifetimeStat('eventsCompleted') >= 20 },
            
            // 🥇 GOLD (9) - Difíceis (5 secretas)
            { id: 'legend', tier: 'gold', icon: '👑', title: 'Legend', description: 'Win 10 games', check: () => getLifetimeStat('gamesWon') >= 10 },
            { id: 'hard_win', tier: 'gold', icon: '🔴', title: 'Hard Victory', description: 'Win on Hard difficulty', check: () => getLifetimeStat('hardWins') >= 1 },
            { id: 'genocide', tier: 'gold', icon: '☠️', title: 'Genocide', description: 'Defeat 200 monsters', check: () => getLifetimeStat('monstersSlain') >= 200 },
            { id: 'conqueror', tier: 'gold', icon: '🏆', title: 'Conqueror', description: 'Clear 100 rooms', check: () => getLifetimeStat('roomsCleared') >= 100 },
            
            // 🔒 SECRET GOLDS (5)
            { id: 'secret_1', tier: 'gold', icon: '🎯', title: 'One Shot Wonder', description: 'Defeat a 10-value monster with a 2-value weapon', check: () => false, secret: true },
            { id: 'secret_2', tier: 'gold', icon: '🍀', title: 'Lucky 7', description: 'Win with exactly 7 HP, 7 cards left, and 777 score', check: () => false, secret: true },
            { id: 'secret_3', tier: 'gold', icon: '🎰', title: 'High Roller', description: 'Win 10 Gamble cards in a row', check: () => false, secret: true },
            { id: 'secret_4', tier: 'gold', icon: '💎', title: 'Minimalist', description: 'Win with only 1 relic', check: () => false, secret: true },
            { id: 'secret_5', tier: 'gold', icon: '🌟', title: 'Untouchable', description: 'Win without taking any damage', check: () => false, secret: true },
            
            // 💎 PLATINUM (1) - Todas as outras
            { id: 'platinum', tier: 'platinum', icon: '💎', title: 'Master Scoundrel', description: 'Unlock ALL other achievements', check: () => {
                const unlockedAchs = JSON.parse(localStorage.getItem('dungeon_scoundrel_achievements') || '[]');
                return unlockedAchs.length >= 49; // All except platinum itself
            }}
        ];

        // ===== ADVANCED SOUND EFFECTS SYSTEM =====
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Master gain for all sound effects
        const sfxMasterGain = audioContext.createGain();
        sfxMasterGain.connect(audioContext.destination);
        sfxMasterGain.gain.value = 0.3;

        const soundEffects = {
            cardDraw: (ctx, time) => {
                for (let i = 0; i < 8; i++) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = 200 + Math.random() * 400;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + (i * 0.03);
                    gain.gain.setValueAtTime(0.03, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);
                    osc.start(startTime);
                    osc.stop(startTime + 0.05);
                }
            },
            cardFlip: (ctx, time) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, time);
                osc.frequency.exponentialRampToValueAtTime(800, time + 0.1);
                osc.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.15, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
                osc.start(time);
                osc.stop(time + 0.15);
            },
            attack: (ctx, time) => {
                const noise = ctx.createBufferSource();
                const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) { data[i] = (Math.random() * 2 - 1) * (1 - i / data.length); }
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                const gain = ctx.createGain();
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.2, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
                const clang = ctx.createOscillator();
                const clangGain = ctx.createGain();
                clang.type = 'square';
                clang.frequency.value = 800;
                clang.connect(clangGain);
                clangGain.connect(sfxMasterGain);
                clangGain.gain.setValueAtTime(0.15, time + 0.1);
                clangGain.gain.exponentialRampToValueAtTime(0.001, time + 0.25);
                noise.start(time);
                clang.start(time + 0.1);
                clang.stop(time + 0.25);
            },
            damage: (ctx, time) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(50, time + 0.4);
                osc.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.3, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.4);
                osc.start(time);
                osc.stop(time + 0.4);
                const crack = ctx.createOscillator();
                const crackGain = ctx.createGain();
                crack.type = 'square';
                crack.frequency.value = 200;
                crack.connect(crackGain);
                crackGain.connect(sfxMasterGain);
                crackGain.gain.setValueAtTime(0.1, time + 0.05);
                crackGain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
                crack.start(time + 0.05);
                crack.stop(time + 0.15);
            },
            heal: (ctx, time) => {
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + (i * 0.08);
                    gain.gain.setValueAtTime(0.1, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);
                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                });
            },
            equip: (ctx, time) => {
                const osc1 = ctx.createOscillator();
                const osc2 = ctx.createOscillator();
                const gain = ctx.createGain();
                osc1.type = 'square';
                osc2.type = 'square';
                osc1.frequency.value = 400;
                osc2.frequency.value = 600;
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.15, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
                osc1.start(time);
                osc2.start(time);
                osc1.stop(time + 0.2);
                osc2.stop(time + 0.2);
            },
            hold: (ctx, time) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, time);
                osc.frequency.exponentialRampToValueAtTime(600, time + 0.1);
                osc.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.2, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
                osc.start(time);
                osc.stop(time + 0.15);
            },
            special: (ctx, time) => {
                for (let i = 0; i < 6; i++) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = 800 + (i * 200) + (Math.random() * 100);
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + (i * 0.05);
                    gain.gain.setValueAtTime(0.08, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);
                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                }
            },
            combo: (ctx, time) => {
                const chord = [659.25, 783.99, 987.77]; // E5, G5, B5
                chord.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    gain.gain.setValueAtTime(0.12, time);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.4);
                    osc.start(time);
                    osc.stop(time + 0.4);
                });
            },
            roomClear: (ctx, time) => {
                const melody = [523.25, 659.25, 783.99]; // C5, E5, G5
                melody.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + (i * 0.12);
                    gain.gain.setValueAtTime(0.15, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);
                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                });
            },
            avoid: (ctx, time) => {
                const noise = ctx.createBufferSource();
                const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.4, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) { data[i] = (Math.random() * 2 - 1) * (1 - i / data.length); }
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2000, time);
                filter.frequency.exponentialRampToValueAtTime(200, time + 0.4);
                const gain = ctx.createGain();
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.2, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.4);
                noise.start(time);
            },
            victory: (ctx, time) => {
                const fanfare = [{freq: 523.25, start: 0}, {freq: 659.25, start: 0.15}, {freq: 783.99, start: 0.3}, {freq: 1046.50, start: 0.45}];
                fanfare.forEach(note => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = note.freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + note.start;
                    gain.gain.setValueAtTime(0.2, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);
                    osc.start(startTime);
                    osc.stop(startTime + 0.5);
                });
            },
            defeat: (ctx, time) => {
                const descent = [{freq: 493.88, start: 0}, {freq: 440.00, start: 0.2}, {freq: 392.00, start: 0.4}, {freq: 293.66, start: 0.6}];
                descent.forEach(note => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = note.freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + note.start;
                    gain.gain.setValueAtTime(0.15, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.6);
                    osc.start(startTime);
                    osc.stop(startTime + 0.6);
                });
            },
            start: (ctx, time) => {
                const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + (i * 0.1);
                    gain.gain.setValueAtTime(0.12, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);
                    osc.start(startTime);
                    osc.stop(startTime + 0.5);
                });
            },
            error: (ctx, time) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.value = 150;
                osc.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.2, time);
                gain.gain.setValueAtTime(0, time + 0.1);
                gain.gain.setValueAtTime(0.2, time + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
                osc.start(time);
                osc.stop(time + 0.3);
            }
        };

        // Unified playSound function
        function playSound(soundName) {
            if (!game.settings.soundEnabled || !audioContext) return;
            const soundFn = soundEffects[soundName];
            if (!soundFn) {
                console.warn('Sound not found:', soundName);
                return;
            }
            try {
                const time = audioContext.currentTime;
                soundFn(audioContext, time);
            } catch (e) {
                // console.warn("Audio context error", e);
            }
        }
        
        // ============================================
// DARK ATMOSPHERIC MUSIC SYSTEM
// ============================================
// Substitui Epic8BitMusic por atmosfera dark medieval
// Inspirado em Heretic, Zelda, Diablo

class DarkAtmosphericMusic {
    constructor() {
        this.context = audioContext;
        this.masterGain = this.context.createGain();
        this.masterGain.connect(this.context.destination);
        this.masterGain.gain.value = 0.15; // Mais baixo que 8-bit
        
        this.isPlaying = false;
        this.currentContext = 'menu'; // menu, gameplay, shop, victory, defeat
        this.oscillators = [];
        this.intervals = [];
        this.gainNodes = [];
        
        this.contextNames = {
            menu: '🏰 Dark Awakening',
            gameplay: '⚔️ Into the Depths',
            shop: '🛍️ Merchant\'s Shadow',
            victory: '👑 Triumph in Darkness',
            defeat: '💀 The Final Darkness'
        };
    }
    
    getCurrentTrackName() {
        return this.contextNames[this.currentContext];
    }
    
    start() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.playContext(this.currentContext);
        this.updateNowPlayingDisplay();
    }
    
    stop() {
        this.isPlaying = false;
        this.stopAll();
        this.updateNowPlayingDisplay();
    }
    
    stopAll() {
        this.oscillators.forEach(osc => { try { osc.stop(); } catch(e) {} });
        this.intervals.forEach(id => clearInterval(id));
        this.oscillators = [];
        this.intervals = [];
        this.gainNodes = [];
    }
    
    // Sistema de troca automática de contexto
    switchContext(newContext) {
        if (this.currentContext === newContext) return;
        console.log(`🎵 Music: ${this.currentContext} → ${newContext}`);
        
        this.currentContext = newContext;
        
        if (this.isPlaying) {
            this.fadeOut(0.5, () => {
                this.stopAll();
                this.playContext(newContext);
                this.fadeIn(0.5);
            });
        }
        
        this.updateNowPlayingDisplay();
    }
    
    fadeOut(duration, callback) {
        this.masterGain.gain.exponentialRampToValueAtTime(
            0.001,
            this.context.currentTime + duration
        );
        setTimeout(callback, duration * 1000);
    }
    
    fadeIn(duration) {
        this.masterGain.gain.setValueAtTime(0.001, this.context.currentTime);
        this.masterGain.gain.exponentialRampToValueAtTime(
            0.15,
            this.context.currentTime + duration
        );
    }
    
    playContext(context) {
        switch(context) {
            case 'menu': this.playMenuTheme(); break;
            case 'gameplay': this.playGameplayTheme(); break;
            case 'shop': this.playShopTheme(); break;
            case 'victory': this.playVictoryTheme(); break;
            case 'defeat': this.playDefeatTheme(); break;
        }
    }
    
    updateNowPlayingDisplay() {
        const display = document.getElementById('nowPlayingDisplay');
        if (display) {
            display.textContent = this.isPlaying ? 
                this.getCurrentTrackName() : 
                '🎵 Music Paused';
        }
    }
    
    // ============================================
    // TRACK 1: MENU THEME - Dark Awakening
    // ============================================
    playMenuTheme() {
        // Drone grave contínuo (80 Hz)
        this.playDrone(80, 0.20, 'sine');
        this.playDrone(120, 0.15, 'triangle'); // Harmônico
        
        // Pad atmosférico dark
        this.playAtmosphericPad([196, 246.94, 293.66], 0.08); // G3, B3, D4 (menor)
        
        // Bells medievais espaçados (a cada 4 segundos)
        const bellPattern = [523.25, 392, 493.88, 440]; // C5, G4, B4, A4
        let bellIndex = 0;
        const bellTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playBell(bellPattern[bellIndex % bellPattern.length], 0.08, 2.0);
            bellIndex++;
        }, 4000);
        this.intervals.push(bellTimer);
    }
    
    // ============================================
    // TRACK 2: GAMEPLAY THEME - Into the Depths
    // ============================================
    playGameplayTheme() {
        // Drone + Bass pulsante (90 Hz, 2 batidas por segundo)
        this.playDrone(90, 0.18, 'sine');
        
        const bassInterval = 500; // 120 BPM = 500ms
        const bassPattern = [90, 90, 135, 90]; // Tônica, tônica, quinta, tônica
        let bassIndex = 0;
        const bassTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playPercussiveBass(bassPattern[bassIndex % bassPattern.length], 0.22, 0.15);
            bassIndex++;
        }, bassInterval);
        this.intervals.push(bassTimer);
        
        // Melodia menor misteriosa (escala frígia de E)
        const melody = [164.81, 174.61, 196, 220, 246.94, 261.63, 293.66]; // E, F, G, A, B, C, D
        const melPattern = [4, 3, 2, 0, 2, 3, 4, 2]; // Padrão misterioso
        let melIndex = 0;
        const melInterval = 1000;
        const melTimer = setInterval(() => {
            if (!this.isPlaying) return;
            const freq = melody[melPattern[melIndex % melPattern.length]];
            this.playNote(freq * 2, 0.10, 0.8, 'triangle');
            melIndex++;
        }, melInterval);
        this.intervals.push(melTimer);
        
        // Percussão dark sutil
        this.playDarkPercussion(bassInterval * 2);
    }
    
    // ============================================
    // TRACK 3: SHOP THEME - Merchant's Shadow
    // ============================================
    playShopTheme() {
        // Drone mais enérgico
        this.playDrone(110, 0.14, 'sine');
        
        // Bass rítmico (dá movimento)
        const bassPattern = [110, 110, 165, 110]; // Root, root, fifth, root
        let bassIndex = 0;
        const bassInterval = 400; // Mais rápido
        const bassTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playPercussiveBass(bassPattern[bassIndex % bassPattern.length], 0.16, 0.12);
            bassIndex++;
        }, bassInterval);
        this.intervals.push(bassTimer);
        
        // Arpejos medievais com ritmo
        const arpNotes = [261.63, 329.63, 392, 493.88]; // C4, E4, G4, B4
        let arpIndex = 0;
        const arpInterval = 400; // Mais rápido (sincronizado com bass)
        const arpTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playNote(arpNotes[arpIndex % arpNotes.length] * 2, 0.10, 0.35, 'triangle');
            arpIndex++;
        }, arpInterval);
        this.intervals.push(arpTimer);
        
        // Bells com mais presença e ritmo
        const bellPattern = [523.25, 659.25, 783.99, 659.25]; // C5, E5, G5, E5
        let bellIndex = 0;
        const bellTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playBell(bellPattern[bellIndex % bellPattern.length], 0.12, 1.2);
            bellIndex++;
        }, 1600); // Mais frequente
        this.intervals.push(bellTimer);
        
        // Percussão sutil para ritmo
        const percTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playDarkPercussion(800);
        }, 800);
        this.intervals.push(percTimer);
    }
    
    // ============================================
    // TRACK 4: VICTORY THEME - Triumph in Darkness
    // ============================================
    playVictoryTheme() {
        // Fanfarra épica ascendente e empolgante
        const fanfare = [
            {freq: 261.63, time: 0, duration: 0.3},      // C4
            {freq: 329.63, time: 0.3, duration: 0.3},    // E4
            {freq: 392, time: 0.6, duration: 0.3},       // G4
            {freq: 523.25, time: 0.9, duration: 0.5},    // C5
            {freq: 659.25, time: 1.5, duration: 0.4},    // E5
            {freq: 783.99, time: 2.0, duration: 1.0},    // G5 (final triunfante!)
        ];
        
        fanfare.forEach(note => {
            setTimeout(() => {
                if (!this.isPlaying) return;
                this.playNote(note.freq, 0.20, note.duration, 'square');
                this.playNote(note.freq * 2, 0.12, note.duration, 'triangle');
                this.playBell(note.freq, 0.08, note.duration * 2);
                // Percussão triunfante e rápida
                this.playDarkPercussion(80);
            }, note.time * 1000);
        });
        
        // Arpejo final celebratório
        const arpeggio = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
        arpeggio.forEach((freq, index) => {
            setTimeout(() => {
                if (!this.isPlaying) return;
                this.playNote(freq, 0.15, 0.3, 'sine');
            }, (3000 + index * 150));
        });
        
        // Drone victorioso
        setTimeout(() => {
            if (!this.isPlaying) return;
            this.playDrone(523.25, 0.12, 'triangle');
        }, 2000);
    }
    
    // ============================================
    // TRACK 5: DEFEAT THEME - The Final Darkness
    // ============================================
    playDefeatTheme() {
        // Descida cromática sombria
        const descent = [
            {freq: 293.66, time: 0},    // D4
            {freq: 277.18, time: 0.6},  // C#4
            {freq: 261.63, time: 1.2},  // C4
            {freq: 246.94, time: 1.8},  // B3
            {freq: 220, time: 2.4},     // A3
        ];
        
        descent.forEach(note => {
            setTimeout(() => {
                if (!this.isPlaying) return;
                this.playNote(note.freq, 0.15, 0.8, 'sine');
            }, note.time * 1000);
        });
        
        // Bells fúnebres
        setTimeout(() => {
            if (!this.isPlaying) return;
            this.playBell(523.25, 0.08, 3.0); // C5
        }, 1000);
        
        setTimeout(() => {
            if (!this.isPlaying) return;
            this.playBell(392, 0.08, 3.0); // G4
        }, 2000);
        
        // Fade to silence
        setTimeout(() => {
            this.fadeOut(2.0, () => {});
        }, 3000);
    }
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    playDrone(freq, volume, waveType = 'sine') {
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        const filter = this.context.createBiquadFilter();
        
        osc.type = waveType;
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = freq * 4; // Filtro suave
        filter.Q.value = 1;
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        gain.gain.setValueAtTime(0, this.context.currentTime);
        gain.gain.exponentialRampToValueAtTime(volume, this.context.currentTime + 1.0);
        
        osc.start(this.context.currentTime);
        
        this.oscillators.push(osc);
        this.gainNodes.push(gain);
    }
    
    playNote(freq, volume, duration, waveType = 'sine') {
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        const reverb = this.context.createConvolver();
        
        // Criar impulse response simples para reverb
        const reverbTime = 2.0;
        const reverbDecay = 2.0;
        const sampleRate = this.context.sampleRate;
        const length = sampleRate * reverbTime;
        const impulse = this.context.createBuffer(2, length, sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, reverbDecay);
            }
        }
        reverb.buffer = impulse;
        
        osc.type = waveType;
        osc.frequency.value = freq;
        
        osc.connect(gain);
        gain.connect(reverb);
        reverb.connect(this.masterGain);
        
        const now = this.context.currentTime;
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        
        osc.start(now);
        osc.stop(now + duration);
        
        this.oscillators.push(osc);
    }
    
    playBell(freq, volume, duration) {
        // Bell com harmônicos
        const harmonics = [1, 2.76, 5.4, 8.93]; // Proporções de sino
        
        harmonics.forEach((harmonic, index) => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = freq * harmonic;
            
            osc.connect(gain);
            gain.connect(this.masterGain);
            
            const now = this.context.currentTime;
            const vol = volume / (index + 1); // Harmônicos mais baixos
            gain.gain.setValueAtTime(vol, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.start(now);
            osc.stop(now + duration);
            
            this.oscillators.push(osc);
        });
    }
    
    playPercussiveBass(freq, volume, duration) {
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, this.context.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq * 0.5, this.context.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        
        const now = this.context.currentTime;
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        
        osc.start(now);
        osc.stop(now + duration);
        
        this.oscillators.push(osc);
    }
    
    playAtmosphericPad(freqs, volume) {
        freqs.forEach(freq => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            const filter = this.context.createBiquadFilter();
            
            osc.type = 'sawtooth';
            osc.frequency.value = freq;
            
            filter.type = 'lowpass';
            filter.frequency.value = freq * 2;
            filter.Q.value = 0.7;
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            
            gain.gain.setValueAtTime(0, this.context.currentTime);
            gain.gain.linearRampToValueAtTime(volume, this.context.currentTime + 2.0);
            
            osc.start(this.context.currentTime);
            
            this.oscillators.push(osc);
        });
    }
    
    playDarkPercussion(interval) {
        const percTimer = setInterval(() => {
            if (!this.isPlaying) return;
            
            // Kick drum grave
            const kick = this.context.createOscillator();
            const kickGain = this.context.createGain();
            
            kick.frequency.setValueAtTime(150, this.context.currentTime);
            kick.frequency.exponentialRampToValueAtTime(40, this.context.currentTime + 0.1);
            
            kick.connect(kickGain);
            kickGain.connect(this.masterGain);
            
            kickGain.gain.setValueAtTime(0.15, this.context.currentTime);
            kickGain.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + 0.1);
            
            kick.start(this.context.currentTime);
            kick.stop(this.context.currentTime + 0.1);
        }, interval);
        
        this.intervals.push(percTimer);
    }
    
    // Métodos de compatibilidade com código existente
    nextTrack() {
        // No sistema novo, não há "next track" manual
        // Mas mantém compatibilidade
        playSound('cardFlip');
    }
    
    prevTrack() {
        // Compatibilidade
        playSound('cardFlip');
    }
}
        const music = new DarkAtmosphericMusic();

        // Sound/Music Hooks
        btnTopSound.onclick = function() {
            game.settings.soundEnabled = !game.settings.soundEnabled;
            this.classList.toggle('active', game.settings.soundEnabled);
            this.textContent = game.settings.soundEnabled ? '🔊' : '🔇';
            if (game.settings.soundEnabled) playSound('cardFlip');
        };
        btnMusicToggle.onclick = function() {
            game.settings.musicEnabled = !game.settings.musicEnabled;
            this.classList.toggle('active', game.settings.musicEnabled);
            this.textContent = game.settings.musicEnabled ? '⏸️' : '⏯️';

            if (game.settings.musicEnabled) {
                music.start();
            } else {
                music.stop();
            }
        };
        
        // Music Volume Control (Gameplay)
        const musicVolumeSlider = document.getElementById('musicVolume');
        if (musicVolumeSlider) {
            // Initialize slider background with current value
            const initialVolume = musicVolumeSlider.value || 15;
            musicVolumeSlider.style.background = `linear-gradient(to right, #c9a961 0%, #c9a961 ${initialVolume}%, #2a2318 ${initialVolume}%, #2a2318 100%)`;
            
            musicVolumeSlider.oninput = (e) => {
                const volume = e.target.value / 100;
                const volumePercent = e.target.value;
                music.masterGain.gain.value = volume;
                
                // Update slider background dynamically
                e.target.style.background = `linear-gradient(to right, #c9a961 0%, #c9a961 ${volumePercent}%, #2a2318 ${volumePercent}%, #2a2318 100%)`;
            };
        }

        // Welcome Screen Music Controls (AFTER music is created)
        const btnWelcomeMusicToggle = document.getElementById('btnWelcomeMusicToggle');
        const btnWelcomeSoundboard = document.getElementById('btnWelcomeSoundboard');
        
        // Update music button visual
        function updateWelcomeMusicButton() {
            if (btnWelcomeMusicToggle) {
                btnWelcomeMusicToggle.textContent = music.isPlaying ? '⏸️' : '⏯️';
                btnWelcomeMusicToggle.style.opacity = music.isPlaying ? '1' : '0.7';
            }
            
            // Update now playing display
            music.updateNowPlayingDisplay();
        }
        
        if (btnWelcomeMusicToggle) {
            btnWelcomeMusicToggle.onclick = () => {
                game.settings.musicEnabled = !game.settings.musicEnabled;
                if (game.settings.musicEnabled) {
                    music.start();
                } else {
                    music.stop();
                }
                updateWelcomeMusicButton();
                playSound('click');
            };
        }
        
        // Music Volume Control (Welcome Screen)
        const welcomeMusicVolumeSlider = document.getElementById('welcomeMusicVolume');
        if (welcomeMusicVolumeSlider) {
            // Initialize slider background with current value
            const initialVolume = welcomeMusicVolumeSlider.value;
            welcomeMusicVolumeSlider.style.background = `linear-gradient(to right, #c9a961 0%, #c9a961 ${initialVolume}%, #2a2318 ${initialVolume}%, #2a2318 100%)`;
            
            welcomeMusicVolumeSlider.oninput = (e) => {
                const volume = e.target.value / 100;
                const volumePercent = e.target.value;
                music.masterGain.gain.value = volume;
                
                // Update slider background dynamically
                e.target.style.background = `linear-gradient(to right, #c9a961 0%, #c9a961 ${volumePercent}%, #2a2318 ${volumePercent}%, #2a2318 100%)`;
                
                // Sync with gameplay slider
                if (musicVolumeSlider) {
                    musicVolumeSlider.value = e.target.value;
                    musicVolumeSlider.style.background = `linear-gradient(to right, #c9a961 0%, #c9a961 ${volumePercent}%, #2a2318 ${volumePercent}%, #2a2318 100%)`;
                }
            };
        }
        
        // Soundboard Modal
        const soundboardModal = document.getElementById('soundboardModal');
        const btnCloseSoundboard = document.getElementById('btnCloseSoundboard');
        
        if (btnWelcomeSoundboard) {
            btnWelcomeSoundboard.onclick = () => {
                soundboardModal.classList.add('active');
                playSound('click');
            };
        }
        
        if (btnCloseSoundboard) {
            btnCloseSoundboard.onclick = () => {
                soundboardModal.classList.remove('active');
            };
        }
        
        // Soundboard Buttons
        document.getElementById('btnPlayMenu')?.addEventListener('click', () => {
            game.settings.musicEnabled = true;
            music.switchContext('menu');
            if (!music.isPlaying) music.start();
            playSound('cardFlip');
            updateWelcomeMusicButton();
        });
        
        document.getElementById('btnPlayGameplay')?.addEventListener('click', () => {
            game.settings.musicEnabled = true;
            music.switchContext('gameplay');
            if (!music.isPlaying) music.start();
            playSound('cardFlip');
            updateWelcomeMusicButton();
        });
        
        document.getElementById('btnPlayShop')?.addEventListener('click', () => {
            game.settings.musicEnabled = true;
            music.switchContext('shop');
            if (!music.isPlaying) music.start();
            playSound('cardFlip');
            updateWelcomeMusicButton();
        });
        
        document.getElementById('btnPlayVictory')?.addEventListener('click', () => {
            game.settings.musicEnabled = true;
            music.switchContext('victory');
            if (!music.isPlaying) music.start();
            playSound('cardFlip');
            updateWelcomeMusicButton();
        });
        
        document.getElementById('btnPlayDefeat')?.addEventListener('click', () => {
            game.settings.musicEnabled = true;
            music.switchContext('defeat');
            if (!music.isPlaying) music.start();
            playSound('cardFlip');
            updateWelcomeMusicButton();
        });
        
        // Initialize welcome music button state
        updateWelcomeMusicButton();

        // Particles System with performance limit
        let activeParticles = 0;
        const MAX_PARTICLES = 150; // Prevent performance issues
        
        function createParticles(x, y, color, count = 10) {
            // Limit number of particles for performance
            const actualCount = Math.min(count, MAX_PARTICLES - activeParticles);
            if (actualCount <= 0) return; // Skip if at limit
            
            for (let i = 0; i < actualCount; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.cssText = `
                    left: ${x}px;
                    top: ${y}px;
                    width: ${Math.random() * 8 + 4}px;
                    height: ${Math.random() * 8 + 4}px;
                    background: ${color};
                    border-radius: 50%;
                    animation: particleFade ${Math.random() * 0.5 + 0.5}s ease-out forwards;
                    transform: translate(${(Math.random() - 0.5) * 100}px, ${(Math.random() - 0.5) * 100}px);
                `;
                activeParticles++;
                document.body.appendChild(particle);
                setTimeout(() => {
                    particle.remove();
                    activeParticles--;
                }, 1000);
            }
        }
        
        // Add particle animation CSS
        if (!document.getElementById('particleStyles')) {
            const style = document.createElement('style');
            style.id = 'particleStyles';
            style.textContent = `
                .particle {
                    position: fixed;
                    pointer-events: none;
                    z-index: 9999;
                }
                @keyframes particleFade {
                    0% { opacity: 1; transform: translateY(0) scale(1); }
                    100% { opacity: 0; transform: translateY(-100px) scale(0); }
                }
                @keyframes shake {
                    0%, 100% { transform: translateX(0); }
                    25% { transform: translateX(-10px); }
                    75% { transform: translateX(10px); }
                }
                .shake { animation: shake 0.4s ease; }
                
                @keyframes slideInRight {
                    0% { 
                        opacity: 0; 
                        transform: translateX(400px) scale(0.8); 
                    }
                    50% { 
                        transform: translateX(-20px) scale(1.05); 
                    }
                    100% { 
                        opacity: 1; 
                        transform: translateX(0) scale(1); 
                    }
                }
                
                .achievement-toast {
                    transition: opacity 0.5s ease, transform 0.5s ease;
                }
                
                .damage-number {
                    position: fixed;
                    font-size: 2.5em;
                    font-weight: bold;
                    pointer-events: none;
                    z-index: 9999;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                    animation: damageFloat 1.5s ease-out forwards;
                }
                @keyframes damageFloat {
                    0% { opacity: 1; transform: translateY(0) scale(0.5); }
                    50% { transform: translateY(-60px) scale(1.2); }
                    100% { opacity: 0; transform: translateY(-120px) scale(0.8); }
                }
                .damage-number.damage { color: #ff6b6b; }
                .damage-number.heal { color: #6bcf7f; }
                .damage-number.combo { color: #ffd93d; }
                .damage-number.score { color: #ffd700; font-size: 3em; }
                
                .combo-counter {
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%) scale(0);
                    font-size: 5em;
                    font-weight: bold;
                    color: #ffd93d;
                    text-shadow: 0 0 30px rgba(255, 217, 61, 0.8);
                    pointer-events: none;
                    z-index: 9998;
                    animation: comboPopup 1s ease-out forwards;
                }
                @keyframes comboPopup {
                    0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); opacity: 0; }
                    50% { transform: translate(-50%, -50%) scale(1.3) rotate(5deg); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(0.8) rotate(0deg); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Damage Numbers System
        function showDamageNumber(amount, type = 'damage') {
            const x = window.innerWidth / 2 + (Math.random() - 0.5) * 200;
            const y = window.innerHeight / 2 + (Math.random() - 0.5) * 200;
            
            const damageEl = document.createElement('div');
            damageEl.className = `damage-number ${type}`;
            damageEl.textContent = typeof amount === 'number' ? (type === 'heal' ? `+${amount}` : `-${amount}`) : amount;
            damageEl.style.left = x + 'px';
            damageEl.style.top = y + 'px';
            
            document.body.appendChild(damageEl);
            setTimeout(() => damageEl.remove(), 1500);
            
            // Particles
            const color = type === 'heal' ? '#6bcf7f' : (type === 'damage' ? '#ff6b6b' : '#ffd93d');
            createParticles(x, y, color, 15);
        }
        
        function showCombo(count) {
            const comboEl = document.createElement('div');
            comboEl.className = 'combo-counter';
            
            // Different messages and colors based on combo count
            let message = `${count}x COMBO!`;
            let color = '#ffd93d'; // Default yellow
            
            if (count >= 10) {
                message = `${count}x LEGENDARY!`;
                color = '#ff6b6b'; // Red for legendary
            } else if (count >= 7) {
                message = `${count}x AMAZING!`;
                color = '#a8edea'; // Blue for amazing
            } else if (count >= 5) {
                message = `${count}x GREAT!`;
                color = '#6bcf7f'; // Green for great
            }
            
            comboEl.textContent = message;
            comboEl.style.color = color;
            comboEl.style.textShadow = `0 0 30px ${color}`;
            
            document.body.appendChild(comboEl);
            setTimeout(() => comboEl.remove(), 1000);
            
            // Extra particles for high combos
            if (count >= 5) {
                createParticles(window.innerWidth / 2, window.innerHeight / 2, color, count * 3);
            }
        }
        
        function screenShake() {
            const gameWrapper = document.getElementById('gameWrapper');
            if (gameWrapper) {
                gameWrapper.classList.add('shake');
                setTimeout(() => gameWrapper.classList.remove('shake'), 400);
            }
        }

        // Hold System
        function holdCard(card, sourceIndex) {
            // Check max hold cards (Rogue can hold 2)
            const maxHold = (game.classData && game.classData.passive.maxHoldCards) || 1;
            
            // Count current held cards
            const currentHeldCount = game.heldCard ? (Array.isArray(game.heldCard) ? game.heldCard.length : 1) : 0;
            
            if (currentHeldCount >= maxHold) {
                showMessage(`❌ Hold slots full! (Max: ${maxHold})`, 'warning');
                playSound('error');
                return;
            }
            
            // Monsters cannot be held!
            const cardType = getCardType(card);
            if (cardType === 'monster') {
                showMessage('❌ Monsters cannot be held! You must fight them.', 'danger');
                playSound('error');
                return;
            }
            
            // Initialize heldCard as array for Rogue, single for others
            if (!game.heldCard) {
                game.heldCard = maxHold > 1 ? [] : null;
            }
            
            // Add to hold
            const cardToHold = { ...card, sourceIndex };
            if (maxHold > 1) {
                if (!Array.isArray(game.heldCard)) game.heldCard = [];
                game.heldCard.push(cardToHold);
            } else {
                game.heldCard = cardToHold;
            }
            
            game.room.splice(sourceIndex, 1);
            game.stats.cardsHeld++;
            
            const typeEmoji = {
                'weapon': '⚔️',
                'potion': '💊',
                'special': '✨'
            };
            
            playSound('hold');
            addLog(`Held ${card.value}${card.suit}`, 'info');
            showMessage(`📌 ${typeEmoji[cardType]} Held for later use! (${currentHeldCount + 1}/${maxHold})`, 'info');
            createParticles(window.innerWidth / 2, window.innerHeight / 3, '#ffd93d', 20);
            updateUI();
            checkGameState(); // Check if room is now cleared after holding card
        }

        function useHeldCard() {
            if (!game.heldCard) return;
            
            const card = game.heldCard;
            game.heldCard = null;
            
            game.room.unshift(card); // Adds back to the start of the room
            
            updateUI();
            
            // Simulates clicking the card that just returned
            setTimeout(() => {
                const firstCardEl = bottomBar.querySelector('.card');
                if (firstCardEl) {
                    firstCardEl.click();
                }
            }, 100);
        }
        
        // ============================================
        // CLASS ABILITIES
        // ============================================
        
        function useClassAbility() {
            if (!game.classData) return;
            
            // Scoundrel has no ability
            if (!game.classData.active) {
                showMessage('❌ Scoundrel has no special abilities!', 'warning');
                playSound('error');
                return;
            }
            
            // Check cooldown
            if (game.classAbilityCooldown > 0) {
                showMessage(`⏳ Ability on cooldown! ${game.classAbilityCooldown} rooms remaining.`, 'warning');
                playSound('error');
                return;
            }
            
            // Execute ability based on class
            if (game.playerClass === 'knight') {
                useKnightAbility();
            } else if (game.playerClass === 'rogue') {
                useRogueAbility();
            } else if (game.playerClass === 'dancer') {
                useDancerAbility();
            } else if (game.playerClass === 'berserker') {
                useBerserkerAbility();
            } else if (game.playerClass === 'priest') {
                usePriestAbility();
            }
            
            updateAbilityUI();
        }
        
        function useKnightAbility() {
            // Shield Bash: Deal weapon damage to first monster
            if (!game.equippedWeapon) {
                showMessage('⚠️ Need a weapon equipped to use Shield Bash!', 'warning');
                playSound('error');
                return;
            }
            
            const firstMonster = game.room.find(c => getCardType(c) === 'monster');
            if (!firstMonster) {
                showMessage('⚠️ No monsters in room!', 'warning');
                playSound('error');
                return;
            }
            
            const powerBonus = getRelicBonus('power') + getRelicBonus('bigPower');
            const damage = game.equippedWeapon.numValue + powerBonus;
            firstMonster.numValue -= damage;
            
            if (firstMonster.numValue <= 0) {
                const index = game.room.indexOf(firstMonster);
                game.room.splice(index, 1);
                game.discardPile.push(firstMonster);
                game.stats.monstersSlain++;
                showMessage(`🛡️ Shield Bash! Monster defeated!`, 'success');
            } else {
                showMessage(`🛡️ Shield Bash! Dealt ${damage} damage! (${firstMonster.numValue} HP left)`, 'success');
            }
            
            game.classAbilityCooldown = game.classData.active.cooldown;
            playSound('special');
            createParticles(window.innerWidth / 2, window.innerHeight / 2, '#c9a961', 40);
            updateUI();
            checkGameState();
        }
        
        function useRogueAbility() {
            // Shadow Strike: Next monster 2x damage, combo safe
            game.classAbilityActive = true;
            game.classAbilityCounter = 1; // Next monster only
            game.classAbilityCooldown = game.classData.active.cooldown;
            
            showMessage('🔪 Shadow Strike activated! Next kill: 2x damage, combo safe!', 'success');
            playSound('special');
            createParticles(window.innerWidth / 2, window.innerHeight / 2, '#667eea', 40);
            updateUI();
        }
        
        function useDancerAbility() {
            // Healing Dance: Heal 5 HP + damage buff
            game.health = Math.min(game.maxHealth, game.health + 5);
            game.classAbilityActive = true;
            game.classAbilityCounter = 2; // Next 2 monsters
            game.classAbilityCooldown = game.classData.active.cooldown;
            
            showMessage('✨ Healing Dance! +5 HP and damage buff for 2 attacks!', 'success');
            playSound('heal');
            createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd93d', 50);
            updateUI();
        }
        
        function useBerserkerAbility() {
            // Rage Strike: Sacrifice 5 HP for 3x damage
            if (game.health <= 5) {
                showMessage('⚠️ Not enough HP! Need more than 5 HP to use Rage Strike.', 'danger');
                playSound('error');
                return;
            }
            
            // Sacrifice HP
            game.health -= 5;
            
            // Activate 3x damage buff
            game.classAbilityActive = true;
            game.classAbilityCounter = 1; // Next attack only
            game.rageStrikeActive = true; // Special flag for triple damage
            game.classAbilityCooldown = game.classData.active.cooldown;
            
            // Break combo (high risk)
            if (game.combo > 0) {
                showMessage(`💢 Rage Strike! -5 HP, next attack: 3x damage! ⚠️ Combo broken! (Lost ${game.combo}x)`, 'warning');
                game.combo = 0;
            } else {
                showMessage('💢 Rage Strike! -5 HP, next attack: 3x damage!', 'warning');
            }
            
            playSound('special');
            screenShake();
            createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff6b6b', 60);
            updateUI();
        }
        
        function usePriestAbility() {
            // Purification: Remove strongest monster or convert to potion
            const monsters = game.dungeon.filter(c => getCardType(c) === 'monster');
            
            if (monsters.length === 0) {
                showMessage('⚠️ No monsters in dungeon to purify!', 'warning');
                playSound('error');
                return;
            }
            
            // Find strongest monster
            const strongestMonster = monsters.reduce((max, card) => 
                card.numValue > max.numValue ? card : max
            );
            
            // Ask player what to do
            const choice = confirm(
                `📿 PURIFICATION\n\n` +
                `Strongest monster: ${strongestMonster.value}${strongestMonster.suit} (${strongestMonster.numValue} HP)\n\n` +
                `Choose:\n` +
                `• OK = Remove permanently\n` +
                `• Cancel = Transform into potion`
            );
            
            const index = game.dungeon.indexOf(strongestMonster);
            
            if (choice) {
                // Remove permanently
                game.dungeon.splice(index, 1);
                showMessage(`📿 Purification! ${strongestMonster.value}${strongestMonster.suit} removed from existence!`, 'success');
            } else {
                // Transform to potion (random value 2-10)
                const potionValue = Math.floor(Math.random() * 9) + 2;
                game.dungeon[index] = {
                    value: potionValue.toString(),
                    suit: '♥',
                    numValue: potionValue,
                    suitName: 'hearts'
                };
                showMessage(`📿 Purification! ${strongestMonster.value}${strongestMonster.suit} transformed into ${potionValue}♥ potion!`, 'success');
            }
            
            game.classAbilityCooldown = game.classData.active.cooldown;
            playSound('special');
            createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd700', 70);
            updateUI();
        }
        
        function updateAbilityUI() {
            const btn = document.getElementById('btnClassAbility');
            const cooldownDisplay = document.getElementById('abilityCooldownDisplay');
            const desc = document.getElementById('abilityDescription');
            
            if (!game.classData) return;
            
            // Scoundrel has no ability - disable button
            if (!game.classData.active) {
                btn.disabled = true;
                btn.style.opacity = '0.3';
                btn.style.display = 'none'; // Hide button for Scoundrel
                cooldownDisplay.style.display = 'none';
                if (desc) desc.textContent = 'No abilities available';
                return;
            }
            
            // Show button for classes with abilities
            btn.style.display = 'block';
            
            if (game.classAbilityCooldown > 0) {
                btn.disabled = true;
                btn.style.opacity = '0.5';
                cooldownDisplay.textContent = `${game.classAbilityCooldown} rooms`;
                cooldownDisplay.style.display = 'block';
            } else {
                btn.disabled = false;
                btn.style.opacity = '1';
                cooldownDisplay.style.display = 'none';
            }
            
            // Show active buff
            if (game.classAbilityActive && game.classAbilityCounter > 0) {
                desc.innerHTML = `<strong style="color: #6bcf7f;">✨ ACTIVE! ${game.classAbilityCounter} uses left</strong>`;
            } else {
                desc.textContent = game.classData.active.description;
            }
        }
        
        // Tooltip Generation
        function generateTooltip(card) {
            const type = getCardType(card);
            
            // Obliterate mode
            if (game.obliterateMode) {
                return `<span class="tooltip-negative">💥 OBLITERATE: Remove this card permanently!</span>`;
            }
            
            const powerBonus = getRelicBonus('power') + getRelicBonus('bigPower');
            
            if (type === 'monster') {
                const baseWeapon = game.equippedWeapon?.numValue || 0;
                const berserkBonus = game.berserkStacks > 0 ? 5 : 0;
                
                // Add class ability bonuses
                let classBonus = 0;
                if (game.classAbilityActive && game.classAbilityCounter > 0) {
                    if (game.playerClass === 'dancer') {
                        classBonus = 2;
                    }
                }
                
                // Berserker Bloodlust passive
                let bloodlustBonus = 0;
                if (game.classData && game.classData.passive.bloodlust) {
                    const hpPercent = (game.health / game.maxHealth) * 100;
                    if (hpPercent <= 30) bloodlustBonus = 3;
                    else if (hpPercent <= 50) bloodlustBonus = 2;
                    else if (hpPercent <= 70) bloodlustBonus = 1;
                }
                
                const totalWeapon = baseWeapon + powerBonus + berserkBonus + classBonus + bloodlustBonus;
                let effectiveWeapon = game.doubleDamage ? totalWeapon * 2 : totalWeapon;
                
                // Rogue Shadow Strike (2x)
                if (game.classAbilityActive && game.classAbilityCounter > 0 && game.playerClass === 'rogue') {
                    effectiveWeapon *= 2;
                }
                
                // Berserker Rage Strike (3x)
                if (game.rageStrikeActive && game.classAbilityCounter > 0) {
                    effectiveWeapon *= 3;
                }

                if (baseWeapon === 0) {
                    return `<span class="tooltip-negative">⚠️ No weapon! Damage: -${card.numValue} HP</span>`;
                }
                
                let actualDamage = card.numValue - effectiveWeapon;
                
                // Add info about active buffs
                let buffInfo = '';
                if (game.berserkStacks > 0) buffInfo += `🔥+${berserkBonus} `;
                if (game.doubleDamage) buffInfo += `⚡2x `;
                if (game.mirrorShield > 0) buffInfo += `🪞${game.mirrorShield} `;
                if (classBonus > 0) buffInfo += `💃+${classBonus} `;
                if (bloodlustBonus > 0) buffInfo += `💢+${bloodlustBonus} `;
                if (game.classAbilityActive && game.classAbilityCounter > 0 && game.playerClass === 'rogue') buffInfo += `🔪2x `;
                if (game.rageStrikeActive && game.classAbilityCounter > 0) buffInfo += `⚔️3x `;
                
                if (game.dodgeActive) return `<span class="tooltip-positive">🛡️ Dodge: No damage! ${buffInfo}</span>`;
                
                if (game.mirrorShield > 0 && actualDamage > 0) {
                    const reflected = Math.min(actualDamage, game.mirrorShield);
                    const remaining = actualDamage - reflected;
                    if (remaining <= 0) {
                        return `<span class="tooltip-positive">🪞 Mirror blocks all! ${buffInfo}</span>`;
                    } else {
                        return `<span class="tooltip-warning">🪞 Mirror -${reflected}, Take -${remaining} ${buffInfo}</span>`;
                    }
                }
                
                if (actualDamage > 0) return `<span class="tooltip-negative">⚔️ Fight: -${actualDamage} HP ${buffInfo}</span>`;
                else return `<span class="tooltip-positive">⚔️ Perfect! No damage! ${buffInfo}</span>`;
                
            } else if (type === 'weapon') {
                const current = (game.equippedWeapon?.numValue || 0) + powerBonus;
                const cardValue = card.numValue + powerBonus;

                if (cardValue > current) return `<span class="tooltip-positive">⬆️ Better Weapon! (${current} → ${cardValue})</span>`;
                else if (cardValue < current) return `<span class="tooltip-negative">⬇️ Worse Weapon (${current} → ${cardValue})</span>`;
                else return `<span class="tooltip-neutral">↔️ Same Weapon (${cardValue})</span>`;
                
            } else if (type === 'potion') {
                const maxPotions = (game.classData && game.classData.passive.maxPotionsPerRoom) || 1;
                if (game.potionsUsed >= maxPotions) {
                    return `<span class="tooltip-negative">❌ Potion limit reached (${maxPotions}/${maxPotions})</span>`;
                }
                
                const healBonus = getRelicBonus('healBonus');
                const classHealBonus = (game.classData && game.classData.passive.potionHealBonus) || 0;
                const totalHealBonus = healBonus + classHealBonus;
                const heal = Math.min(card.numValue + totalHealBonus, game.maxHealth - game.health);

                if (heal > 0) {
                    let bonusText = totalHealBonus > 0 ? ` (+${totalHealBonus} bonus)` : '';
                    return `<span class="tooltip-positive">💚 Heal: +${heal} HP${bonusText}</span>`;
                } else {
                    return `<span class="tooltip-neutral">💚 HP Full</span>`;
                }
                
            } else if (card.special) {
                return `<span class="tooltip-positive">✨ ${card.special.description}</span>`;
            }
            return '';
        }
        
        // ===== ACHIEVEMENT SYSTEM =====
        function checkAchievements() {
            // Check achievements in real-time during gameplay
            checkAllAchievements();
            
            // Check in-game achievements that can't be checked via lifetime stats
            const unlocked = loadAchievements();
            
            // Collector - 3 relics in single run
            if (game.relics.length >= 3 && !unlocked.includes('collector')) {
                unlockAchievement('collector');
            }
            
            // Relic Hunter - 5 relics in single run
            if (game.relics.length >= 5 && !unlocked.includes('relic_hunter')) {
                unlockAchievement('relic_hunter');
            }
        }

        // Game Log (now in a modal or sidebar? For now, no visible log)
        function addLog(message, type = 'info') {
            console.log(`LOG [${type}]: ${message}`);
            // (The log UI was removed for a cleaner layout)
        }
        
        // Initialize deck
        function createDeck() {
            let deck = [];
            
            // SCOUNDREL ORIGINAL RULES:
            // Remove: Jokers, Red Face Cards (J♥,Q♥,K♥,J♦,Q♦,K♦), Red Aces (A♥,A♦)
            
            // 26 MONSTERS (♠ Spades + ♣ Clubs): A(14), 2-10, J(11), Q(12), K(13)
            const monsterSuits = [
                { suit: '♠', suitName: 'spades' },
                { suit: '♣', suitName: 'clubs' }
            ];
            const monsterValues = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
            const monsterNumValues = [14, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13];
            
            for (let suit of monsterSuits) {
                for (let i = 0; i < monsterValues.length; i++) {
                    deck.push({ 
                        value: monsterValues[i], 
                        suit: suit.suit, 
                        numValue: monsterNumValues[i], 
                        suitName: suit.suitName 
                    });
                }
            }
            
            // 9 WEAPONS (♦ Diamonds): 2-10 only (NO face cards, NO Ace)
            const weaponValues = ['2', '3', '4', '5', '6', '7', '8', '9', '10'];
            const weaponNumValues = [2, 3, 4, 5, 6, 7, 8, 9, 10];
            
            for (let i = 0; i < weaponValues.length; i++) {
                deck.push({ 
                    value: weaponValues[i], 
                    suit: '♦', 
                    numValue: weaponNumValues[i], 
                    suitName: 'diamonds' 
                });
            }
            
            // 9 POTIONS (♥ Hearts): 2-10 only (NO face cards, NO Ace)
            const potionValues = ['2', '3', '4', '5', '6', '7', '8', '9', '10'];
            const potionNumValues = [2, 3, 4, 5, 6, 7, 8, 9, 10];
            
            for (let i = 0; i < potionValues.length; i++) {
                deck.push({ 
                    value: potionValues[i], 
                    suit: '♥', 
                    numValue: potionNumValues[i], 
                    suitName: 'hearts' 
                });
            }
            
            // SPECIAL CARDS (our addition for gamification)
            // Always 6 special cards, but types are random (deck = 50 cards total)
            const specialCount = 6;
            for (let i = 0; i < specialCount; i++) {
                deck.push({ 
                    value: '✨', 
                    suit: '', 
                    numValue: 0, 
                    suitName: 'special', 
                    special: specialCards[Math.floor(Math.random() * specialCards.length)] 
                });
            }
            
            // TOTAL: 26 monsters + 9 weapons + 9 potions + 6 specials = 50 cards
            return shuffleDeck(deck);
        }

        function shuffleDeck(deck) {
            let shuffled = [...deck];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // ============================================
        // MAIN GAME LOGIC
        // ============================================

        function startGame() {
            // 1. Load Stats and Unlocks
            loadPermanentStats();
            loadUnlocks();
            
            // 2. Configure Game State
            game.difficulty = document.querySelector('.difficulty-btn.selected').dataset.difficulty;
            const healthMap = { easy: 20, normal: 15, hard: 10, endless: 15 };
            let startHealthBonus = permanentUnlocks.startHealth ? 5 : 0;

            game.maxHealth = healthMap[game.difficulty] + startHealthBonus;
            
            // Apply class passives
            if (game.classData && game.classData.passive) {
                // Knight: +5 Max HP
                if (game.classData.passive.maxHpBonus) {
                    game.maxHealth += game.classData.passive.maxHpBonus;
                }
                // Priest: +2 Max HP (starting bonus)
                if (game.classData.passive.startMaxHpBonus) {
                    game.maxHealth += game.classData.passive.startMaxHpBonus;
                }
            }
            
            game.health = game.maxHealth;
            
            // Update player info display
            if (game.playerClass) {
                document.getElementById('playerAvatar').src = `assets/avatar-${game.playerClass}.jpg`;
                document.getElementById('playerNameDisplay').textContent = sanitizePlayerName(playerNameInput.value);
                document.getElementById('playerClassDisplay').textContent = game.classData.name;
                
                // Update ability button (only if class has an active ability)
                if (game.classData.active) {
                    document.getElementById('abilityIcon').textContent = game.classData.active.icon;
                    document.getElementById('abilityName').textContent = game.classData.active.name;
                    document.getElementById('abilityDescription').textContent = game.classData.active.description;
                }
                
                // Show passive icons
                const passiveIconsDisplay = document.getElementById('passiveIconsDisplay');
                passiveIconsDisplay.innerHTML = '';
                
                // Create passive icons based on class
                const passiveIcons = {
                    knight: [
                        { icon: '❤️', text: '+5 HP', title: 'Start with +5 Max HP' },
                        { icon: '🔨', text: '+1 Dur', title: 'Weapons last +1 use' }
                    ],
                    rogue: [
                        { icon: '📌', text: 'x2 Hold', title: 'Can hold 2 cards' },
                        { icon: '💰', text: '+1 Gold', title: '+1 gold per room' }
                    ],
                    dancer: [
                        { icon: '💊', text: '+3 HP', title: 'Potions heal +3 HP' },
                        { icon: '💊', text: 'x2 Use', title: 'Use 2 potions per room' },
                        { icon: '🎲', text: '+15%', title: '+15% event chance' }
                    ],
                    berserker: [
                        { icon: '💢', text: 'Bloodlust', title: 'Damage increases as HP decreases' },
                        { icon: '⚔️', text: 'High Risk', title: '+1/+2/+3 damage at ≤70%/50%/30% HP' }
                    ],
                    priest: [
                        { icon: '🕊️', text: '15% Dodge', title: '15% chance to dodge damage' },
                        { icon: '💊', text: '+1 HP', title: 'Potions heal +1 HP' },
                        { icon: '❤️', text: '+2 HP', title: 'Start with +2 Max HP' }
                    ]
                };
                
                const icons = passiveIcons[game.playerClass] || [];
                icons.forEach(passive => {
                    const iconEl = document.createElement('div');
                    iconEl.style.cssText = 'background: rgba(0,0,0,0.5); border: 1px solid #5a4a38; border-radius: 6px; padding: 4px 8px; font-size: 0.7em; display: flex; align-items: center; gap: 4px; color: #ffd700;';
                    iconEl.title = passive.title;
                    iconEl.innerHTML = `<span>${passive.icon}</span><span style="color: #c9a961;">${passive.text}</span>`;
                    passiveIconsDisplay.appendChild(iconEl);
                });
            }
            
            game.deck = createDeck();
            game.dungeon = [...game.deck];
            game.room = [];
            game.discardPile = [];
            game.equippedWeapon = null;
            game.heldCard = null;
            game.potionsUsed = 0;
            game.gameOver = false;
            game.score = 0;
            game.combo = permanentUnlocks.comboMaster ? 1 : 0;
            game.dodgeActive = false;
            game.doubleDamage = false;
            game.berserkStacks = 0;
            game.mirrorShield = 0;
            game.obliterateMode = false;
            game.gameStartTime = Date.now();
            game.seenEvents = []; // Track events seen this run (no repeats)
            game.eventTriggeredThisRoom = false; // Max 1 event per room
            game.shopPriceMultiplier = 1.0; // Price increases 15% per purchase (anti-exploit)
            
            // Class abilities
            game.classAbilityCooldown = 0; // Cooldown in rooms
            game.classAbilityActive = false; // Is buff active?
            game.classAbilityCounter = 0; // Uses left for buff
            
            // Run Stats
            game.stats = {
                monstersSlain: 0, totalDamage: 0, totalHealing: 0, roomsCleared: 0,
                weaponsEquipped: 0, potionsUsed: 0, maxCombo: 0, specialsUsed: 0,
                cardsHeld: 0, roomsAvoided: 0, gamesWon: 0, hardWins: 0,
                shopsVisited: 0,  // Track for score penalty
                minimalistWin: false, onePunch: false, musicWasOn: game.settings.musicEnabled
            };
            
            // Initial Gold and Relics
            const startingGoldMap = { easy: 30, normal: 15, hard: 0, endless: 15 };
            game.gold = startingGoldMap[game.difficulty] || 0;
            game.totalGoldEarned = 0;
            game.relics = [];
            applyPermanentUnlocks(); // Applies initial gold/relics

            // 3. Update UI
            addLog(`Game started on ${game.difficulty.toUpperCase()} difficulty!`, 'info');
            showMessage(`Game started! Enter a dungeon to begin.`, 'info');
            
            btnStartGameModal.disabled = true; // Prevent double click
            btnDrawRoom.disabled = false;
            btnAvoidRoom.disabled = false;
            
            // Start Timer
            if (game.gameTimerInterval) clearInterval(game.gameTimerInterval);
            game.gameTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - game.gameStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                gameTimer.textContent = `⏱️ ${minutes}:${seconds}`;
            }, 1000);
            
            updateUI();
            updateRelicsDisplay();
            
            // 4. Change Screens
            showGameUI();
            
            playSound('start');
            
            // Switch to gameplay music
            music.switchContext('gameplay');
        }

        function drawRoom() {
            if (game.dungeon.length === 0) {
                // Endless mode: reload deck instead of ending
                if (game.difficulty === 'endless') {
                    game.dungeon = createDeck();
                    showMessage('♾️ ENDLESS MODE: Deck reloaded! The dungeon never ends!', 'info');
                    playSound('special');
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, '#a8edea', 50);
                } else {
                    endGame('victory');
                    return;
                }
            }

            // Check if it's a boss room (every 10 rooms)
            const nextRoomNumber = game.stats.roomsCleared + 1;
            const isBossRoom = nextRoomNumber % 10 === 0;
            
            // Warn player about upcoming boss
            if (nextRoomNumber === 9) {
                showMessage('⚠️ BOSS APPROACHING! Prepare for battle in the next room!', 'warning');
            }
            
            if (isBossRoom) {
                // BOSS BATTLE!
                const bossNumber = Math.floor(nextRoomNumber / 10);
                const bossHP = 15; // Fixed boss HP
                
                // Boss names and flavor
                const bossNames = [
                    { name: 'The Forgotten Knight', flavor: 'A hollow warrior bound by ancient curses...' },
                    { name: 'The Crimson Warden', flavor: 'Guardian of the deeper dungeons, covered in blood of the fallen.' },
                    { name: 'The Shadow Lord', flavor: 'Darkness incarnate. Few have lived to speak of this encounter.' },
                    { name: 'The Abyss Keeper', flavor: 'The final horror. The one who devours all hope.' }
                ];
                
                const boss = bossNames[Math.min(bossNumber - 1, bossNames.length - 1)];
                
                const bossCard = {
                    suit: '👹',
                    value: '👹',
                    numValue: bossHP,
                    maxHP: bossHP, // Store max HP for HP bar
                    isBoss: true,
                    bossNumber: bossNumber,
                    bossName: boss.name,
                    bossFlavor: boss.flavor
                };
                
                const numToDraw = Math.min(3, game.dungeon.length);
                const drawnCards = game.dungeon.splice(0, numToDraw);
                game.room.push(bossCard, ...drawnCards);
                game.lastActionWasAvoid = false;
                
                playSound('special');
                addLog(`⚠️ BOSS BATTLE! ${boss.name} has ${bossHP} HP!`, 'danger');
                showMessage(`👹 BOSS: ${boss.name}`, 'danger');
                
                // Show boss intro with flavor
                setTimeout(() => {
                    showMessage(boss.flavor, 'info');
                }, 1000);
                
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff6b6b', 60);
            } else {
                // Normal room
                const numToDraw = 4;
                const drawnCards = game.dungeon.splice(0, Math.min(numToDraw, game.dungeon.length));
                game.room.push(...drawnCards);
                game.lastActionWasAvoid = false;
                
                playSound('cardDraw');
                addLog(`Entered dungeon with ${game.room.length} cards`, 'info');
                showMessage(`You entered a dungeon with ${game.room.length} cards!`, 'info');
            }
            
            updateUI();
            btnDrawRoom.disabled = true;
            btnAvoidRoom.disabled = true;
        }

        function avoidRoom() {
            if (game.lastActionWasAvoid) {
                showMessage('❌ You cannot avoid 2 dungeons in a row!', 'warning');
                playSound('error');
                return;
            }
            if (game.dungeon.length < 3) {
                showMessage('Not enough cards to avoid!', 'warning');
                return;
            }

            const discarded = game.dungeon.splice(0, 3);
            game.discardPile.push(...discarded);
            game.stats.roomsAvoided++;
            game.lastActionWasAvoid = true;
            
            playSound('avoid');
            addLog('Avoided dungeon, 3 cards discarded', 'info');
            showMessage('You avoided the dungeon! 3 cards discarded.', 'info');
            updateUI();

            if (game.dungeon.length === 0) {
                endGame('victory');
            }
        }

        // Undo System - Save game state before action
        function saveGameState() {
            game.lastGameState = {
                health: game.health,
                gold: game.gold,
                room: [...game.room],
                dungeon: [...game.dungeon],
                discardPile: [...game.discardPile],
                equippedWeapon: game.equippedWeapon ? {...game.equippedWeapon} : null,
                potionsUsed: game.potionsUsed,
                combo: game.combo,
                heldCard: game.heldCard ? {...game.heldCard} : null
            };
            game.undoAvailable = true;
        }
        
        function undoLastMove() {
            if (!game.undoAvailable || !game.lastGameState) {
                showMessage('❌ No move to undo!', 'warning');
                return;
            }
            
            // Restore game state
            game.health = game.lastGameState.health;
            game.gold = game.lastGameState.gold;
            game.room = [...game.lastGameState.room];
            game.dungeon = [...game.lastGameState.dungeon];
            game.discardPile = [...game.lastGameState.discardPile];
            game.equippedWeapon = game.lastGameState.equippedWeapon ? {...game.lastGameState.equippedWeapon} : null;
            game.potionsUsed = game.lastGameState.potionsUsed;
            game.combo = game.lastGameState.combo;
            game.heldCard = game.lastGameState.heldCard ? {...game.lastGameState.heldCard} : null;
            
            game.undoAvailable = false;
            game.lastGameState = null;
            
            showMessage('↩️ Move undone!', 'info');
            playSound('cardFlip');
            updateUI();
        }

        function handleCardClick(card, index) {
            if (game.gameOver) return;
            
            // Save state for undo (Easy/Normal only)
            if (game.difficulty === 'easy' || game.difficulty === 'normal') {
                saveGameState();
            }

            // Obliterate mode - remove ANY card permanently
            if (game.obliterateMode) {
                game.room.splice(index, 1);
                // Don't add to discard - it's obliterated!
                game.obliterateMode = false;
                showMessage('💥 Card OBLITERATED from existence!', 'success');
                playSound('special');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff6b6b', 40);
                
                // Track obliteration for achievement
                const saved = localStorage.getItem('scoundrel_lifetime_stats');
                let lifetimeStats = saved ? JSON.parse(saved) : {};
                lifetimeStats.cardsObliterated = (lifetimeStats.cardsObliterated || 0) + 1;
                localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
                
                updateUI();
                checkGameState();
                checkAchievements();
                return;
            }

            const cardType = getCardType(card);

            if (cardType === 'monster') handleMonster(card, index);
            else if (cardType === 'weapon') handleWeapon(card, index);
            else if (cardType === 'potion') handlePotion(card, index);
            else if (cardType === 'special') handleSpecial(card, index);
        }

        function getCardType(card) {
            if (card.special) return 'special';
            if (card.isBoss) return 'monster'; // Boss is a monster!
            if (card.suitName === 'clubs' || card.suitName === 'spades') return 'monster';
            if (card.suitName === 'diamonds') return 'weapon';
            if (card.suitName === 'hearts') return 'potion';
        }
        
        function handleSpecial(card, index) {
            game.room.splice(index, 1);
            game.discardPile.push(card);
            game.stats.specialsUsed++;
            
            playSound('special');
            addLog(`Used special: ${card.special.name}`, 'heal');
            card.special.effect();
            
            updateUI();
            checkGameState();
            checkAchievements();
        }

        function handleMonster(monster, index) {
            const powerBonus = getRelicBonus('power') + getRelicBonus('bigPower');
            const baseWeapon = game.equippedWeapon ? game.equippedWeapon.numValue : 0;
            
            // Add berserk bonus
            const berserkBonus = game.berserkStacks > 0 ? 5 : 0;
            
            // Add class ability bonuses
            let classBonus = 0;
            let rogueDoubleActive = false;
            let berserkerTripleActive = false;
            if (game.classAbilityActive && game.classAbilityCounter > 0) {
                if (game.playerClass === 'rogue') {
                    // Rogue: 2x damage on next attack
                    rogueDoubleActive = true;
                } else if (game.playerClass === 'dancer') {
                    // Dancer: +2 damage for next 2 monsters
                    classBonus = 2;
                } else if (game.playerClass === 'berserker' && game.rageStrikeActive) {
                    // Berserker: 3x damage on next attack
                    berserkerTripleActive = true;
                }
            }
            
            // Berserker Bloodlust passive
            let bloodlustBonus = 0;
            if (game.classData && game.classData.passive.bloodlust) {
                const hpPercent = (game.health / game.maxHealth) * 100;
                if (hpPercent <= 30) bloodlustBonus = 3;
                else if (hpPercent <= 50) bloodlustBonus = 2;
                else if (hpPercent <= 70) bloodlustBonus = 1;
            }
            
            const totalWeapon = baseWeapon + powerBonus + berserkBonus + classBonus + bloodlustBonus;
            let effectiveWeapon = game.doubleDamage ? totalWeapon * 2 : totalWeapon;
            
            // Apply Rogue Shadow Strike (2x damage)
            if (rogueDoubleActive) {
                effectiveWeapon *= 2;
            }
            
            // Apply Berserker Rage Strike (3x damage)
            if (berserkerTripleActive) {
                effectiveWeapon *= 3;
            }
            
            // Boss battle: reduce HP instead of instant kill
            if (monster.isBoss) {
                // SPECIAL CASE: Boss without weapon - boss attacks once and flees!
                if (!game.equippedWeapon) {
                    const bossDamage = monster.numValue;
                    game.health -= bossDamage;
                    game.stats.totalDamage += bossDamage;
                    
                    // Remove boss from room
                    game.room.splice(index, 1);
                    game.discardPile.push(monster);
                    
                    showMessage(`👹 ${monster.bossName || 'Boss'} attacked and fled! -${bossDamage} HP (NO REWARD!)`, 'danger');
                    playSound('damage');
                    screenShake();
                    createParticles(window.innerWidth / 2, window.innerWidth / 2, '#ff6b6b', 60);
                    
                    // Additional warning message
                    setTimeout(() => {
                        showMessage(`⚠️ No weapon equipped = No gold! Always bring a weapon to boss fights!`, 'warning');
                    }, 1500);
                    
                    // Break combo
                    game.combo = permanentUnlocks.comboMaster ? 1 : 0;
                    
                    updateUI();
                    checkGameState();
                    return;
                }
                
                monster.numValue -= effectiveWeapon;
                
                // Weapon durability for boss attacks
                if (game.equippedWeapon && game.equippedWeapon.durability < 999) {
                    game.equippedWeapon.durability--;
                    
                    if (game.equippedWeapon.durability <= 0) {
                        // Weapon broke!
                        showMessage(`💔 Your weapon broke!`, 'danger');
                        playSound('error');
                        game.discardPile.push(game.equippedWeapon);
                        game.equippedWeapon = null;
                        
                        // Check if room is now cleared after weapon broke
                        updateUI();
                        checkGameState();
                    }
                }
                
                if (monster.numValue <= 0) {
                    // Boss defeated!
                    game.stats.monstersSlain++;
                    game.room.splice(index, 1);
                    game.discardPile.push(monster);
                    
                    const bossGold = (Math.floor(Math.random() * 21) + 30);
                    earnGold(bossGold);
                    
                    // Victory messages based on boss
                    const victoryMessages = [
                        '⚔️ The Knight falls silent. The curse is broken...',
                        '💉 The Warden collapses. The path ahead is now open.',
                        '✨ The Shadow dissolves into nothingness. Light returns.',
                        '🌟 The Abyss Keeper is no more. You are the legend now.'
                    ];
                    
                    const victoryMsg = victoryMessages[Math.min(monster.bossNumber - 1, victoryMessages.length - 1)];
                    
                    showMessage(`👹 ${monster.bossName} DEFEATED! +${bossGold} GOLD!`, 'success');
                    setTimeout(() => showMessage(victoryMsg, 'success'), 800);
                    
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd700', 80);
                    playSound('special');
                    
                    // Increment combo for boss kill
                    game.combo++;
                    game.stats.maxCombo = Math.max(game.stats.maxCombo, game.combo);
                    
                    updateUI();
                    checkGameState();
                    checkAchievements();
                    return;
                } else {
                    // Boss still alive - show HP remaining
                    showMessage(`⚔️ Hit boss for ${effectiveWeapon} damage! Boss HP: ${monster.numValue}`, 'info');
                    playSound('attack');
                    updateUI();
                    // DON'T return - let player continue in same room with boss
                    return;
                }
            }
            
            let damage = Math.max(0, monster.numValue - effectiveWeapon);
            
            // Consume berserk stack
            if (game.berserkStacks > 0 && berserkBonus > 0) {
                game.berserkStacks--;
                showMessage(`🔥 Berserk +5 damage! (${game.berserkStacks} left)`, 'info');
            }
            
            playSound('attack');
            
            // Dodge
            if (game.dodgeActive && damage > 0) {
                game.dodgeActive = false;
                playSound('special');
                addLog(`Dodged attack from ${monster.value}${monster.suit}!`, 'heal');
                showMessage('🛡️ Dodged! No damage!', 'success');
            }
            // Priest Divine Blessing - 15% chance to dodge
            else if (damage > 0 && game.classData && game.classData.passive.divineBlessing && Math.random() < 0.15) {
                playSound('special');
                addLog(`Divine Blessing! Dodged attack from ${monster.value}${monster.suit}!`, 'heal');
                showMessage('🕊️ Divine Blessing! No damage!', 'success');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd700', 40);
                game.combo++;
                game.stats.maxCombo = Math.max(game.stats.maxCombo, game.combo);
            } 
            // Mirror Shield - Reflect damage
            else if (damage > 0 && game.mirrorShield > 0) {
                const reflected = Math.min(damage, game.mirrorShield);
                game.mirrorShield -= reflected;
                const remaining = damage - reflected;
                
                if (remaining > 0) {
                    game.health -= remaining;
                    game.stats.totalDamage += remaining;
                    showDamageNumber(remaining, 'damage');
                    playSound('damage');
                }
                
                showMessage(`🪞 Mirror reflected ${reflected} damage! Shield: ${game.mirrorShield}`, 'success');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#a8edea', 30);
                
                if (remaining <= 0) {
                    game.combo++;
                    game.stats.maxCombo = Math.max(game.stats.maxCombo, game.combo);
                } else {
                    game.combo = permanentUnlocks.comboMaster ? 1 : 0;
                }
            }
            // Relic Shield
            else if (damage > 0) {
                let shieldRelic = game.relics.find(r => r.id === 'tank' && !r.shieldUsed);
                if (shieldRelic) {
                    shieldRelic.shieldUsed = true;
                    const actualDamage = Math.max(0, damage - 1);
                    showMessage(`🛡️ Shield absorbed 1 damage! Received ${actualDamage}.`, 'success');
                    if (actualDamage > 0) {
                        game.health -= actualDamage;
                        game.stats.totalDamage += actualDamage;
                        showDamageNumber(actualDamage, 'damage');
                        playSound('damage');
                        game.combo = permanentUnlocks.comboMaster ? 1 : 0;
                    }
                } else {
                    // Normal Damage
                    game.health -= damage;
                    game.stats.totalDamage += damage;
                    game.combo = permanentUnlocks.comboMaster ? 1 : 0; // Reset combo
                    showDamageNumber(damage, 'damage');
                    playSound('damage');
                    screenShake();
                    addLog(`Took ${damage} damage from ${monster.value}${monster.suit}`, 'damage');
                    showMessage(`⚔️ Took ${damage} damage!`, 'danger');
                }
            } 
            // Perfect Kill
            else {
                game.combo++;
                game.stats.maxCombo = Math.max(game.stats.maxCombo, game.combo);
                if (game.combo >= 2) {
                    showCombo(game.combo);
                    playSound('combo');
                }
                
                // Lifesteal
                const lifesteal = game.relics.filter(r => r.id === 'vampire').length * 2;
                if (lifesteal > 0) {
                    game.health = Math.min(game.maxHealth, game.health + lifesteal);
                    showMessage(`🧛 +${lifesteal} HP from Vampirism!`, 'success');
                }
                
                addLog(`Defeated ${monster.value}${monster.suit}! (Combo: ${game.combo})`, 'info');
                showMessage(`⚔️ Perfect kill! ${game.combo}x COMBO!`, 'success');
            }
            
            if (game.doubleDamage) game.doubleDamage = false;
            
            // Weapon durability system
            if (game.equippedWeapon && game.equippedWeapon.durability < 999) {
                game.equippedWeapon.durability--;
                
                if (game.equippedWeapon.durability <= 0) {
                    // Weapon broke!
                    showMessage(`💔 Your weapon broke!`, 'danger');
                    playSound('error');
                    game.discardPile.push(game.equippedWeapon);
                    game.equippedWeapon = null;
                } else {
                    // Show remaining durability
                    const emoji = game.equippedWeapon.durability === 1 ? '⚠️' : '⚔️';
                    addLog(`${emoji} Weapon: ${game.equippedWeapon.durability}/${game.equippedWeapon.maxDurability} uses left`, 'info');
                }
            }
            
            // Decrement class ability counter
            if (game.classAbilityActive && game.classAbilityCounter > 0) {
                game.classAbilityCounter--;
                if (game.classAbilityCounter === 0) {
                    game.classAbilityActive = false;
                    game.rageStrikeActive = false; // Reset Berserker flag
                    showMessage('✨ Class ability buff expired!', 'info');
                }
            }
            
            // Rogue Shadow Strike: don't break combo
            const rogueComboSafe = (game.playerClass === 'rogue' && rogueDoubleActive);
            if (rogueComboSafe && damage > 0) {
                // Override combo break for Rogue ability
                game.combo++;
                game.stats.maxCombo = Math.max(game.stats.maxCombo, game.combo);
            }
            
            game.stats.monstersSlain++;
            game.room.splice(index, 1);
            game.discardPile.push(monster);
            
            // Monster gold (difficulty-based, with boss bonus)
            if (monster.isBoss) {
                // Boss gold rewards (much more generous!)
                const bossGoldByDifficulty = {
                    easy: Math.floor(Math.random() * 16) + 25,    // 25-40 gold
                    normal: Math.floor(Math.random() * 11) + 20,  // 20-30 gold
                    hard: Math.floor(Math.random() * 11) + 15,    // 15-25 gold
                    endless: Math.floor(Math.random() * 11) + 20  // 20-30 gold
                };
                const bossGold = bossGoldByDifficulty[game.difficulty] || 20;
                earnGold(bossGold);
                showMessage(`👹 BOSS DEFEATED! +${bossGold} gold!`, 'success');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#d4af37', 50);
            } else {
                // Normal monster gold
                const goldByDifficulty = {
                    easy: Math.floor(Math.random() * 4) + 3,    // 3-6 gold
                    normal: Math.floor(Math.random() * 3) + 2,  // 2-4 gold
                    hard: Math.floor(Math.random() * 2) + 1,    // 1-2 gold
                    endless: Math.floor(Math.random() * 3) + 2  // 2-4 gold
                };
                const baseGold = goldByDifficulty[game.difficulty] || 2;
                earnGold(baseGold);
            }
            
            // Revive
            if (game.health <= 0) {
                const phoenix = game.relics.find(r => r.id === 'phoenix' && !r.used);
                if (phoenix) {
                    phoenix.used = true;
                    game.health = 10;
                    showMessage('🐦 Phoenix Feather activated! Revived with 10 HP!', 'success');
                    playSound('special');
                    updateRelicsDisplay();
                }
            }
            
            updateRunningScore(); // Update score
            updateUI();
            checkGameState();
            checkAchievements();
        }

        function handleWeapon(weapon, index) {
            if (game.equippedWeapon) {
                game.discardPile.push(game.equippedWeapon);
            }
            
            // BREAKING COMBO: Equiping weapon breaks combo (strategic choice!)
            if (game.combo > 0) {
                const brokenCombo = game.combo;
                game.combo = permanentUnlocks.comboMaster ? 1 : 0;
                if (brokenCombo >= 3) {
                    showMessage(`💔 ${brokenCombo}x combo broken! (equipped weapon)`, 'warning');
                }
            }
            
            game.equippedWeapon = weapon;
            game.room.splice(index, 1);
            game.stats.weaponsEquipped++;
            
            // Set durability based on difficulty
            const durabilityMap = { easy: 3, normal: 2, hard: 1, endless: 2 };
            game.equippedWeapon.maxDurability = durabilityMap[game.difficulty] || 2;
            
            // Apply Knight bonus (+1 durability)
            if (game.classData && game.classData.passive.weaponDurabilityBonus) {
                game.equippedWeapon.maxDurability += game.classData.passive.weaponDurabilityBonus;
            }
            
            game.equippedWeapon.durability = game.equippedWeapon.maxDurability;
            
            // Check for Durable Weapons relic
            if (game.relics.some(r => r.id === 'durable_weapons')) {
                game.equippedWeapon.maxDurability = 999; // Infinite durability
                game.equippedWeapon.durability = 999;
            }
            
            playSound('equip');
            const powerBonus = getRelicBonus('power') + getRelicBonus('bigPower');
            addLog(`Equipped ${weapon.value}${weapon.suit}!`, 'equip');
            showMessage(`⚔️ Equipped weapon with value ${weapon.numValue + powerBonus}! (${game.equippedWeapon.durability}/${game.equippedWeapon.maxDurability} uses)`, 'success');
            
            updateUI();
            checkGameState();
            checkAchievements();
        }

        function handlePotion(potion, index) {
            // Check max potions per room (Dancer can use 2)
            const maxPotions = (game.classData && game.classData.passive.maxPotionsPerRoom) || 1;
            
            // Check if potion limit reached
            if (game.potionsUsed >= maxPotions) {
                showMessage(`Only ${maxPotions} potion(s) per dungeon! Discarding...`, 'warning');
                game.room.splice(index, 1);
                game.discardPile.push(potion);
                addLog(`Discarded potion ${potion.value}${potion.suit}`, 'info');
                updateUI();
                checkGameState();
                return;
            }

            // POTIONS DO NOT BREAK COMBO! (Strategic choice - different from weapons)
            // This allows for healing while maintaining combo chains
            
            const healBonus = getRelicBonus('healBonus');
            // Add class bonus (Dancer: +3 HP)
            const classHealBonus = (game.classData && game.classData.passive.potionHealBonus) || 0;
            const heal = potion.numValue + healBonus + classHealBonus;
            
            const oldHealth = game.health;
            game.health = Math.min(game.health + heal, game.maxHealth);
            const actualHeal = game.health - oldHealth;
            
            if (actualHeal > 0) {
                game.potionsUsed++;
                game.stats.potionsUsed++;
                game.stats.totalHealing += actualHeal;
                showDamageNumber(actualHeal, 'heal');
                playSound('heal');
                addLog(`Used ${potion.value}${potion.suit}, healed ${actualHeal} HP`, 'heal');
                showMessage(`💚 Healed ${actualHeal} HP!`, 'success');
            } else {
                 showMessage(`💚 HP is full!`, 'info');
            }
            
            game.room.splice(index, 1);
            game.discardPile.push(potion);
            updateUI();
            checkGameState();
            checkAchievements();
        }

        function checkGameState() {
            // Room Cleared?
            if (game.room.length === 0 && !game.gameOver) {
                game.potionsUsed = 0;
                game.stats.roomsCleared++;
                
                // Show combo message if active (combo now persists between rooms!)
                if (game.combo >= 3) {
                    showMessage(`🔥 ${game.combo}x COMBO! DUNGEON CLEAR! Keep it going!`, 'success');
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd93d', 40);
                }
                
                // COMBO NO LONGER RESETS - it persists between chambers!
                // (Only breaks when: taking damage, or equipping a weapon)
                game.undoAvailable = false; // Reset undo for new room
                game.lastGameState = null;
                game.eventTriggeredThisRoom = false; // Reset event flag for new room
                
                // Decrement class ability cooldown
                if (game.classAbilityCooldown > 0) {
                    game.classAbilityCooldown--;
                    if (game.classAbilityCooldown === 0) {
                        showMessage('✨ Class ability ready!', 'success');
                    }
                }
                
                playSound('roomClear');
                addLog(`Dungeon cleared! Total: ${game.stats.roomsCleared}`, 'info');
                
                // Victory particles!
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd700', 40);
                setTimeout(() => createParticles(window.innerWidth / 2 + 100, window.innerHeight / 2, '#6bcf7f', 30), 150);
                setTimeout(() => createParticles(window.innerWidth / 2 - 100, window.innerHeight / 2, '#4ecdc4', 30), 300);
                
                btnDrawRoom.disabled = false;
                btnAvoidRoom.disabled = game.lastActionWasAvoid;
                
                // Room Clear Relics (optimized single iteration)
                let goldPerRoom = 0;
                let passiveHeal = 0;
                
                game.relics.forEach(r => {
                    // Reset tank shield
                    if (r.id === 'tank') r.shieldUsed = false;
                    
                    // Gold bonuses
                    if (r.id === 'coin_pouch') goldPerRoom += 2;
                    if (r.id === 'greedy') goldPerRoom += 3;
                    
                    // Passive healing
                    if (r.id === 'bandage') passiveHeal += 0.5;
                    if (r.id === 'meditation') passiveHeal += 1;
                });
                
                // Rogue: +1 gold per room
                if (game.classData && game.classData.passive.bonusGoldPerRoom) {
                    goldPerRoom += game.classData.passive.bonusGoldPerRoom;
                }
                
                if (goldPerRoom > 0) earnGold(goldPerRoom);
                if (passiveHeal > 0) game.health = Math.min(game.maxHealth, game.health + Math.floor(passiveHeal));
                
                // Reset Mirror Shield at room clear (only for current dungeon)
                game.mirrorShield = 0;
                
                // Reset weapon durability at room clear (Master Smith relic)
                if (game.equippedWeapon && game.relics.some(r => r.id === 'master_smith')) {
                    game.equippedWeapon.durability = game.equippedWeapon.maxDurability;
                    showMessage('🔨 Master Smith repaired your weapon!', 'success');
                }
                
                // Room clear bonus (difficulty-based)
                const roomBonusByDifficulty = {
                    easy: Math.floor(Math.random() * 4) + 5,    // 5-8 gold
                    normal: Math.floor(Math.random() * 3) + 4,  // 4-6 gold
                    hard: Math.floor(Math.random() * 3) + 2,    // 2-4 gold
                    endless: Math.floor(Math.random() * 3) + 4  // 4-6 gold
                };
                const bonusGold = roomBonusByDifficulty[game.difficulty] || 3;
                earnGold(bonusGold);
                
                updateRunningScore(); // Update score
                updateUI(); // Update stats
                checkAchievements();

                // Event Chance (difficulty-based)
                // Only trigger if no event was triggered this room yet
                const eventChanceByDifficulty = {
                    easy: 0.40,      // 40% chance
                    normal: 0.30,    // 30% chance
                    hard: 0.20,      // 20% chance
                    endless: 0.25    // 25% chance
                };
                let eventChance = eventChanceByDifficulty[game.difficulty] || 0.30;
                
                // Dancer: +15% event chance (luck passive)
                if (game.classData && game.classData.passive.eventChanceBonus) {
                    eventChance += (game.classData.passive.eventChanceBonus / 100);
                }
                
                setTimeout(() => {
                    if (!game.gameOver && !game.eventTriggeredThisRoom && Math.random() < eventChance) {
                        triggerRandomEvent();
                    }
                }, 800);
            }

            if (game.health <= 0) {
                endGame('death');
            }

            // Don't end game on victory in endless mode
            if (game.dungeon.length === 0 && game.room.length === 0 && game.difficulty !== 'endless') {
                endGame('victory');
            }
        }

        function endGame(reason, gaveUp = false) {
            if (game.gameStartTime === 0 || game.gameOver) return;
            
            game.gameOver = true;
            if (game.gameTimerInterval) clearInterval(game.gameTimerInterval); // Stop clock
            
            // Switch music based on outcome
            if (reason === 'victory') {
                music.switchContext('victory');
            } else {
                music.switchContext('defeat');
            }
            
            const gameTime = Math.floor((Date.now() - game.gameStartTime) / 1000);
            let title, message, score, scoreLabel, isVictory = false;

            if (reason === 'death') {
                title = '💀 DEFEAT';
                const deathNarratives = [
                    'The darkness claimed another soul...',
                    'Your tale ends here, in the depths.',
                    'The dungeon has taken its toll.',
                    'Another scoundrel falls to the abyss.'
                ];
                const randomDeath = deathNarratives[Math.floor(Math.random() * deathNarratives.length)];
                message = gaveUp ? 'You gave up the run.' : randomDeath;
                score = gaveUp ? 0 : calculateDeathScore(); // Score is 0 if gave up
                scoreLabel = 'Final Score:';
                playSound('defeat');
            } else if (reason === 'victory') {
                isVictory = true;
                title = '🏆 VICTORY';
                const victoryNarratives = [
                    'Against all odds, you emerge victorious!',
                    'The dungeon is conquered. You are the legend.',
                    'Light pierces through the darkness. You survived.',
                    'Your name will echo through these halls forever.'
                ];
                const randomVictory = victoryNarratives[Math.floor(Math.random() * victoryNarratives.length)];
                message = randomVictory;
                score = calculateWinScore();
                scoreLabel = 'Final Score:';
                playSound('victory');
                
                // Epic victory particle explosion!
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const x = window.innerWidth / 2 + (Math.random() - 0.5) * 400;
                        const y = window.innerHeight / 2 + (Math.random() - 0.5) * 300;
                        const colors = ['#ffd700', '#6bcf7f', '#4ecdc4', '#ff6b6b', '#ffd93d'];
                        createParticles(x, y, colors[i % colors.length], 50);
                    }, i * 200);
                }
                
                game.stats.gamesWon = 1;
                permanentStats.gamesWon = (permanentStats.gamesWon || 0) + 1;
                if (game.difficulty === 'hard') {
                    game.stats.hardWins = 1;
                    permanentStats.hardWins = (permanentStats.hardWins || 0) + 1;
                }
                if (permanentStats.fastestWin === 0 || gameTime < permanentStats.fastestWin) {
                    permanentStats.fastestWin = gameTime;
                }
                setTimeout(() => showDamageNumber(score, 'score'), 500);
            }
            
            // Update permanent stats
            updateLifetimeStats(); // Save stats
            checkAchievements(); // Check one last time
            savePermanentStats(); // Save progress
            saveUnlocks(); // Save unlocks

            showGameOver(title, message, score, scoreLabel, isVictory, gameTime);
        }
        
        // Ported Score Functions
        function calculateWinScore() {
            const timeInSeconds = Math.max(1, Math.floor((Date.now() - game.gameStartTime) / 1000));
            
            let difficultyMultiplier = 1;
            if (game.difficulty === 'normal') difficultyMultiplier = 1.5;
            if (game.difficulty === 'hard') difficultyMultiplier = 2.5;

            const baseScore = 1000; // Win bonus
            const healthBonus = game.health * 20;
            const goldBonus = game.totalGoldEarned * 5;
            const comboBonus = game.stats.maxCombo * 10;
            const monsterBonus = game.stats.monstersSlain * 2;
            
            // NEW BONUSES/PENALTIES
            const speedrunBonus = timeInSeconds < 300 ? 500 : (timeInSeconds < 600 ? 250 : 0); // <5min: +500, <10min: +250
            const perfectRunBonus = game.stats.totalDamage === 0 ? 1000 : 0; // No damage taken
            const shopPenalty = (game.stats.shopsVisited || 0) * 50; // -50 per shop visit
            
            const timePenalty = timeInSeconds * 2;
            
            const totalScore = Math.floor(
                ((baseScore + healthBonus + goldBonus + comboBonus + monsterBonus + speedrunBonus + perfectRunBonus) - timePenalty - shopPenalty) * difficultyMultiplier
            );
            
            return Math.max(1, totalScore); // Score must be at least 1
        }
        
        function calculateDeathScore() {
            // Original logic from Letterboard
            const monstersInDiscard = game.discardPile.filter(c => 
                c.suitName === 'clubs' || c.suitName === 'spades'
            );
            const totalValue = monstersInDiscard.reduce((sum, card) => sum + card.numValue, 0);
            return game.health - totalValue; // Will be a negative number
        }

        function showGameOver(title, message, score, scoreLabel, isVictory, gameTime) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay active game-over'; // Use modal class
            
            const submitButtonHTML = isVictory ? 
                `<button class="btn btn-success" id="btnSubmitScore">🚀 Submit Score</button>` : '';
            
            // Score Breakdown
            let scoreBreakdownHTML = '';
            if (isVictory) {
                const timeInSeconds = Math.max(1, gameTime);
                let difficultyMultiplier = 1;
                if (game.difficulty === 'normal') difficultyMultiplier = 1.5;
                if (game.difficulty === 'hard') difficultyMultiplier = 2.5;

                const baseScore = 1000;
                const healthBonus = game.health * 20;
                const goldBonus = game.totalGoldEarned * 5;
                const comboBonus = game.stats.maxCombo * 10;
                const monsterBonus = game.stats.monstersSlain * 2;
                
                // NEW BONUSES/PENALTIES
                const speedrunBonus = timeInSeconds < 300 ? 500 : (timeInSeconds < 600 ? 250 : 0);
                const perfectRunBonus = game.stats.totalDamage === 0 ? 1000 : 0;
                const shopPenalty = (game.stats.shopsVisited || 0) * 50;
                
                const timePenalty = timeInSeconds * 2;
                const subTotal = (baseScore + healthBonus + goldBonus + comboBonus + monsterBonus + speedrunBonus + perfectRunBonus) - timePenalty - shopPenalty;

                let bonusesHTML = '';
                if (speedrunBonus > 0) bonusesHTML += `<p style="color: #6bcf7f;">⚡ Speedrun Bonus (${Math.floor(timeInSeconds/60)}m${timeInSeconds%60}s): +${speedrunBonus}</p>`;
                if (perfectRunBonus > 0) bonusesHTML += `<p style="color: #ffd700;">🏆 Perfect Run (No Damage): +${perfectRunBonus}</p>`;
                if (shopPenalty > 0) bonusesHTML += `<p style="color: #ff6b6b;">🏺 Shop Penalty (${game.stats.shopsVisited || 0} visits): -${shopPenalty}</p>`;

                scoreBreakdownHTML = `
                    <div class="game-over-stats" style="background: rgba(0,0,0,0.4); border: 1px solid #ffd700; margin-bottom: 15px; text-align: left;">
                        <p style="color: #ffd700; font-weight: bold; font-size: 1.1em; margin-bottom: 10px;">📊 Score Breakdown:</p>
                        <p>🎯 Win Bonus: +1000</p>
                        <p>❤️ Health Bonus (${game.health} HP): +${healthBonus}</p>
                        <p>💰 Gold Bonus (${game.totalGoldEarned} 🪙): +${goldBonus}</p>
                        <p>🔥 Combo Bonus (${game.stats.maxCombo}x): +${comboBonus}</p>
                        <p>⚔️ Monster Bonus (${game.stats.monstersSlain}): +${monsterBonus}</p>
                        ${bonusesHTML}
                        <p style="color: #ff6b6b;">⏱️ Time Penalty (${Math.floor(timeInSeconds/60)}m${timeInSeconds%60}s): -${timePenalty}</p>
                        <hr style="border-color: rgba(255,255,255,0.2); margin: 5px 0;">
                        <p>Subtotal: ${subTotal} x ${difficultyMultiplier}x (${game.difficulty.toUpperCase()}) = <strong style="color: #ffd700; font-size: 1.2em;">${score}</strong></p>
                    </div>
                `;
            }
            
            overlay.innerHTML = `
                <div class="modal-content" style="max-width: 600px;">
                    <h1>${title}</h1>
                    <p>${message}</p>
                    ${scoreBreakdownHTML}
                    <p class="game-over-score">${scoreLabel} ${score}</p>
                    <div class="game-over-stats">
                        <p>📊 <strong>Run Statistics:</strong></p>
                        <p>⏱️ Time: ${Math.floor(gameTime/60)}m ${(gameTime%60).toString().padStart(2, '0')}s</p>
                        <p>⚔️ Monsters Slain: ${game.stats.monstersSlain}</p>
                        <p>🗡️ Weapons Used: ${game.stats.weaponsEquipped}</p>
                        <p>💔 Damage Taken: ${game.stats.totalDamage}</p>
                        <p>💚 Healing Received: ${game.stats.totalHealing}</p>
                        <p>🏰 Rooms Cleared: ${game.stats.roomsCleared}</p>
                        <p>🔥 Max Combo: ${game.stats.maxCombo}x</p>
                        <p>🪙 Gold Earned: ${game.totalGoldEarned}</p>
                    </div>
                    <div class="game-over-controls">
                        <button class="btn btn-primary" id="btnPlayAgain">🔄 Play Again</button>
                        ${submitButtonHTML}
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            document.getElementById('btnPlayAgain').onclick = () => {
                overlay.remove();
                btnStartGameModal.disabled = false; // Reset button
                music.switchContext('menu'); // Return to menu music
                showWelcomeScreen(); // Back to welcome screen
            };
            
            if (isVictory) {
                document.getElementById('btnSubmitScore').addEventListener('click', async (e) => {
                    const btn = e.target;
                    btn.disabled = true;
                    btn.textContent = 'Submitting...';
                    
                    try {
                        await submitScoreToLeaderboard(score, gameTime);
                        btn.textContent = '✅ Submitted!';
                    } catch (err) {
                        btn.textContent = 'Submission Failed';
                        btn.disabled = false;
                        console.error("Score submission error:", err);
                    }
                });
            }
        }

        function showMessage(text, type) {
            const msgEl = document.createElement('div');
            msgEl.className = `message ${type}`;
            msgEl.textContent = text;
            messageArea.appendChild(msgEl);
            
            // Adjust duration based on importance
            const duration = type === 'danger' ? 4000 : (type === 'success' ? 2500 : 3000);
            
            setTimeout(() => {
                msgEl.style.opacity = '0';
                setTimeout(() => msgEl.remove(), 500);
            }, duration);
        }

        // ============================================
        // UI UPDATE
        // ============================================
        
        function updateRunningScore() {
            game.score = (game.stats.monstersSlain * 10) + (game.stats.roomsCleared * 50) + game.totalGoldEarned;
            mainScoreValue.textContent = game.score;
        }
        
        function updateUI() {
            // HP Critical Warning
            if (game.health > 0 && game.health <= 5) {
                document.body.classList.add('hp-critical');
                // Show warning message first time
                if (!game.criticalWarningShown) {
                    showMessage('⚠️ CRITICAL HP! Find healing soon!', 'danger');
                    game.criticalWarningShown = true;
                }
            } else {
                document.body.classList.remove('hp-critical');
                game.criticalWarningShown = false;
            }
            
            // Top Bar
            healthEl.textContent = `${game.health} / ${game.maxHealth}`;
            goldEl.textContent = game.gold;
            dungeonCountEl.textContent = game.dungeon.length;
            statRoomsEl.textContent = game.stats.roomsCleared;
            mainScoreValue.textContent = game.score; // Update main score
            
            // Show active class buff indicator
            if (game.classAbilityActive && game.classAbilityCounter > 0) {
                const buffIndicator = document.createElement('div');
                buffIndicator.style.cssText = 'position: fixed; top: 120px; right: 20px; background: rgba(255, 215, 0, 0.9); color: #000; padding: 10px 15px; border-radius: 8px; font-weight: bold; z-index: 100; animation: pulse 1s infinite;';
                buffIndicator.id = 'classBuffIndicator';
                
                if (game.playerClass === 'rogue') {
                    buffIndicator.innerHTML = `🔪 SHADOW STRIKE<br><small>2x damage, combo safe!</small>`;
                } else if (game.playerClass === 'dancer') {
                    buffIndicator.innerHTML = `💃 HEALING DANCE<br><small>+2 dmg (${game.classAbilityCounter} left)</small>`;
                }
                
                // Remove old indicator
                const oldIndicator = document.getElementById('classBuffIndicator');
                if (oldIndicator) oldIndicator.remove();
                
                document.body.appendChild(buffIndicator);
            } else {
                const oldIndicator = document.getElementById('classBuffIndicator');
                if (oldIndicator) oldIndicator.remove();
            }
            
            // Undo button visibility (Easy/Normal only)
            const btnUndo = document.getElementById('btnUndo');
            if (btnUndo && (game.difficulty === 'easy' || game.difficulty === 'normal')) {
                btnUndo.style.display = 'inline-block';
                btnUndo.disabled = !game.undoAvailable;
            } else if (btnUndo) {
                btnUndo.style.display = 'none';
            }

            // Center Stage - Weapon
            equippedWeaponEl.innerHTML = '';
            if (game.equippedWeapon) {
                const cardEl = createCardElement(game.equippedWeapon);
                cardEl.classList.add('equipped');
                
                const powerBonus = getRelicBonus('power') + getRelicBonus('bigPower');
                if (powerBonus > 0 || game.doubleDamage) {
                    const badge = document.createElement('div');
                    badge.style.cssText = 'position:absolute;top:5px;right:5px;background:#ffd93d;color:#000;padding:3px 8px;border-radius:10px;font-size:0.8em;font-weight:bold;';
                    badge.textContent = game.doubleDamage ? `2x (${game.equippedWeapon.numValue + powerBonus})` : `+${powerBonus}`;
                    cardEl.appendChild(badge);
                }
                
                // Durability indicator
                if (game.equippedWeapon.durability < 999) {
                    const durabilityBar = document.createElement('div');
                    durabilityBar.style.cssText = 'position:absolute;bottom:5px;left:5px;right:5px;height:8px;background:rgba(0,0,0,0.5);border-radius:4px;overflow:hidden;';
                    
                    const durabilityFill = document.createElement('div');
                    const percentage = (game.equippedWeapon.durability / game.equippedWeapon.maxDurability) * 100;
                    let fillColor = '#6bcf7f'; // Green (full)
                    if (percentage <= 33) fillColor = '#ff6b6b'; // Red (low)
                    else if (percentage <= 66) fillColor = '#ffd93d'; // Yellow (medium)
                    
                    durabilityFill.style.cssText = `height:100%;width:${percentage}%;background:${fillColor};transition:all 0.3s ease;`;
                    durabilityBar.appendChild(durabilityFill);
                    
                    const durabilityText = document.createElement('div');
                    const durabilityIcon = game.equippedWeapon.durability === 1 ? '⚠️' : '⚔️';
                    durabilityText.style.cssText = 'position:absolute;bottom:12px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:white;padding:2px 6px;border-radius:8px;font-size:0.7em;font-weight:bold;white-space:nowrap;';
                    durabilityText.textContent = `${durabilityIcon} ${game.equippedWeapon.durability}/${game.equippedWeapon.maxDurability}`;
                    
                    cardEl.appendChild(durabilityBar);
                    cardEl.appendChild(durabilityText);
                }
                
                equippedWeaponEl.appendChild(cardEl);
            } else {
                equippedWeaponEl.innerHTML = '<div class="empty-slot">No Weapon</div>';
            }
            
            // Right Bar - Hold (supports multiple cards for Rogue)
            holdAreaContainer.innerHTML = '';
            const maxHold = (game.classData && game.classData.passive.maxHoldCards) || 1;
            
            if (game.heldCard) {
                // Handle both single card and array of cards
                const heldCards = Array.isArray(game.heldCard) ? game.heldCard : [game.heldCard];
                
                heldCards.forEach((card, idx) => {
                    const cardEl = createCardElement(card);
                    cardEl.classList.add('held');
                    cardEl.style.marginBottom = '10px';
                    cardEl.onclick = () => {
                        // Use specific held card
                        if (Array.isArray(game.heldCard)) {
                            const selectedCard = game.heldCard.splice(idx, 1)[0];
                            if (game.heldCard.length === 0) game.heldCard = null;
                            game.room.unshift(selectedCard);
                            updateUI();
                            setTimeout(() => {
                                const firstCardEl = bottomBar.querySelector('.card');
                                if (firstCardEl) firstCardEl.click();
                            }, 100);
                        } else {
                            useHeldCard();
                        }
                    };
                    holdAreaContainer.appendChild(cardEl);
                });
                
                // Show count if multiple slots
                if (maxHold > 1) {
                    const countEl = document.createElement('div');
                    countEl.style.cssText = 'text-align:center;color:#ffd93d;font-size:0.9em;margin-top:5px;';
                    countEl.textContent = `${heldCards.length}/${maxHold} held`;
                    holdAreaContainer.appendChild(countEl);
                }
            } else {
                const emptyText = maxHold > 1 ? `Right-click to hold (0/${maxHold})` : 'Right-click to hold';
                holdAreaContainer.innerHTML = `<div class="empty-slot" style="font-size: 0.8em;">${emptyText}</div>`;
            }
            
            // Right Bar - Discard
            discardPilePreview.innerHTML = '';
            const lastFive = game.discardPile.slice(-5).reverse();
            if (lastFive.length > 0) {
                lastFive.forEach(card => {
                    discardPilePreview.appendChild(createMiniCardElement(card));
                });
            } else {
                discardPilePreview.innerHTML = '<span style="font-size: 0.8em; opacity: 0.5;">Empty</span>';
            }

            // Bottom Bar - Room
            bottomBar.innerHTML = '';
            if (game.room.length > 0) {
                game.room.forEach((card, index) => {
                    const cardEl = createCardElement(card);
                    
                    const tooltip = generateTooltip(card);
                    if (tooltip) {
                        const tooltipEl = document.createElement('div');
                        tooltipEl.className = 'card-tooltip';
                        tooltipEl.innerHTML = tooltip;
                        cardEl.appendChild(tooltipEl);
                    }
                    
                    // Add preview
                    const type = getCardType(card);
                    const powerBonus = getRelicBonus('power') + getRelicBonus('bigPower');
                    const baseWeaponVal = game.equippedWeapon ? game.equippedWeapon.numValue : 0;
                    const effectiveWeapon = game.doubleDamage ? (baseWeaponVal + powerBonus) * 2 : (baseWeaponVal + powerBonus);

                    if (type === 'monster') {
                        const damage = card.numValue - effectiveWeapon;
                        if (game.dodgeActive || damage <= 0) cardEl.classList.add('preview-safe');
                        else cardEl.classList.add('preview-danger');
                    } else if (type === 'weapon') {
                        const current = baseWeaponVal + powerBonus;
                        const cardValue = card.numValue + powerBonus;
                        if (cardValue > current) cardEl.classList.add('preview-safe');
                        else if (cardValue < current) cardEl.classList.add('preview-danger');
                        else cardEl.classList.add('preview-neutral');
                    } else if (type === 'potion') {
                        const maxPotions = (game.classData && game.classData.passive.maxPotionsPerRoom) || 1;
                        if (game.potionsUsed >= maxPotions) cardEl.classList.add('preview-danger');
                        else cardEl.classList.add('preview-safe');
                    } else if (type === 'special') {
                        cardEl.classList.add('preview-safe');
                    }
                    
                    // Click events
                    cardEl.onclick = (e) => {
                        e.stopPropagation();
                        playSound('cardFlip');
                        handleCardClick(card, index);
                    };
                    cardEl.oncontextmenu = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        holdCard(card, index);
                    };
                    
                    bottomBar.appendChild(cardEl);
                });
            } else if (!game.gameOver) {
                 bottomBar.innerHTML = '<div class="empty-slot">Dungeon Empty. Use controls above.</div>';
            }
            
            // Update class ability UI
            if (game.classData) {
                updateAbilityUI();
            }
        }

        function createCardElement(card) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            const type = getCardType(card);
            cardEl.classList.add(type);
            
            // Boss special styling
            if (card.isBoss) {
                cardEl.classList.add('boss');
                cardEl.style.boxShadow = '0 0 30px rgba(255, 107, 107, 0.8)';
                cardEl.style.borderColor = '#ff6b6b';
                cardEl.style.animation = 'bossPulse 1.5s infinite';
            }

            if (type === 'special') {
                cardEl.innerHTML = `
                    <div class="card-value">${card.special.name.split(' ')[0]}</div>
                    <div style="font-size: 0.8em; padding: 0 5px;">${card.special.name.split(' ').slice(1).join(' ')}</div>
                    <div class="card-suit">✨</div>
                `;
            } else if (card.isBoss) {
                // Calculate HP percentage for bar
                const hpPercent = card.maxHP ? (card.numValue / card.maxHP) * 100 : 100;
                const hpColor = hpPercent > 66 ? '#6bcf7f' : (hpPercent > 33 ? '#ffd93d' : '#ff6b6b');
                
                cardEl.innerHTML = `
                    <div class="card-value" style="font-size: 2em;">👹</div>
                    <div style="font-size: 0.9em; color: #ff6b6b; font-weight: bold;">BOSS</div>
                    <div class="card-suit" style="font-size: 1.2em; color: #ff6b6b;">${card.numValue} HP</div>
                    <div style="width: 90%; height: 8px; background: rgba(255,255,255,0.2); border-radius: 4px; margin: 5px auto 0; overflow: hidden;">
                        <div style="width: ${hpPercent}%; height: 100%; background: ${hpColor}; transition: all 0.3s ease; border-radius: 4px;"></div>
                    </div>
                `;
            } else {
                cardEl.innerHTML = `
                    <div class="card-value">${card.value}</div>
                    <div class="card-suit">${card.suit}</div>
                `;
            }
            return cardEl;
        }
        
        function createMiniCardElement(card) {
            const cardEl = document.createElement('div');
            cardEl.className = 'mini-card';
            const type = getCardType(card);
            cardEl.classList.add(type);

            if (type === 'special') {
                cardEl.innerHTML = `<span class="card-value">✨</span>`;
            } else {
                cardEl.innerHTML = `
                    <span class="card-value">${card.value}</span>
                    <span class="card-suit">${card.suit}</span>
                `;
            }
            return cardEl;
        }

        // ============================================
        // RELICS, SHOP, EVENTS (Ported Logic)
        // ============================================
        const RELICS = [
            // === COMUM (25) - Efeitos básicos e úteis ===
            { id: 'small_shield', name: '🛡️ Small Shield', description: '+3 maximum health', rarity: 'common', effect: 'smallHealth' },
            { id: 'bronze_ring', name: '💍 Bronze Ring', description: '+1 damage to all weapons', rarity: 'common', effect: 'smallPower' },
            { id: 'heal_charm', name: '💚 Healing Charm', description: 'Potions heal +1 HP', rarity: 'common', effect: 'smallHealBonus' },
            { id: 'coin_pouch', name: '💰 Coin Pouch', description: 'Gain 2 gold per room cleared', rarity: 'common', effect: 'smallGoldPerRoom' },
            { id: 'lucky_penny', name: '🪙 Lucky Penny', description: '+20% gold from all sources', rarity: 'common', effect: 'smallGoldBonus' },
            { id: 'leather_boots', name: '👢 Leather Boots', description: 'Avoid costs 2 cards instead of 3', rarity: 'common', effect: 'betterAvoid' },
            { id: 'bandage', name: '🩹 Bandage', description: 'Heal 0.5 HP per room cleared', rarity: 'common', effect: 'tinyRegen' },
            { id: 'weak_thorns', name: '🌿 Weak Thorns', description: 'Reflect 1 damage to attackers', rarity: 'common', effect: 'weakThorns' },
            { id: 'compass', name: '🧭 Compass', description: '10% more events', rarity: 'common', effect: 'moreEvents' },
            { id: 'dice', name: '🎲 Lucky Dice', description: 'Shop items 5% cheaper', rarity: 'common', effect: 'tinyDiscount' },
            { id: 'feather', name: '🪶 Light Feather', description: 'Hold 2 cards instead of 1', rarity: 'common', effect: 'extraHold' },
            { id: 'candle', name: '🕯️ Candle', description: 'See 1 extra card in deck', rarity: 'common', effect: 'peek' },
            { id: 'rope', name: '🪢 Rope', description: 'Start with 1 extra HP', rarity: 'common', effect: 'tinyHealth' },
            { id: 'stone', name: '🪨 Stone', description: 'Reduce first damage by 1', rarity: 'common', effect: 'firstShield' },
            { id: 'herb', name: '🌱 Herb', description: 'Potions usable twice per dungeon', rarity: 'common', effect: 'doublePot' },
            { id: 'map', name: '🗺️ Map', description: 'See next 3 cards', rarity: 'common', effect: 'cardPreview' },
            { id: 'gloves', name: '🧤 Gloves', description: 'Weapons last 1 extra use', rarity: 'common', effect: 'extraDurability' },
            { id: 'book', name: '📖 Old Book', description: 'Special cards +10% more common', rarity: 'common', effect: 'moreSpecials' },
            { id: 'bell', name: '🔔 Bell', description: 'Gold visible on cards', rarity: 'common', effect: 'goldSight' },
            { id: 'key', name: '🗝️ Old Key', description: 'Unlock 1 free shop item', rarity: 'common', effect: 'freeItem' },
            { id: 'mirror_shard', name: '🪞 Mirror Shard', description: 'Reflect 2 damage once per room', rarity: 'common', effect: 'weakReflect' },
            { id: 'charm', name: '✨ Charm', description: 'Start with 10 extra gold', rarity: 'common', effect: 'startGold' },
            { id: 'tooth', name: '🦷 Monster Tooth', description: 'Monsters give +1 gold', rarity: 'common', effect: 'monsterGold' },
            { id: 'clover', name: '☘️ Four Leaf Clover', description: 'Avoid can be used 2x in row', rarity: 'common', effect: 'doubleAvoid' },
            { id: 'lantern', name: '🏮 Lantern', description: 'Events give +2 gold', rarity: 'common', effect: 'eventGold' },
            
            // === INCOMUM (15) - Efeitos moderados ===
            { id: 'silver_shield', name: '🛡️ Silver Shield', description: '+5 maximum health', rarity: 'uncommon', effect: 'maxHealth' },
            { id: 'silver_ring', name: '💍 Silver Ring', description: '+2 damage to all weapons', rarity: 'uncommon', effect: 'power' },
            { id: 'healer', name: '💚 Healing Amulet', description: 'Potions heal +2 HP', rarity: 'uncommon', effect: 'healBonus' },
            { id: 'greedy', name: '💰 Golden Idol', description: 'Gain 3 gold per room cleared', rarity: 'uncommon', effect: 'goldPerRoom' },
            { id: 'vampire', name: '🧛 Vampiric Fang', description: 'Heal 2 HP when defeating monsters', rarity: 'uncommon', effect: 'lifesteal' },
            { id: 'meditation', name: '🧘 Meditation Stone', description: 'Heal 1 HP per room', rarity: 'uncommon', effect: 'passive_heal' },
            { id: 'armor', name: '🦾 Iron Armor', description: 'Reduce all damage by 1', rarity: 'uncommon', effect: 'damageReduction' },
            { id: 'boots', name: '👟 Speed Boots', description: 'Draw 1 extra card per dungeon', rarity: 'uncommon', effect: 'extraDraw' },
            { id: 'gauntlet', name: '🥊 Power Gauntlet', description: 'First attack each room +3 damage', rarity: 'uncommon', effect: 'firstStrike' },
            { id: 'necklace', name: '📿 Holy Necklace', description: 'Events heal 2 HP', rarity: 'uncommon', effect: 'eventHeal' },
            { id: 'crystal', name: '💎 Crystal', description: 'Shop items 15% cheaper', rarity: 'uncommon', effect: 'discount' },
            { id: 'hourglass', name: '⏳ Hourglass', description: 'Berserk lasts 1 extra turn', rarity: 'uncommon', effect: 'longerBerserk' },
            { id: 'magnet', name: '🧲 Magnet', description: '+40% gold from all sources', rarity: 'uncommon', effect: 'goldBonus' },
            { id: 'ring_fire', name: '🔥 Fire Ring', description: 'Combo damage +1 per stack', rarity: 'uncommon', effect: 'comboBoost' },
            { id: 'cloak', name: '🧥 Cloak', description: 'First damage each room is 0', rarity: 'uncommon', effect: 'firstDodge' },
            { id: 'berserker', name: '💢 Berserker Ring', description: '+2 damage to all weapons', rarity: 'uncommon', effect: 'power' },
            
            // === RARA (8) - Efeitos poderosos ===
            { id: 'gold_shield', name: '🛡️ Golden Shield', description: '+10 maximum health', rarity: 'rare', effect: 'bigHealth' },
            { id: 'blade', name: '🗡️ Dancing Blade', description: '+3 weapon damage', rarity: 'rare', effect: 'bigPower' },
            { id: 'lucky', name: '🍀 Lucky Charm', description: '+60% gold from all sources', rarity: 'rare', effect: 'bigGoldBonus' },
            { id: 'warrior', name: '⚡ Thunder Gauntlet', description: '20% chance to deal double damage', rarity: 'rare', effect: 'criticalChance' },
            { id: 'tank', name: '🏰 Fortress Armor', description: 'Start each room with 1 HP shield', rarity: 'rare', effect: 'roomShield' },
            { id: 'master_smith', name: '🔨 Master Smith', description: 'Repairs weapon at end of each room', rarity: 'rare', effect: 'auto_repair' },
            { id: 'crown', name: '👑 Crown', description: 'Double all stat bonuses from relics', rarity: 'rare', effect: 'doubleRelics' },
            { id: 'orb', name: '🔮 Magic Orb', description: 'Special cards appear 2x more', rarity: 'rare', effect: 'manySpecials' },
            
            // === LENDÁRIA (2) - Game-changing ===
            { id: 'phoenix', name: '🐦 Phoenix Feather', description: 'Revive once with 10 HP', rarity: 'legendary', effect: 'revive', oneTime: true, used: false },
            { id: 'durable_weapons', name: '🛠️ Eternal Forge', description: 'Weapons never break', rarity: 'legendary', effect: 'infinite_durability' }
        ];

        const EVENTS = [
            { id: 'shrine', title: '🔮 Mysterious Shrine', text: 'You find a glowing shrine. An ancient voice offers you a choice...',
                choices: [
                    { text: '❤️ Sacrifice 5 HP for +2 weapon damage permanently (Gain Berserker Ring)',
                        effect: () => {
                            if (game.health > 5) { game.health -= 5; game.relics.push({...RELICS.find(r => r.id === 'berserker')}); showMessage('Gained Berserker Ring!', 'success'); updateRelicsDisplay(); } 
                            else { showMessage('Not enough HP!', 'danger'); }
                        }},
                    { text: '💰 Offer 20 gold for +5 max HP',
                        effect: () => {
                            if (game.gold >= 20) { game.gold -= 20; game.maxHealth += 5; game.health += 5; showMessage('+5 Max HP!', 'success'); } 
                            else { showMessage('Not enough gold!', 'danger'); }
                        }},
                    { text: '🚪 Leave quietly', effect: () => { showMessage('You leave the shrine untouched.', 'info'); }}
                ]},
            { id: 'merchant', title: '🎒 Traveling Merchant', text: 'A friendly merchant offers you a deal!',
                choices: [
                    { text: '💊 Buy healing potion for 15 gold (heal 8 HP)',
                        effect: () => {
                            if (game.gold >= 15) { game.gold -= 15; game.health = Math.min(game.maxHealth, game.health + 8); showMessage('Healed 8 HP!', 'success'); } 
                            else { showMessage('Not enough gold!', 'danger'); }
                        }},
                    { text: '🔮 Buy random relic for 30 gold',
                        effect: () => {
                            if (game.gold >= 30) { game.gold -= 30; giveRandomRelic(); } 
                            else { showMessage('Not enough gold!', 'danger'); }
                        }},
                    { text: '👋 Say goodbye', effect: () => { showMessage('Maybe next time!', 'info'); }}
                ]},
            { id: 'fountain', title: '💧 Whispering Fountain', text: 'You find a shimmering fountain. The water looks pure.',
                choices: [
                    { text: 'Drink (Heal 5 HP)', effect: () => { 
                        const heal = Math.min(5, game.maxHealth - game.health);
                        game.health += heal;
                        showMessage(`💧 You feel refreshed! +${heal} HP`, 'success');
                        updateUI();
                    }},
                    { text: 'Ignore', effect: () => { showMessage('You move on.', 'info'); }}
                ]},
            { id: 'gambler', title: '🎲 Shady Gambler', text: 'A figure offers a game. "Bet 10 Gold. Win 25 or lose it all."',
                choices: [
                    { text: 'Bet (Requires 10 Gold)', effect: () => { 
                        if (game.gold < 10) { showMessage('🎲 "You don\'t have enough gold!" he scoffs.', 'warning'); return; }
                        game.gold -= 10;
                        if (Math.random() < 0.4) { showMessage('🎲 You won! +25 Gold!', 'success'); earnGold(25); } 
                        else { showMessage('🎲 You lost! -10 Gold!', 'danger'); }
                        updateUI();
                    }},
                    { text: 'Refuse', effect: () => { showMessage('You walk away from the game.', 'info'); }}
                ]},
            { id: 'treasure', title: '🏺 Cursed Treasure', text: 'A golden chest glimmers before you... but dark energy surrounds it.',
                choices: [
                    { text: '💰 Take the risk (+50 gold, -10 HP)', effect: () => { 
                        if (game.health > 10) { game.health -= 10; earnGold(50); showMessage('💰 +50 gold! But the curse hurts...', 'success'); }
                        else { showMessage('⚠️ Too risky! You need more than 10 HP!', 'danger'); }
                        updateUI();
                    }},
                    { text: '🔮 Try to cleanse it (50% chance)', effect: () => {
                        if (Math.random() < 0.5) { earnGold(60); showMessage('✨ Cleansed! +60 gold with no curse!', 'success'); }
                        else { game.health -= 15; showMessage('💔 The curse backfired! -15 HP!', 'danger'); }
                        updateUI();
                    }},
                    { text: '🚪 Leave it alone', effect: () => { showMessage('Wisdom over greed.', 'info'); }}
                ]},
            { id: 'witch', title: '🧙 Mysterious Witch', text: 'An old witch offers her services: "I can upgrade your equipment... for a price."',
                choices: [
                    { text: '⚔️ Upgrade weapon (+2 damage, 25 gold)', effect: () => {
                        if (game.gold >= 25 && game.equippedWeapon) { game.gold -= 25; game.equippedWeapon.numValue += 2; showMessage('⚔️ Weapon upgraded!', 'success'); updateUI(); }
                        else if (!game.equippedWeapon) { showMessage('No weapon to upgrade!', 'warning'); }
                        else { showMessage('Not enough gold!', 'danger'); }
                    }},
                    { text: '❤️ Restore all HP (30 gold)', effect: () => {
                        if (game.gold >= 30) { game.gold -= 30; game.health = game.maxHealth; showMessage('❤️ Fully healed!', 'success'); updateUI(); }
                        else { showMessage('Not enough gold!', 'danger'); }
                    }},
                    { text: '🏃 Decline', effect: () => { showMessage('"Your loss, scoundrel!"', 'info'); }}
                ]},
            { id: 'library', title: '📚 Ancient Library', text: 'You discover a library filled with magical tomes.',
                choices: [
                    { text: '📖 Study combat techniques (+1 damage permanent)', effect: () => {
                        game.relics.push({ id: 'study_bonus', name: '📖 Combat Study', description: '+1 damage', rarity: 'common', effect: 'smallPower' });
                        showMessage('📖 You learned new techniques!', 'success');
                        updateRelicsDisplay();
                    }},
                    { text: '🔮 Learn healing magic (+1 HP/room)', effect: () => {
                        game.relics.push({ id: 'healing_study', name: '🔮 Healing Magic', description: '+1 HP per room', rarity: 'uncommon', effect: 'passive_heal' });
                        showMessage('🔮 You mastered healing!', 'success');
                        updateRelicsDisplay();
                    }},
                    { text: '🚪 Leave quickly', effect: () => { showMessage('No time for reading!', 'info'); }}
                ]},
            { id: 'beggar', title: '🙏 Poor Beggar', text: 'A starving beggar asks for help. "Please... just 5 gold for food..."',
                choices: [
                    { text: '❤️ Give 5 gold (Karma reward)', effect: () => {
                        if (game.gold >= 5) { 
                            game.gold -= 5; 
                            game.health = Math.min(game.maxHealth, game.health + 3);
                            showMessage('❤️ Good deed! +3 HP (karma)', 'success'); 
                        } else { showMessage('Not enough gold!', 'danger'); }
                        updateUI();
                    }},
                    { text: '💰 Give 20 gold (Great karma)', effect: () => {
                        if (game.gold >= 20) { 
                            game.gold -= 20;
                            giveRandomRelic('uncommon');
                            showMessage('✨ Your kindness is rewarded! (Relic gained)', 'success');
                        } else { showMessage('Not enough gold!', 'danger'); }
                    }},
                    { text: '🚶 Ignore', effect: () => { showMessage('You walk past...', 'info'); }}
                ]},
            { id: 'blacksmith', title: '⚒️ Dwarven Blacksmith', text: 'A skilled dwarf offers to fix your gear. "I can repair or enhance!"',
                choices: [
                    { text: '🔧 Repair weapon (Full durability, 15 gold)', effect: () => {
                        if (game.gold >= 15 && game.equippedWeapon && game.equippedWeapon.durability < game.equippedWeapon.maxDurability) {
                            game.gold -= 15;
                            game.equippedWeapon.durability = game.equippedWeapon.maxDurability;
                            showMessage('🔧 Weapon fully repaired!', 'success');
                            updateUI();
                        } else if (!game.equippedWeapon) { showMessage('No weapon!', 'warning'); }
                        else if (game.equippedWeapon.durability >= game.equippedWeapon.maxDurability) { showMessage('Already at full durability!', 'info'); }
                        else { showMessage('Not enough gold!', 'danger'); }
                    }},
                    { text: '⭐ Enhance durability (+2 max uses, 25 gold)', effect: () => {
                        if (game.gold >= 25 && game.equippedWeapon) {
                            game.gold -= 25;
                            game.equippedWeapon.maxDurability += 2;
                            game.equippedWeapon.durability += 2;
                            showMessage('⭐ Weapon enhanced!', 'success');
                            updateUI();
                        } else if (!game.equippedWeapon) { showMessage('No weapon!', 'warning'); }
                        else { showMessage('Not enough gold!', 'danger'); }
                    }},
                    { text: '👋 No thanks', effect: () => { showMessage('"Suit yourself!"', 'info'); }}
                ]},
            { id: 'dragon', title: '🐉 Sleeping Dragon', text: 'A dragon sleeps atop a massive hoard of gold. Do you dare...?',
                choices: [
                    { text: '💎 Steal carefully (60% success)', effect: () => {
                        if (Math.random() < 0.6) { 
                            earnGold(40); 
                            showMessage('🤫 +40 gold stolen! The dragon sleeps...', 'success'); 
                        } else { 
                            game.health -= 20; 
                            showMessage('🐉 The dragon wakes! -20 HP!', 'danger'); 
                        }
                        updateUI();
                    }},
                    { text: '🗡️ Fight the dragon! (-15 HP, +80 gold)', effect: () => {
                        if (game.health > 15) {
                            game.health -= 15;
                            earnGold(80);
                            showMessage('🐉 Victory! +80 gold!', 'success');
                        } else { showMessage('Too dangerous!', 'danger'); }
                        updateUI();
                    }},
                    { text: '🏃 Run away', effect: () => { showMessage('Discretion is the better part of valor.', 'info'); }}
                ]},
            { id: 'mirror', title: '🪞 Magic Mirror', text: 'A mystical mirror shows your reflection. "Touch me and face yourself..."',
                choices: [
                    { text: '✨ Accept the challenge (Mirror match)', effect: () => {
                        const damage = Math.floor(game.health * 0.3);
                        game.health -= damage;
                        earnGold(30);
                        showMessage(`🪞 You defeat your reflection! -${damage} HP, +30 gold`, 'success');
                        updateUI();
                    }},
                    { text: '🔮 Ask for wisdom (+5 HP)', effect: () => {
                        game.health = Math.min(game.maxHealth, game.health + 5);
                        showMessage('🔮 The mirror grants clarity. +5 HP', 'success');
                        updateUI();
                    }},
                    { text: '🚪 Leave', effect: () => { showMessage('You look away from the mirror.', 'info'); }}
                ]},
            { id: 'ghost', title: '👻 Friendly Ghost', text: 'A spectral figure appears. "I can help you... or hurt you. Your choice!"',
                choices: [
                    { text: '🎁 Accept help (Random buff)', effect: () => {
                        const buffs = ['dodge', 'berserk', 'goldBonus'];
                        const buff = buffs[Math.floor(Math.random() * buffs.length)];
                        if (buff === 'dodge') { game.dodgeActive = true; showMessage('👻 Next attack dodged!', 'success'); }
                        else if (buff === 'berserk') { game.berserkStacks += 3; showMessage('👻 +3 Berserk stacks!', 'success'); }
                        else { earnGold(20); showMessage('👻 +20 gold!', 'success'); }
                        updateUI();
                    }},
                    { text: '⚔️ Attack the ghost (Risk/reward)', effect: () => {
                        if (Math.random() < 0.5) {
                            earnGold(50);
                            showMessage('👻 The ghost vanishes, dropping gold! +50', 'success');
                        } else {
                            game.health -= 8;
                            showMessage('👻 The ghost counterattacks! -8 HP', 'danger');
                        }
                        updateUI();
                    }},
                    { text: '🙏 Show respect', effect: () => { showMessage('👻 "Wise choice, mortal."', 'info'); }}
                ]},
            { id: 'portal', title: '🌀 Mysterious Portal', text: 'A swirling portal appears. Where does it lead?',
                choices: [
                    { text: '🎲 Jump in! (Random outcome)', effect: () => {
                        const outcomes = ['good', 'great', 'bad'];
                        const result = outcomes[Math.floor(Math.random() * outcomes.length)];
                        if (result === 'good') { game.health += 8; showMessage('🌀 Portal leads to healing springs! +8 HP', 'success'); }
                        else if (result === 'great') { giveRandomRelic(); showMessage('🌀 You found a treasure room! Relic gained!', 'success'); }
                        else { game.health -= 5; showMessage('🌀 Ouch! Rough landing. -5 HP', 'danger'); }
                        updateUI();
                    }},
                    { text: '🔍 Study it first (Safer)', effect: () => {
                        earnGold(15);
                        showMessage('🌀 You analyze the portal and find gold nearby. +15', 'success');
                        updateUI();
                    }},
                    { text: '🚫 Avoid it', effect: () => { showMessage('You don\'t trust strange portals.', 'info'); }}
                ]},
            { id: 'altar', title: '🕯️ Sacrificial Altar', text: 'An ancient altar radiates dark power. "Offer something... gain something greater."',
                choices: [
                    { text: '❤️ Sacrifice 10 HP (Rare relic)', effect: () => {
                        if (game.health > 10) {
                            game.health -= 10;
                            giveRandomRelic('rare');
                            showMessage('🕯️ The altar accepts! Rare relic gained!', 'success');
                        } else { showMessage('Not enough HP!', 'danger'); }
                        updateUI();
                    }},
                    { text: '💰 Sacrifice 30 gold (+10 max HP)', effect: () => {
                        if (game.gold >= 30) {
                            game.gold -= 30;
                            game.maxHealth += 10;
                            game.health += 10;
                            showMessage('🕯️ Power flows through you! +10 max HP', 'success');
                        } else { showMessage('Not enough gold!', 'danger'); }
                        updateUI();
                    }},
                    { text: '🏃 Flee', effect: () => { showMessage('You back away slowly.', 'info'); }}
                ]},
            { id: 'trap', title: '⚠️ Hidden Trap Room', text: 'You trigger a trap! Spikes, arrows, or treasure?',
                choices: [
                    { text: '🛡️ Defend (-5 HP, safe)', effect: () => {
                        game.health -= 5;
                        showMessage('⚠️ You block most damage! -5 HP', 'warning');
                        updateUI();
                    }},
                    { text: '🤸 Dodge! (50% avoid all)', effect: () => {
                        if (Math.random() < 0.5) {
                            earnGold(25);
                            showMessage('🤸 Perfect dodge! Found hidden gold! +25', 'success');
                        } else {
                            game.health -= 12;
                            showMessage('⚠️ Failed! Hit by trap! -12 HP', 'danger');
                        }
                        updateUI();
                    }},
                    { text: '💰 Check for treasure (Risk)', effect: () => {
                        if (Math.random() < 0.3) {
                            giveRandomRelic();
                            showMessage('🎁 Trap was a ruse! Relic found!', 'success');
                        } else {
                            game.health -= 15;
                            showMessage('💔 Trap activates! -15 HP', 'danger');
                        }
                        updateUI();
                    }}
                ]}
        ];
        
        // ===================================
        // NEW SHOP_ITEMS LIST
        // ===================================
        const SHOP_ITEMS = [
            {
                id: 'heal_small', name: '💊 Small Potion', description: 'Restore 8 HP', price: 18,
                buy: () => { game.health = Math.min(game.maxHealth, game.health + 8); showMessage('Healed 8 HP!', 'success'); return true; }
            },
            {
                id: 'heal_large', name: '🍾 Large Potion', description: 'Restore 15 HP', price: 30,
                buy: () => { game.health = Math.min(game.maxHealth, game.health + 15); showMessage('Healed 15 HP!', 'success'); return true; }
            },
            {
                id: 'heal_full', name: '✨ Elixir', description: 'Restore to full HP', price: 50,
                buy: () => { game.health = game.maxHealth; showMessage('Fully healed!', 'success'); return true; }
            },
            {
                id: 'max_health', name: '❤️ Heart Container', description: '+5 maximum HP', price: 35,
                buy: () => { game.maxHealth += 5; game.health += 5; showMessage('+5 Max HP!', 'success'); return true; }
            },
            {
                id: 'max_health_big', name: '❤️❤️ Large Heart', description: '+10 maximum HP', price: 60,
                buy: () => { game.maxHealth += 10; game.health += 10; showMessage('+10 Max HP!', 'success'); return true; }
            },
            {
                id: 'weapon_upgrade', name: '⚔️ Weapon Polish', description: 'Upgrade current weapon by +2', price: 40,
                buy: () => {
                    if (game.equippedWeapon) {
                        game.equippedWeapon.numValue += 2;
                        showMessage('Weapon upgraded!', 'success');
                        updateUI();
                        return true;
                    } else {
                        showMessage('No weapon equipped!', 'danger');
                        return false;
                    }
                }
            },
            {
                id: 'weapon_big_upgrade', name: '⚔️⚔️ Master Forge', description: 'Upgrade current weapon by +5', price: 70,
                buy: () => {
                    if (game.equippedWeapon) {
                        game.equippedWeapon.numValue += 5;
                        showMessage('Weapon greatly upgraded!', 'success');
                        updateUI();
                        return true;
                    } else {
                        showMessage('No weapon equipped!', 'danger');
                        return false;
                    }
                }
            },
            {
                id: 'common_relic', name: '⚪ Common Relic', description: 'Gain a random common relic', price: 25,
                buy: () => { giveRelicByRarity('common'); return true; }
            },
            {
                id: 'uncommon_relic', name: '🟢 Uncommon Relic', description: 'Gain a random uncommon relic', price: 50,
                buy: () => { giveRelicByRarity('uncommon'); return true; }
            },
            {
                id: 'rare_relic', name: '🔵 Rare Relic', description: 'Gain a random rare relic', price: 100,
                buy: () => { giveRelicByRarity('rare'); return true; }
            },
            {
                id: 'legendary_relic', name: '🟠 Legendary Relic', description: 'Gain a random legendary relic', price: 200,
                buy: () => { giveRelicByRarity('legendary'); return true; }
            },
            {
                id: 'repair_weapon', name: '🔧 Weapon Repair', description: 'Restore weapon durability to full', price: 25,
                buy: () => {
                    if (game.equippedWeapon && game.equippedWeapon.durability < game.equippedWeapon.maxDurability) {
                        game.equippedWeapon.durability = game.equippedWeapon.maxDurability;
                        showMessage(`🔧 Weapon repaired! (${game.equippedWeapon.durability}/${game.equippedWeapon.maxDurability})`, 'success');
                        updateUI();
                        return true;
                    } else if (!game.equippedWeapon) {
                        showMessage('No weapon equipped!', 'danger');
                        return false;
                    } else {
                        showMessage('Weapon already at full durability!', 'info');
                        return false;
                    }
                }
            },
            {
                id: 'remove_card', name: '🔥 Card Removal', description: 'Remove a card from deck (coming soon)', price: 25,
                buy: () => { showMessage('Feature coming soon!', 'info'); return false; }
            }
        ];
        
        let permanentUnlocks = {
            startHealth: false, startGold: false, betterDrops: false, extraRelic: false,
            strongerWeapons: false, masterHealer: false, richStart: false, comboMaster: false,
            bigStart: false, ultraWeapons: false, godMode: false, relicMaster: false,
            shopDiscount: false, eventLuck: false, survivalBonus: false, speedBonus: false,
            weaponMaster: false, potionMaster: false, goldRush: false, comboGod: false,
            durablePlus: false, startPower: false, megaHealth: false, luckyCharm: false,
            berserkMaster: false, mirrorMaster: false, dodgeMaster: false, criticalStrike: false,
            lifeSteal: false, thornsArmor: false
        };
        const UNLOCKS = [
            // Tier 1: Beginner (Easy)
            { id: 'startHealth', name: '❤️ Tough Start', description: 'Start each run with +5 max HP', requirement: 'Clear 10 rooms', check: () => getTotalStat('roomsCleared') >= 10 },
            { id: 'startGold', name: '💰 Rich Start', description: 'Start each run with 30 gold', requirement: 'Earn 200 gold (lifetime)', check: () => getTotalStat('totalGoldEarned') >= 200 },
            { id: 'strongerWeapons', name: '⚔️ Weapon Expert', description: 'All weapons get +1 damage', requirement: 'Defeat 50 monsters', check: () => getTotalStat('monstersSlain') >= 50 },
            { id: 'masterHealer', name: '💚 Healer', description: 'All potions heal +2 HP', requirement: 'Use 20 potions', check: () => getTotalStat('potionsUsed') >= 20 },
            { id: 'comboMaster', name: '🔥 Combo Start', description: 'Combos start at 1 instead of 0', requirement: 'Get a 5x combo', check: () => getTotalStat('maxCombo') >= 5 },
            
            // Tier 2: Intermediate (Medium)
            { id: 'betterDrops', name: '🍀 Lucky', description: '+30% gold from all sources', requirement: 'Earn 500 gold (lifetime)', check: () => getTotalStat('totalGoldEarned') >= 500 },
            { id: 'extraRelic', name: '🔮 Relic Start', description: 'Start each run with 1 random relic', requirement: 'Clear 30 rooms', check: () => getTotalStat('roomsCleared') >= 30 },
            { id: 'richStart', name: '💎 Wealthy Start', description: 'Start with 50 gold instead of 30', requirement: 'Earn 1000 gold (lifetime)', check: () => getTotalStat('totalGoldEarned') >= 1000 },
            { id: 'weaponMaster', name: '⚔️ Weapon Master', description: 'All weapons get +2 damage (stacks with Expert)', requirement: 'Equip 100 weapons', check: () => getTotalStat('weaponsEquipped') >= 100 },
            { id: 'potionMaster', name: '💊 Potion Master', description: 'All potions heal +4 HP (stacks)', requirement: 'Use 75 potions', check: () => getTotalStat('potionsUsed') >= 75 },
            
            // Tier 3: Advanced (Hard)
            { id: 'bigStart', name: '❤️❤️ Warrior Start', description: 'Start with +10 max HP (stacks)', requirement: 'Clear 75 rooms', check: () => getTotalStat('roomsCleared') >= 75 },
            { id: 'durablePlus', name: '🛠️ Durable Weapons', description: 'Weapons have +1 durability on all difficulties', requirement: 'Win 3 games', check: () => getTotalStat('gamesWon') >= 3 },
            { id: 'goldRush', name: '💰💰 Gold Rush', description: '+50% gold from all sources (stacks)', requirement: 'Earn 3000 gold (lifetime)', check: () => getTotalStat('totalGoldEarned') >= 3000 },
            { id: 'shopDiscount', name: '🏪 Merchant Friend', description: '20% discount in all shops', requirement: 'Buy 50 items from shop', check: () => getTotalStat('itemsBought') >= 50 },
            { id: 'relicMaster', name: '🔮🔮 Double Relic Start', description: 'Start with 2 random relics', requirement: 'Clear 100 rooms', check: () => getTotalStat('roomsCleared') >= 100 },
            
            // Tier 4: Expert (Very Hard)
            { id: 'ultraWeapons', name: '⚔️⚔️⚔️ Weapon God', description: 'All weapons get +4 damage total', requirement: 'Defeat 500 monsters', check: () => getTotalStat('monstersSlain') >= 500 },
            { id: 'startPower', name: '⚡ Power Start', description: 'Start each run with a random weapon', requirement: 'Win 5 games', check: () => getTotalStat('gamesWon') >= 5 },
            { id: 'megaHealth', name: '❤️❤️❤️ Titan Health', description: 'Start with +20 max HP total', requirement: 'Clear 150 rooms', check: () => getTotalStat('roomsCleared') >= 150 },
            { id: 'eventLuck', name: '🎲 Event Master', description: 'Events appear 50% more often', requirement: 'Complete 50 events', check: () => getTotalStat('eventsCompleted') >= 50 },
            { id: 'luckyCharm', name: '🍀🍀 Super Lucky', description: '+60% gold from all sources', requirement: 'Earn 5000 gold (lifetime)', check: () => getTotalStat('totalGoldEarned') >= 5000 },
            
            // Tier 5: Master (Extreme)
            { id: 'comboGod', name: '🔥🔥🔥 Combo God', description: 'Combos start at 2, +2 damage per combo', requirement: 'Get a 15x combo', check: () => getTotalStat('maxCombo') >= 15 },
            { id: 'survivalBonus', name: '💪 Survivor', description: 'Start with +5 HP when below 50% health', requirement: 'Win 10 games', check: () => getTotalStat('gamesWon') >= 10 },
            { id: 'speedBonus', name: '⏱️ Speedrunner', description: 'Gain 2x gold for winning under 5 minutes', requirement: 'Win a game in under 5 minutes', check: () => getTotalStat('fastestWin') > 0 && getTotalStat('fastestWin') < 300 },
            { id: 'berserkMaster', name: '🔥 Berserk God', description: 'Berserk gives +7 damage instead of +5', requirement: 'Use Berserk 50 times', check: () => getTotalStat('berserkUses') >= 50 },
            { id: 'mirrorMaster', name: '🪞 Mirror Master', description: 'Mirror reflects 15 damage instead of 10', requirement: 'Win a game on Hard', check: () => getTotalStat('hardWins') >= 1 },
            
            // Tier 6: Legend (Insane)
            { id: 'godMode', name: '👑 God Mode', description: 'Start with +15 max HP, 100 gold, 2 relics', requirement: 'Win 20 games', check: () => getTotalStat('gamesWon') >= 20 },
            { id: 'dodgeMaster', name: '🛡️ Dodge God', description: 'Dodge cards avoid 2 attacks instead of 1', requirement: 'Clear 200 rooms', check: () => getTotalStat('roomsCleared') >= 200 },
            { id: 'criticalStrike', name: '💥 Critical Master', description: '10% chance to deal 3x damage', requirement: 'Defeat 1000 monsters', check: () => getTotalStat('monstersSlain') >= 1000 },
            { id: 'lifeSteal', name: '🧛 Vampiric', description: 'Heal 1 HP on every perfect kill', requirement: 'Win 15 games', check: () => getTotalStat('gamesWon') >= 15 },
            { id: 'thornsArmor', name: '🌵 Thorns', description: 'Reflect 2 damage to all attackers', requirement: 'Win 3 games on Hard', check: () => getTotalStat('hardWins') >= 3 }
        ];

        // Support Functions (Shop, Relics, etc.)
        function earnGold(amount) {
            let mult = 1.0;
            
            // Gold multipliers from relics
            if (game.relics.some(r => r.id === 'lucky_penny')) mult += 0.2;
            if (game.relics.some(r => r.id === 'magnet')) mult += 0.4;
            if (game.relics.some(r => r.id === 'lucky')) mult += 0.6;
            
            // Permanent unlocks
            if (permanentUnlocks.betterDrops) mult += 0.3;
            if (permanentUnlocks.goldRush) mult += 0.5;
            if (permanentUnlocks.luckyCharm) mult += 0.6;
            
            const actual = Math.floor(amount * mult);
            game.gold += actual;
            game.totalGoldEarned += actual;
            updateRunningScore(); // Update score
            updateUI();
        }

        // Give relic by specific rarity
        function giveRelicByRarity(rarity) {
            let available = RELICS.filter(r => r.rarity === rarity && !game.relics.find(gr => gr.id === r.id));
            
            // If no new relics of this rarity, allow duplicates
            if (available.length === 0) {
                available = RELICS.filter(r => r.rarity === rarity);
            }
            
            if (available.length === 0) {
                showMessage('No relics of this rarity available!', 'warning');
                return;
            }
            
            const randomRelic = available[Math.floor(Math.random() * available.length)];
            game.relics.push({...randomRelic, used: false});
            
            // Apply immediate health effects
            if (randomRelic.effect === 'smallHealth') { game.maxHealth += 3; game.health += 3; }
            if (randomRelic.effect === 'maxHealth') { game.maxHealth += 5; game.health += 5; }
            if (randomRelic.effect === 'bigHealth') { game.maxHealth += 10; game.health += 10; }
            if (randomRelic.effect === 'tinyHealth') { game.maxHealth += 1; game.health += 1; }
            
            const rarityColors = { common: '⚪', uncommon: '🟢', rare: '🔵', legendary: '🟠' };
            showMessage(`${rarityColors[rarity]} Relic: ${randomRelic.name}!`, 'success');
            updateRelicsDisplay();
            updateUI();
        }
        
        // Give random relic (defaults to common for unlocks)
        function giveRandomRelic(rarityFilter = 'common') {
            giveRelicByRarity(rarityFilter);
        }
        
        function giveRareRelic() {
            giveRelicByRarity('rare');
        }

        function updateRelicsDisplay() {
            if (game.relics.length === 0) {
                relicsList.innerHTML = '<div class="relic-effect">No relics yet.</div>';
                return;
            }
            relicsList.innerHTML = game.relics.map(r => `
                <div class="relic-item ${r.used ? 'used' : ''}">
                    <div class="relic-name">${r.name}</div>
                    <div class="relic-effect">${r.description}</div>
                </div>
            `).join('');
        }

        function getRelicBonus(type) {
            let bonus = 0;
            game.relics.forEach(r => {
                if (r.effect === type) {
                    // Power bonuses
                    if (type === 'smallPower') bonus += 1;
                    if (type === 'power') bonus += 2;
                    if (type === 'bigPower') bonus += 3;
                    
                    // Heal bonuses
                    if (type === 'smallHealBonus') bonus += 1;
                    if (type === 'healBonus') bonus += 2;
                    
                    // Gold bonuses
                    if (type === 'smallGoldPerRoom') bonus += 2;
                    if (type === 'goldPerRoom') bonus += 3;
                }
            });
            
            // Permanent unlocks bonuses
            if (type === 'power' && permanentUnlocks.strongerWeapons) bonus += 1;
            if (type === 'healBonus' && permanentUnlocks.masterHealer) bonus += 2;
            
            // Sum all power types for total weapon bonus
            if (type === 'totalPower') {
                bonus += getRelicBonus('smallPower');
                bonus += getRelicBonus('power');
                bonus += getRelicBonus('bigPower');
            }
            
            return bonus;
        }

        function triggerRandomEvent() {
            if (game.gameOver) return;
            
            // Filter out events already seen this run (no repeats)
            const availableEvents = EVENTS.filter(e => !game.seenEvents.includes(e.id));
            
            // If all events seen, reset the pool
            if (availableEvents.length === 0) {
                game.seenEvents = [];
                availableEvents.push(...EVENTS);
            }
            
            // Pick random event from available pool
            const event = availableEvents[Math.floor(Math.random() * availableEvents.length)];
            
            // Mark event as seen this run
            game.seenEvents.push(event.id);
            
            // Mark that an event was triggered this room (max 1 per room)
            game.eventTriggeredThisRoom = true;
            
            showEventModal(event);
        }
        
        function showEventModal(event) {
            eventTitle.textContent = event.title;
            eventText.innerHTML = event.text;
            eventChoices.innerHTML = ''; // Clear previous choices
            
            event.choices.forEach(choice => {
                const choiceEl = document.createElement('div');
                choiceEl.className = 'event-choice';
                choiceEl.innerHTML = choice.text;
                choiceEl.onclick = () => {
                    choice.effect();
                    eventModal.classList.remove('active');
                    
                    // Track event completion for achievement
                    const saved = localStorage.getItem('scoundrel_lifetime_stats');
                    let lifetimeStats = saved ? JSON.parse(saved) : {};
                    lifetimeStats.eventsCompleted = (lifetimeStats.eventsCompleted || 0) + 1;
                    localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
                    
                    // Re-enable buttons if room is empty
                    if (game.room.length === 0) {
                        btnDrawRoom.disabled = false;
                        btnAvoidRoom.disabled = game.lastActionWasAvoid;
                    }
                    updateUI();
                    checkGameState();
                    checkAchievements();
                };
                eventChoices.appendChild(choiceEl);
            });
            
            // Disable game buttons while event is active
            btnDrawRoom.disabled = true;
            btnAvoidRoom.disabled = true;
            eventModal.classList.add('active');
        }
        
        function openShop() {
            updateShopDisplay();
            // Disable game buttons
            btnDrawRoom.disabled = true;
            btnAvoidRoom.disabled = true;
            shopModal.classList.add('active');
            
            // Switch to shop music
            music.switchContext('shop');
            
            // Track shop visit for score penalty AND achievements
            game.stats.shopsVisited = (game.stats.shopsVisited || 0) + 1;
            
            const saved = localStorage.getItem('scoundrel_lifetime_stats');
            let lifetimeStats = saved ? JSON.parse(saved) : {};
            lifetimeStats.shopsVisited = (lifetimeStats.shopsVisited || 0) + 1;
            localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
            checkAchievements();
        }

        function updateShopDisplay() {
            shopGoldAmount.textContent = game.gold;
            shopItems.innerHTML = ''; // Clear shop
            
            // Check for shop discount unlock
            const discount = permanentUnlocks.shopDiscount ? 0.8 : 1.0; // 20% discount
            
            // Show price multiplier warning if prices have increased
            if (game.shopPriceMultiplier > 1.0) {
                const increasePercent = Math.round((game.shopPriceMultiplier - 1) * 100);
                const warningBanner = document.createElement('div');
                warningBanner.style.cssText = 'background: rgba(255, 107, 107, 0.2); border: 2px solid #ff6b6b; padding: 10px; margin-bottom: 15px; text-align: center; border-radius: 8px;';
                warningBanner.innerHTML = `⚠️ <strong>Prices increased by ${increasePercent}%</strong> due to repeated purchases!`;
                shopItems.appendChild(warningBanner);
            }
            
            SHOP_ITEMS.forEach(item => {
                const basePrice = Math.floor(item.price * discount);
                const finalPrice = Math.floor(basePrice * game.shopPriceMultiplier);
                const itemEl = document.createElement('div');
                itemEl.className = 'shop-item';
                
                // Add visual indicator if can't afford
                const canAfford = game.gold >= finalPrice;
                const affordClass = canAfford ? '' : 'cannot-afford';
                const priceColor = canAfford ? '#ffd700' : '#ff6b6b';
                
                // Show original price if discount OR price increased
                let priceDisplayHTML = '';
                if (discount < 1.0 && game.shopPriceMultiplier > 1.0) {
                    // Show both original and base (with multiplier) if both active
                    priceDisplayHTML = `<span style="text-decoration: line-through; opacity: 0.5;">${item.price}</span> → <span style="text-decoration: line-through; opacity: 0.5;">${basePrice}</span> `;
                } else if (discount < 1.0) {
                    // Just discount
                    priceDisplayHTML = `<span style="text-decoration: line-through; opacity: 0.5;">${item.price}</span> `;
                } else if (game.shopPriceMultiplier > 1.0) {
                    // Just price increase
                    priceDisplayHTML = `<span style="text-decoration: line-through; opacity: 0.5;">${item.price}</span> `;
                }
                
                itemEl.innerHTML = `
                    <div class="item-info ${affordClass}">
                        <div class="item-name">${item.name}</div>
                        <div class="item-description">${item.description}</div>
                        <div class="item-price" style="color: ${priceColor}; font-weight: bold;">
                            ${priceDisplayHTML}${finalPrice} 🪙
                            ${!canAfford ? ' <span style="color: #ff6b6b; font-size: 0.9em;">(Need ' + (finalPrice - game.gold) + ' more)</span>' : ''}
                        </div>
                    </div>
                    <button class="buy-btn" data-item-id="${item.id}" data-price="${finalPrice}">${canAfford ? 'Buy' : '🔒 Locked'}</button>
                `;
                
                const buyBtn = itemEl.querySelector('.buy-btn');
                if (!canAfford) {
                    buyBtn.disabled = true;
                    buyBtn.style.opacity = '0.5';
                }
                
                buyBtn.onclick = () => buyItem(item, finalPrice);
                
                shopItems.appendChild(itemEl);
            });
            
            // Show discount banner if unlocked
            if (discount < 1.0) {
                const banner = document.createElement('div');
                banner.style.cssText = 'background: rgba(255, 215, 0, 0.2); border: 2px solid #ffd700; padding: 10px; margin-bottom: 15px; text-align: center; border-radius: 8px;';
                banner.innerHTML = '🏪 <strong>Merchant Friend Active!</strong> 20% discount on all items!';
                shopItems.prepend(banner);
            }
        }
        
        function buyItem(item, finalPrice) {
            if (game.gold < finalPrice) {
                showMessage(`❌ Not enough gold! Need ${finalPrice - game.gold} more.`, 'danger');
                playSound('error');
                return;
            }
            
            const success = item.buy(); // Run the item's function
            if (success) {
                game.gold -= finalPrice;
                
                // ANTI-EXPLOIT: Increase prices by 15% after each purchase
                game.shopPriceMultiplier *= 1.15;
                
                showMessage(`Purchased ${item.name}!`, 'success');
                playSound('special');
                
                // Track item purchase for achievement
                const saved = localStorage.getItem('scoundrel_lifetime_stats');
                let lifetimeStats = saved ? JSON.parse(saved) : {};
                lifetimeStats.itemsBought = (lifetimeStats.itemsBought || 0) + 1;
                localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
                
                updateUI();
                updateShopDisplay(); // Re-render shop
                checkAchievements();
            } else {
                playSound('error');
            }
        }
        
        function closeShop() {
            shopModal.classList.remove('active');
            // Return to gameplay music
            music.switchContext('gameplay');
            if (game.room.length === 0) {
                btnDrawRoom.disabled = false;
                btnAvoidRoom.disabled = game.lastActionWasAvoid;
            }
        }

        // Modal open/close functions
        function showTutorial() { tutorialModal.classList.add('active'); }
        
        function openUnlocks() { 
            updateUnlocksDisplay();
            unlocksModal.classList.add('active');
        }
        
        function updateUnlocksDisplay() { 
            const unlocksList = document.getElementById('unlocksList');
            unlocksList.innerHTML = UNLOCKS.map(unlock => {
                const isUnlocked = permanentUnlocks[unlock.id];
                const canUnlock = !isUnlocked && unlock.check();
                return `
                <div class="unlock-item ${isUnlocked ? 'unlocked' : (canUnlock ? '' : 'locked')}">
                    <div class="item-info">
                        <div class="item-name">${unlock.name}</div>
                        <div class="item-description">${unlock.description}</div>
                        <div class="unlock-requirement">
                            ${isUnlocked ? '✅ UNLOCKED' : 
                              (canUnlock ? '✨ READY TO UNLOCK!' : `🔒 ${unlock.requirement}`)}
                        </div>
                    </div>
                    ${!isUnlocked && canUnlock ? `
                        <button class="buy-btn" onclick="unlockUpgradeWrapper('${unlock.id}')">
                            Unlock
                        </button>
                    ` : ''}
                </div>
            `}).join('');
        }
        
        window.unlockUpgradeWrapper = (unlockId) => {
            permanentUnlocks[unlockId] = true;
            saveUnlocks();
            showMessage('✨ Unlock activated! Will apply to next run.', 'success');
            playSound('special');
            updateUnlocksDisplay();
        }
        
        function loadUnlocks() {
             const saved = localStorage.getItem('scoundrel_unlocks');
             if(saved) {
                try {
                    const parsed = JSON.parse(saved);
                    permanentUnlocks = { ...permanentUnlocks, ...parsed }; // This merges the saved data into the default structure
                } catch(e) { console.error("Failed to parse unlocks:", e); }
             }
        }
        function saveUnlocks() { 
            UNLOCKS.forEach(unlock => {
                if (!permanentUnlocks[unlock.id] && unlock.check()) {
                    // We don't unlock here, just check. Unlocking is manual.
                }
            });
            localStorage.setItem('scoundrel_unlocks', JSON.stringify(permanentUnlocks)); 
        }
        
        function applyPermanentUnlocks() {
            if (permanentUnlocks.startGold) earnGold(30);
            if (permanentUnlocks.richStart) earnGold(20); // Total 50
            if (permanentUnlocks.extraRelic) giveRandomRelic();
        }

        // ============================================
        // LEADERBOARD (FIREBASE)
        // ============================================
        async function submitScoreToLeaderboard(score, gameTime) {
            if (!db || !appId || !userId) throw new Error("Firebase is not ready");
            
            const playerName = playerNameInput.value.trim() || 'Scoundrel';
            
            // Salvar em collection específica por dificuldade
            const collectionName = `leaderboard_${game.difficulty}`;
            const leaderboardCol = collection(db, `/artifacts/${appId}/public/data/${collectionName}`);
            
            const scoreData = {
                name: playerName.substring(0, 20),
                score: score,
                userId: userId,
                difficulty: game.difficulty,
                time: gameTime,
                health: game.health,
                combo: game.stats.maxCombo,
                gold: game.totalGoldEarned,
                createdAt: new Date().toISOString()
            };
            
            await addDoc(leaderboardCol, scoreData);
            console.log(`Score submitted to ${collectionName}:`, scoreData);
        }

        // Current selected difficulty for leaderboard
        let currentLeaderboardDifficulty = 'easy';

        async function showLeaderboard(difficulty = 'easy') {
            leaderboardModal.classList.add('active');
            currentLeaderboardDifficulty = difficulty;
            await loadLeaderboardForDifficulty(difficulty);
        }

        async function loadLeaderboardForDifficulty(difficulty) {
            const listDiv = document.getElementById('leaderboardList');
            listDiv.innerHTML = '<p style="text-align: center; color: #aaa;">Loading scores...</p>';
            
            // Validate difficulty
            if (!difficulty || typeof difficulty !== 'string') {
                difficulty = 'easy'; // Default fallback
            }
            
            if (!db || !appId) {
                listDiv.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px;">
                        <p style="color: #ffd93d; font-size: 1.2em; margin-bottom: 15px;">📡 Offline Mode</p>
                        <p style="color: #aaa;">Leaderboard requires online connection.</p>
                        <p style="color: #aaa; font-size: 0.9em; margin-top: 10px;">
                            Your progress and achievements are still saved locally!
                        </p>
                    </div>
                `;
                return;
            }

            try {
                // Carregar da collection específica da dificuldade
                const collectionName = `leaderboard_${difficulty}`;
                const leaderboardCol = collection(db, `/artifacts/${appId}/public/data/${collectionName}`);
                const q = query(leaderboardCol, limit(100)); // Get latest 100
                
                const querySnapshot = await getDocs(q);
                let scores = [];
                querySnapshot.forEach(doc => scores.push(doc.data()));
                
                // Sort on client (mandatory)
                scores.sort((a, b) => b.score - a.score);
                
                const top10 = scores.slice(0, 10);
                
                if (top10.length === 0) {
                    const diffIcons = { easy: '🟢', normal: '🟡', hard: '🔴', endless: '♾️' };
                    const diffName = difficulty ? difficulty.toUpperCase() : 'UNKNOWN';
                    listDiv.innerHTML = `<p style="text-align: center; color: #aaa;">No scores yet for ${diffIcons[difficulty] || '❓'} ${diffName}.<br>Be the first!</p>`;
                    return;
                }
                
                listDiv.innerHTML = top10.map((entry, index) => `
                    <div class="leaderboard-entry">
                        <span class="leaderboard-rank">#${index + 1}</span>
                        <div style="flex: 1;">
                            <div class="leaderboard-name">${entry.name || 'Scoundrel'}</div>
                            <div class="leaderboard-details" style="font-size: 0.8em; color: #aaa;">
                                ${entry.time}s | ${entry.combo}x Combo | ${entry.gold}🪙
                            </div>
                        </div>
                        <span class="leaderboard-score">${entry.score}</span>
                    </div>
                `).join('');

            } catch (e) {
                console.error("Error fetching leaderboard:", e);
                listDiv.innerHTML = `<p style="text-align: center; color: #ff6b6b;">Error loading: ${e.message}</p>`;
            }
        }

        // Switch leaderboard difficulty (chamada pelos tabs)
        window.switchLeaderboardDifficulty = async function(difficulty) {
            currentLeaderboardDifficulty = difficulty;
            
            // Update tab active state
            document.querySelectorAll('.difficulty-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.difficulty === difficulty) {
                    tab.classList.add('active');
                }
            });
            
            // Load new leaderboard
            await loadLeaderboardForDifficulty(difficulty);
        }
        
        // ============================================
        // PERMANENT STATS (LOCALSTORAGE)
        // ============================================
        function loadPermanentStats() {
            const saved = localStorage.getItem('scoundrel_permanent_stats');
            if (saved) {
                try {
                    permanentStats = JSON.parse(saved);
                } catch(e) {
                    permanentStats = { gamesWon: 0, hardWins: 0, fastestWin: 0 };
                }
            } else {
                permanentStats = { gamesWon: 0, hardWins: 0, fastestWin: 0 };
            }
        }
        function savePermanentStats() {
            localStorage.setItem('scoundrel_permanent_stats', JSON.stringify(permanentStats));
        }
        
        function getTotalStat(stat) {
            const stats = storage.get('scoundrel_lifetime_stats', {});
            return stats[stat] || 0;
        }

        function updateLifetimeStats() {
            storage.update('scoundrel_lifetime_stats', stats => ({
                ...stats,
                monstersSlain: (stats.monstersSlain || 0) + game.stats.monstersSlain,
                roomsCleared: (stats.roomsCleared || 0) + game.stats.roomsCleared,
                potionsUsed: (stats.potionsUsed || 0) + game.stats.potionsUsed,
                totalGoldEarned: (stats.totalGoldEarned || 0) + game.totalGoldEarned,
                maxCombo: Math.max((stats.maxCombo || 0), game.stats.maxCombo),
                weaponsEquipped: (stats.weaponsEquipped || 0) + game.stats.weaponsEquipped,
                specialsUsed: (stats.specialsUsed || 0) + game.stats.specialsUsed,
                roomsAvoided: (stats.roomsAvoided || 0) + game.stats.roomsAvoided,
                cardsHeld: (stats.cardsHeld || 0) + game.stats.cardsHeld,
                gamesWon: (stats.gamesWon || 0) + game.stats.gamesWon,
                // Difficulty-specific wins
                easyWins: game.stats.gamesWon > 0 && game.difficulty === 'easy' ? (stats.easyWins || 0) + 1 : (stats.easyWins || 0),
                normalWins: game.stats.gamesWon > 0 && game.difficulty === 'normal' ? (stats.normalWins || 0) + 1 : (stats.normalWins || 0),
                hardWins: game.stats.gamesWon > 0 && game.difficulty === 'hard' ? (stats.hardWins || 0) + 1 : (stats.hardWins || 0)
            }));
            
            // Check achievements after updating stats
            checkAllAchievements();
        }

        // ============================================
        // ACHIEVEMENTS SYSTEM
        // ============================================
        function getLifetimeStat(stat) {
            return getTotalStat(stat); // Alias for achievements
        }
        
        function loadAchievements() {
            return storage.get('dungeon_scoundrel_achievements', []);
        }
        
        function saveAchievements(unlockedIds) {
            storage.set('dungeon_scoundrel_achievements', unlockedIds);
        }
        
        function unlockAchievement(achievementId) {
            const unlocked = loadAchievements();
            if (!unlocked.includes(achievementId)) {
                unlocked.push(achievementId);
                saveAchievements(unlocked);
                
                const ach = ACHIEVEMENTS.find(a => a.id === achievementId);
                if (ach) {
                    showAchievementToast(ach);
                    playSound('special');
                    createParticles(window.innerWidth / 2, window.innerHeight / 3, '#ffd700', 50);
                }
                
                updateAchievementCounter();
                return true;
            }
            return false;
        }
        
        // Track active achievement toasts for stacking
        let achievementToastCount = 0;
        
        function showAchievementToast(achievement) {
            const toast = document.createElement('div');
            toast.className = 'message success achievement-toast';
            
            // Position à direita, empilhado progressivamente
            const topPosition = 80 + (achievementToastCount * 130); // 130px de espaço entre toasts
            achievementToastCount++;
            
            toast.style.cssText = `
                position: fixed; 
                top: ${topPosition}px; 
                right: 20px; 
                z-index: 9999; 
                min-width: 320px;
                max-width: 350px;
                animation: slideInRight 0.5s ease;
                box-shadow: 0 10px 40px rgba(255, 215, 0, 0.4);
            `;
            
            toast.innerHTML = `
                <div style="font-size: 1.3em;">🏆 ACHIEVEMENT!</div>
                <div style="font-size: 1.1em; margin-top: 5px;">${achievement.icon} ${achievement.title}</div>
                <div style="font-size: 0.9em; margin-top: 3px; opacity: 0.8;">${achievement.description}</div>
            `;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(400px)';
                setTimeout(() => {
                    toast.remove();
                    achievementToastCount--;
                }, 500);
            }, 4000);
        }
        
        function checkAllAchievements() {
            let newlyUnlocked = [];
            const unlocked = loadAchievements();
            
            ACHIEVEMENTS.forEach(ach => {
                if (!unlocked.includes(ach.id) && ach.check()) {
                    if (unlockAchievement(ach.id)) {
                        newlyUnlocked.push(ach.title);
                    }
                }
            });
            
            return newlyUnlocked;
        }
        
        function updateAchievementCounter() {
            const unlocked = loadAchievements();
            achievementCounter.textContent = `${unlocked.length}/50`;
        }
        
        function updateAchievementsDisplay() {
            const unlocked = loadAchievements();
            
            // Update counters
            const bronze = ACHIEVEMENTS.filter(a => a.tier === 'bronze');
            const silver = ACHIEVEMENTS.filter(a => a.tier === 'silver');
            const gold = ACHIEVEMENTS.filter(a => a.tier === 'gold');
            const platinum = ACHIEVEMENTS.filter(a => a.tier === 'platinum');
            
            const bronzeUnlocked = bronze.filter(a => unlocked.includes(a.id)).length;
            const silverUnlocked = silver.filter(a => unlocked.includes(a.id)).length;
            const goldUnlocked = gold.filter(a => unlocked.includes(a.id)).length;
            const platinumUnlocked = platinum.filter(a => unlocked.includes(a.id)).length;
            
            document.getElementById('achievementStats').textContent = `${unlocked.length}/50 Unlocked`;
            document.getElementById('bronzeCount').textContent = `${bronzeUnlocked}/25`;
            document.getElementById('silverCount').textContent = `${silverUnlocked}/15`;
            document.getElementById('goldCount').textContent = `${goldUnlocked}/9`;
            document.getElementById('platinumCount').textContent = `${platinumUnlocked}/1`;
            
            // Render achievement cards
            achievementsList.innerHTML = ACHIEVEMENTS.map(ach => {
                const isUnlocked = unlocked.includes(ach.id);
                const isSecret = ach.secret && !isUnlocked;
                
                return `
                    <div class="achievement-card ${ach.tier} ${isUnlocked ? 'unlocked' : 'locked'} ${isSecret ? 'secret' : ''}">
                        <div class="achievement-header">
                            <span class="achievement-medal">${ach.icon}</span>
                            <span class="achievement-title">${isSecret ? '???' : ach.title}</span>
                        </div>
                        ${!isSecret ? `<div class="achievement-description">${ach.description}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        loadPermanentStats();
        loadUnlocks();
        updateAchievementCounter();
        
        // Initialize menu music (autoplay)
        setTimeout(() => {
            game.settings.musicEnabled = true;
            music.switchContext('menu');
            music.start();
            updateWelcomeMusicButton();
        }, 100);
        
        showWelcomeScreen(); // Show welcome screen on load

    </script>
</body>
</html>

