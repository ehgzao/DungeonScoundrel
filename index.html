<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🎴 Dungeon Scoundrel - Roguelike Card Game</title>
    
    <!-- SEO Meta Tags -->
    <meta name="description" content="A dark medieval roguelike card game. Explore dungeons, fight monsters, collect powerful relics and prove your skill in this challenging card game! 4 difficulties, 50 achievements, permanent unlock system.">
    <meta name="keywords" content="roguelike, card game, medieval, dungeon crawler, RPG, strategy, browser game, HTML5 game, dark fantasy, atmospheric">
    <meta name="author" content="Dungeon Scoundrel Team">
    <meta name="theme-color" content="#2c2416">
    
    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://dungeonscoundrel.com/">
    <meta property="og:title" content="🎴 Dungeon Scoundrel - Dark Medieval Roguelike Card Game">
    <meta property="og:description" content="A challenging medieval roguelike card game. Explore dungeons, collect relics, defeat monsters! 4 difficulties, 50 achievements. Play now in your browser!">
    <meta property="og:image" content="https://dungeonscoundrel.com/favicon.svg">
    <meta property="og:locale" content="en_US">
    <meta property="og:site_name" content="Dungeon Scoundrel">
    
    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image">
    <meta property="twitter:url" content="https://dungeonscoundrel.com/">
    <meta property="twitter:title" content="🎴 Dungeon Scoundrel - Dark Medieval Roguelike">
    <meta property="twitter:description" content="A challenging medieval roguelike card game. Explore dungeons, collect relics, defeat monsters! Play now!">
    <meta property="twitter:image" content="https://dungeonscoundrel.com/favicon.svg">
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <link rel="alternate icon" href="favicon.svg">
    <link rel="mask-icon" href="favicon.svg" color="#d4af37">
    <link rel="apple-touch-icon" href="favicon.svg">
    
    <!-- Web App Manifest -->
    <link rel="manifest" href="site.webmanifest">
    
    <!-- Medieval Fonts from Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700;900&family=Cinzel+Decorative:wght@700;900&family=MedievalSharp&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="src/styles/styles.css">

</head>
<body>

    <!-- ============================================ -->
    <!-- ORIENTATION WARNING (Mobile Portrait)
    <!-- ============================================ -->
    <div class="orientation-warning" id="orientationWarning">
        <div class="orientation-warning-icon">📱➡️📱</div>
        <h2>Rotate Your Device</h2>
        <p>For the best experience, please rotate your device to <strong>landscape mode</strong> (horizontal).</p>
        <p style="margin-top: 20px; font-size: 0.9em; opacity: 0.7;">You can still play in portrait, but landscape is recommended.</p>
    </div>

    <!-- ============================================ -->
    <!-- WELCOME SCREEN
    <!-- ============================================ -->
    <div class="welcome-screen" id="welcomeScreen">
        <h1>🎴 DUNGEON SCOUNDREL</h1>
        <div class="welcome-buttons">
            <button class="welcome-btn" id="btnWelcomeStart">⚔️ Start Quest</button>
            <button class="welcome-btn" id="btnWelcomeTutorial">📜 How to Play</button>
            <button class="welcome-btn" id="btnWelcomeLeaderboard">🏆 Hall of Fame</button>
            <button class="welcome-btn" id="btnWelcomeSoundboard">🎼 Music Chamber</button>
            <button class="welcome-btn btn-highlight" id="btnWelcomeUnlocks">🗝️ Upgrades</button>
        </div>
        
        <!-- Music Controls -->
        <div style="margin-top: 30px; width: 100%; max-width: 350px;">
            <div id="nowPlayingDisplay" style="text-align: center; color: #d4af37; font-size: clamp(0.9em, 3vw, 1.1em); margin-bottom: 15px; min-height: 25px; font-weight: 600; font-family: 'Cinzel', serif;">
                🎵 Dark Awakening
            </div>
            <div style="display: flex; gap: 12px; justify-content: center; align-items: center;">
                <button class="settings-btn" id="btnWelcomeMusicToggle" title="Play/Pause Music" style="font-size: clamp(1.2em, 4vw, 1.5em); padding: 10px 18px; background: linear-gradient(135deg, #8b7355 0%, #a89078 100%); border: 2px solid #d4af37;">
                    ⏯️
                </button>
                <input type="range" id="welcomeMusicVolume" min="0" max="100" value="15" title="Music Volume" 
                       style="width: 120px; height: 24px; cursor: pointer; margin: 0 10px;">
            </div>
        </div>
    </div>

    <!-- ============================================ -->
    <!-- MAIN GAME WRAPPER (HIDDEN)
    <!-- ============================================ -->
    <div class="game-wrapper" id="gameWrapper">

        <!-- TOP BAR (STATS, GOLD, SETTINGS) -->
        <div class="top-bar">
            <div class="stats-group">
                <div class="stat-display" id="top-bar-health" title="Current / Max Health">
                    ❤️ <span class="stat-value" id="health">20</span>
                </div>
                <div class="stat-display" id="top-bar-gold" title="Gold">
                    🪙 <span class="stat-value" id="goldAmount">0</span>
                </div>
                 <!-- Score removed from here -->
                <div class="stat-display" id="top-bar-dungeon" title="Cards left in Dungeon">
                    🏰 <span class="stat-value" id="dungeonCount">0</span>
                </div>
                <div class="stat-display" id="top-bar-rooms" title="Rooms Cleared">
                    🚪 <span class="stat-value" id="statRooms">0</span>
                </div>
            </div>
            
            <!-- ACHIEVEMENTS COMPACT -->
            <div class="achievements-compact" id="achievementsCompact" title="Click to view all achievements">
                🏆 <span class="achievement-counter" id="achievementCounter">0/50</span>
            </div>
            
            <div class="settings-group">
                <button class="settings-btn" id="btnTopSound" title="Toggle Sound (SFX)">🔊</button>
                
                <div class="music-controls">
                    <button class="settings-btn" id="btnMusicToggle" title="Play/Pause Music">⏯️</button>
                    <input type="range" id="musicVolume" min="0" max="100" value="15" title="Music Volume" 
                           style="width: 80px; height: 20px; vertical-align: middle; margin: 0 5px; cursor: pointer;">
                </div>
                
                <button class="settings-btn" id="btnTopTutorial" title="Open Tutorial">📖</button>
                <button class="settings-btn" id="btnTopLeaderboard" title="Open Leaderboard">📊</button>
                <button class="settings-btn btn-highlight" id="btnTopUnlocks" title="Open Unlocks">🔓</button>
                <button class="settings-btn btn-danger-style" id="btnTopGiveUp" title="Give Up Run">🏳️</button>
            </div>
        </div>

        <!-- CENTER AREA (RELICS, STAGE, HOLD) -->
        <div class="center-area">
            
            <!-- LEFT PANEL (RELICS & SHOP) -->
            <div class="left-sidebar" id="relicsPanel">
                <h3>🔮 RELICS</h3>
                <div id="relicsList">
                    <!-- Relics are injected here -->
                </div>
                <div class="sidebar-action">
                    <button class="btn-shop" id="btnOpenShop">🏺 Merchant</button>
                </div>
            </div>

            <!-- CENTER STAGE (WEAPON, MESSAGES, CONTROLS) -->
            <div class="center-stage">
                
                <div id="messageArea">
                    <!-- Messages appear here -->
                </div>

                <!-- NEW SCORE DISPLAY -->
                <div class="score-display" id="mainScoreDisplay">
                    <div class="score-label">SCORE</div>
                    <div class="score-value" id="mainScoreValue">0</div>
                </div>

                <div id="center-stage-weapon">
                    <div class="center-stage-label">Equipped Weapon</div>
                    <div class="cards-row" id="equippedWeapon">
                        <div class="empty-slot">No Weapon</div>
                    </div>
                </div>
                
                <div class="controls">
                    <button class="btn btn-primary" id="btnDrawRoom" disabled>⚔️ Enter Chamber</button>
                    <button class="btn btn-success" id="btnAvoidRoom" disabled>🛡️ Evade</button>
                    <button class="btn btn-warning" id="btnUndo" disabled style="display: none;">↩️ Undo Last Move</button>
                </div>
            </div>

            <!-- RIGHT PANEL (HOLD, DISCARD, TIMER) -->
            <div class="right-sidebar">
                <div class="hold-area">
                    <div class="sidebar-label hold-label">Held Card</div>
                    <div id="holdAreaContainer">
                        <div class="empty-slot" id="holdSlotPlaceholder" style="font-size: 0.85em; line-height: 1.3;">Tap & hold any card<br>to save for later</div>
                    </div>
                </div>
                
                <div class="sidebar-label discard-label">Discard</div>
                <div id="discardPilePreview">
                    <!-- Discard mini-cards -->
                </div>
                
                <div class="sidebar-timer" id="gameTimer">
                    ⏱️ 00:00
                </div>
            </div>

        </div>

        <!-- BOTTOM BAR (ROOM / "HAND") -->
        <div class="bottom-bar" id="room">
            <!-- The 4 room cards appear here -->
            <div class="empty-slot">Click "Enter Dungeon" to start</div>
        </div>
    </div>


    <!-- ============================================ -->
    <!-- MODALS
    <!-- ============================================ -->

    <!-- Modal: New Game (Name + Difficulty) -->
    <div class="modal-overlay" id="newGameModal">
        <div class="modal-content">
            <h2>✨ New Game</h2>
            <div class="form-group">
                <label for="playerNameInput">👤 Player Name (3-10 characters) *</label>
                <input type="text" id="playerNameInput" placeholder="Enter your name" minlength="3" maxlength="10" required>
                <div id="nameError" style="display: none; color: #ff6b6b; font-size: 0.9em; margin-top: 5px; font-weight: bold;"></div>
                <small style="color: #aaa; font-size: 0.85em;">Minimum 3, maximum 10 characters</small>
            </div>
            <div class="form-group">
                <label>🔥 Difficulty</label>
                <div class="difficulty-selector" id="difficultySelector">
                    <button class="difficulty-btn easy" data-difficulty="easy">
                        🟢 Easy<br><small>20 HP | 30 🪙</small>
                    </button>
                    <button class="difficulty-btn normal selected" data-difficulty="normal">
                        🟡 Normal<br><small>15 HP | 15 🪙</small>
                    </button>
                    <button class="difficulty-btn hard" data-difficulty="hard">
                        🔴 Hard<br><small>10 HP | 0 🪙</small>
                    </button>
                    <button class="difficulty-btn endless" data-difficulty="endless">
                        ♾️ Endless<br><small>15 HP | 15 🪙</small>
                    </button>
                </div>
                <div style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; margin-top: 10px; font-size: 0.9em; color: #ddd; line-height: 1.5;">
                    <strong>⚔️ Weapon Durability:</strong> Easy: 3 | Normal: 2 | Hard: 1 | Endless: 2
                    <br><br><strong>💎 Gold & Events:</strong>
                    <br>• <strong>🟢 Easy:</strong> More gold & events (40%)
                    <br>• <strong>🟡 Normal:</strong> Balanced (30%)
                    <br>• <strong>🔴 Hard:</strong> Less gold & events (20%)
                    <br><br><strong>↩️ Undo:</strong> Available on Easy & Normal only
                    <br><br><strong>👹 Boss Battles:</strong> Every 10 rooms!
                    <br><br><strong>Higher difficulty = Bigger score multiplier!</strong>
                </div>
            </div>
            <div class="modal-controls">
                <button class="btn btn-success" id="btnStartGameModal">⚔️ Start Quest!</button>
                <button class="btn btn-secondary" id="btnCancelStart">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Modal: Tutorial -->
    <div class="modal-overlay" id="tutorialModal">
        <div class="modal-content">
            <h2>📜 How to Play</h2>
            
            <div class="tutorial-section">
                <h3>🎯 Objective</h3>
                <p>Clear all cards from the Dungeon deck without your health reaching zero!</p>
            </div>

            <div class="tutorial-section">
                <h3>🎮 Gameplay</h3>
                <p><strong>1. Start the Action:</strong></p>
                <p>• Choose <strong>"Enter Dungeon"</strong> (draws 4 cards) or <strong>"Avoid Dungeon"</strong> (discards 3 cards from the top). You cannot avoid two dungeons in a row.</p>
                <p><strong>2. Clear the Dungeon:</strong></p>
                <p>• You must use or discard all 4 cards from the dungeon (in the bottom bar) to advance.</p>
            </div>

            <div class="tutorial-section">
                <h3>🃏 Card Types</h3>
                <p>
                    <span class="tutorial-card-demo monster">♠️ ♣️ Monsters (Spades & Clubs)</span>
                    <br>Click to fight. You take damage = (Monster Value) - (Your Weapon Value). If your weapon is stronger, you take no damage.
                </p>
                <p>
                    <span class="tutorial-card-demo weapon">♦️ Weapons (Diamonds)</span>
                    <br>Click to equip. Replaces your current weapon.
                </p>
                <p>
                    <span class="tutorial-card-demo potion">♥️ Potions (Hearts)</span>
                    <br>Click to heal. Limit of 1 potion per dungeon!
                </p>
            </div>

            <div class="tutorial-section">
                <h3>📌 "Hold" System</h3>
                <p><strong>Tap & hold</strong> (or <strong>right-click</strong> on desktop) <strong>ANY card</strong> in the room (bottom bar) to save it in the "Held" area (right sidebar).</p>
                <p>• <strong>Works with ALL cards:</strong> Monsters 👹, Weapons ⚔️, Potions 💊, and Specials ✨</p>
                <p>• Only 1 card can be held at a time.</p>
                <p>• Tap the held card to use it immediately (returns to room).</p>
                <p>• <strong>Strategy:</strong> Hold a weapon to skip it now and equip later, or hold a potion for when you need it most!</p>
            </div>
            
            <div class="tutorial-section">
                <h3>⚔️ Weapon Durability</h3>
                <p>Weapons break after use! Easy: 3 uses | Normal: 2 | Hard: 1</p>
                <p>• Colored bar shows durability (🟢 good, 🟡 medium, 🔴 low)</p>
                <p>• Repair in shop or find 🔨 Master Smith relic</p>
            </div>
            
            <div class="tutorial-section">
                <h3>💰 Gold & Economy</h3>
                <p>• <strong>Gold varies by difficulty:</strong> Easy = More | Normal = Balanced | Hard = Much less</p>
                <p>• Get gold from: Monsters, rooms, relics, events</p>
                <p>• <strong>💡 Tip:</strong> On Hard mode, every coin counts!</p>
            </div>
            
            <div class="tutorial-section">
                <h3>🏺 Merchant & 🔮 Relics</h3>
                <p>• <strong>Merchant:</strong> Click 🏺 MERCHANT to spend gold on heals, relics, and upgrades.</p>
                <p>• <strong>Relics by Rarity:</strong></p>
                <p>&nbsp;&nbsp;&nbsp;⚪ Common (25🪙) - Basic bonuses</p>
                <p>&nbsp;&nbsp;&nbsp;🟢 Uncommon (50🪙) - Moderate bonuses</p>
                <p>&nbsp;&nbsp;&nbsp;🔵 Rare (100🪙) - Powerful bonuses</p>
                <p>&nbsp;&nbsp;&nbsp;🟠 Legendary (200🪙) - Game-changing!</p>
                <p>• <strong>Events:</strong> 🎲 Random encounters after clearing rooms. Make choices!</p>
                <p>• <strong>Unlocks:</strong> 🔓 Permanent progress that carries over between runs!</p>
            </div>
            
            <button class="close-modal-btn" id="btnCloseTutorial">Got it!</button>
        </div>
    </div>
    
    <!-- Modal: Leaderboard -->
    <div class="modal-overlay" id="leaderboardModal">
        <div class="modal-content" style="max-width: 700px;">
            <h2>🏆 Hall of Fame (Top 10)</h2>
            
            <!-- Difficulty Tabs -->
            <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
                <button class="difficulty-tab active" data-difficulty="easy" onclick="switchLeaderboardDifficulty('easy')">
                    🟢 Easy
                </button>
                <button class="difficulty-tab" data-difficulty="normal" onclick="switchLeaderboardDifficulty('normal')">
                    🟡 Normal
                </button>
                <button class="difficulty-tab" data-difficulty="hard" onclick="switchLeaderboardDifficulty('hard')">
                    🔴 Hard
                </button>
                <button class="difficulty-tab" data-difficulty="endless" onclick="switchLeaderboardDifficulty('endless')">
                    ♾️ Endless
                </button>
            </div>
            
            <div id="leaderboardList" style="max-height: 400px; overflow-y: auto; padding-right: 10px;">
                <p style="text-align: center; color: #aaa;">Loading scores...</p>
            </div>
            <button class="close-modal-btn" id="btnCloseLeaderboard">Close</button>
        </div>
    </div>
    
    <!-- Other Modals (Shop, Event, Unlocks) - Identical structure -->
    <div class="modal-overlay" id="shopModal">
        <div class="modal-content">
            <h2>🏺 Merchant's Wares</h2>
            <p style="text-align: center; color: #aaa; margin-bottom: 20px;">
                Spend your gold wisely! (Gold: <span id="shopGoldAmount">0</span>)
            </p>
            <div id="shopItems" style="max-height: 400px; overflow-y: auto; padding-right: 10px;"></div>
            <button class="close-modal-btn" id="btnCloseShop">Leave Shop</button>
        </div>
    </div>

    <div class="modal-overlay" id="eventModal">
        <div class="modal-content">
            <h2 id="eventTitle">🎲 Event</h2>
            <div class="event-text" id="eventText"></div>
            <div id="eventChoices"></div>
            <!-- Close button not needed, choice closes modal -->
        </div>
    </div>

    <div class="modal-overlay" id="unlocksModal">
        <div class="modal-content">
            <h2>🗝️ Permanent Upgrades</h2>
            <p style="text-align: center; color: #aaa; margin-bottom: 20px;">
                Progress that continues between runs!
            </p>
            <div id="unlocksList" style="max-height: 400px; overflow-y: auto; padding-right: 10px;"></div>
            <button class="close-modal-btn" id="btnCloseUnlocks">Close</button>
        </div>
    </div>
    
    <!-- Modal: Give Up Confirmation -->
    <div class="modal-overlay" id="giveUpModal">
        <div class="modal-content">
            <h2>🏳️ Give Up?</h2>
            <p class="event-text" style="text-align: center;">Are you sure you want to end this run? Your progress will be lost and your score will be 0.</p>
            <div class="modal-controls" style="flex-direction: row; justify-content: center;">
                <button class="btn btn-secondary" id="btnCancelGiveUp">Cancel</button>
                <button class="btn btn-danger" id="btnConfirmGiveUp">Give Up</button>
            </div>
        </div>
    </div>
    
    <!-- Modal: Achievements -->
    <div class="modal-overlay" id="achievementsModal">
        <div class="modal-content" style="max-width: 900px;">
            <h2>🏆 Achievements</h2>
            <p style="text-align: center; color: #aaa; margin-bottom: 20px;">
                <span id="achievementStats">0/50 Unlocked</span> | 
                🥉 <span id="bronzeCount">0/25</span> | 
                🥈 <span id="silverCount">0/15</span> | 
                🥇 <span id="goldCount">0/9</span> | 
                💎 <span id="platinumCount">0/1</span>
            </p>
            <div id="achievementsList" class="achievements-grid"></div>
            <button class="close-modal-btn" id="btnCloseAchievements">Close</button>
        </div>
    </div>
    
    <!-- Modal: Soundboard -->
    <div class="modal-overlay" id="soundboardModal">
        <div class="modal-content" style="max-width: 600px;">
            <h2>🎵 Soundboard - Dark Atmospheric Music</h2>
            <p style="color: #aaa; margin-bottom: 20px;">Preview all atmospheric tracks from the game!</p>
            
            <div style="display: grid; gap: 15px;">
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 2px solid #8b7355;">
                    <h3 style="color: #d4af37; margin-bottom: 10px;">🏰 Dark Awakening</h3>
                    <p style="color: #bbb; font-size: 0.9em; margin-bottom: 10px;">Menu Theme - Mysterious, inviting, dark</p>
                    <button class="btn btn-primary" id="btnPlayMenu" style="width: 100%;">▶️ Play</button>
                </div>
                
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 2px solid #8b7355;">
                    <h3 style="color: #d4af37; margin-bottom: 10px;">⚔️ Into the Depths</h3>
                    <p style="color: #bbb; font-size: 0.9em; margin-bottom: 10px;">Gameplay Theme - Tense, adventurous</p>
                    <button class="btn btn-primary" id="btnPlayGameplay" style="width: 100%;">▶️ Play</button>
                </div>
                
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 2px solid #8b7355;">
                    <h3 style="color: #d4af37; margin-bottom: 10px;">🛍️ Merchant's Shadow</h3>
                    <p style="color: #bbb; font-size: 0.9em; margin-bottom: 10px;">Shop Theme - Calm but mysterious</p>
                    <button class="btn btn-primary" id="btnPlayShop" style="width: 100%;">▶️ Play</button>
                </div>
                
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 2px solid #8b7355;">
                    <h3 style="color: #d4af37; margin-bottom: 10px;">👑 Triumph in Darkness</h3>
                    <p style="color: #bbb; font-size: 0.9em; margin-bottom: 10px;">Victory Theme - Epic, celebratory</p>
                    <button class="btn btn-primary" id="btnPlayVictory" style="width: 100%;">▶️ Play</button>
                </div>
                
                <div style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; border: 2px solid #8b7355;">
                    <h3 style="color: #d4af37; margin-bottom: 10px;">💀 The Final Darkness</h3>
                    <p style="color: #bbb; font-size: 0.9em; margin-bottom: 10px;">Defeat Theme - Dark, respectful</p>
                    <button class="btn btn-primary" id="btnPlayDefeat" style="width: 100%;">▶️ Play</button>
                </div>
            </div>
            
            <button class="close-modal-btn" id="btnCloseSoundboard" style="margin-top: 20px;">Close</button>
        </div>
    </div>
    
    <!-- Game Over Overlay (will be created via JS) -->
    
    <!-- ============================================ -->
    <!-- FIREBASE CONFIG (Load before main script)
    <!-- ============================================ -->
    <script src="src/config/firebase-config.js"></script>
    
    <!-- ============================================ -->
    <!-- GAME SCRIPT
    <!-- ============================================ -->
    <script type="module">
        // ============================================
        // FIREBASE IMPORTS
        // ============================================
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, addDoc, collection, query, getDocs, limit, setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // ============================================
        // FIREBASE INITIALIZATION
        // ============================================
        let db, auth, appId, userId;

        try {
            // __firebase_config and __app_id are injected by the environment
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);
            appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            // setLogLevel('debug'); // Useful for debugging
            
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    console.log("Firebase Auth: User signed in:", userId);
                } else {
                    try {
                        const token = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
                        if (token) {
                            await signInWithCustomToken(auth, token);
                        } else {
                            await signInAnonymously(auth);
                        }
                        userId = auth.currentUser?.uid || crypto.randomUUID();
                        console.log("Firebase Auth: New user session:", userId);
                    } catch (error) {
                        console.error("Firebase Auth Error:", error);
                        userId = crypto.randomUUID(); // Fallback
                    }
                }
            });
        } catch (e) {
            console.error("Firebase initialization failed:", e);
            // The game continues offline if Firebase fails
        }
        
        // ============================================
        // OPTIMIZATION HELPERS
        // ============================================
        
        // Storage Cache - Optimizes localStorage operations
        class StorageCache {
            constructor() {
                this.cache = {};
            }
            
            get(key, defaultValue = {}) {
                if (this.cache[key] === undefined) {
                    const data = localStorage.getItem(key);
                    this.cache[key] = data ? JSON.parse(data) : defaultValue;
                }
                return this.cache[key];
            }
            
            set(key, value) {
                this.cache[key] = value;
                localStorage.setItem(key, JSON.stringify(value));
            }
            
            update(key, updater) {
                const current = this.get(key);
                const updated = updater(current);
                this.set(key, updated);
                return updated;
            }
            
            invalidate(key) {
                delete this.cache[key];
            }
            
            clearCache() {
                this.cache = {};
            }
        }
        
        const storage = new StorageCache();
        
        // DOM Helpers - Optimizes DOM manipulations
        function createElementFromHTML(html) {
            const template = document.createElement('template');
            template.innerHTML = html.trim();
            return template.content.firstChild;
        }
        
        function createElementsFragment(items, createItemHTML, attachHandlers = null) {
            const fragment = document.createDocumentFragment();
            
            items.forEach(item => {
                const html = createItemHTML(item);
                const element = createElementFromHTML(html);
                
                if (attachHandlers) {
                    attachHandlers(element, item);
                }
                
                fragment.appendChild(element);
            });
            
            return fragment;
        }
        
        function updateList(container, items, createItemHTML, attachHandlers = null) {
            const fragment = createElementsFragment(items, createItemHTML, attachHandlers);
            container.innerHTML = '';
            container.appendChild(fragment);
        }
        
        // Modal Manager - Simplified modal management
        const modalManager = {
            open(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) modal.classList.add('active');
            },
            close(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) modal.classList.remove('active');
            },
            toggle(modalId) {
                const modal = document.getElementById(modalId);
                if (modal) modal.classList.toggle('active');
            }
        };
        
        console.log('✅ Optimization helpers loaded!');
        
        // ============================================
        // DOM ELEMENTS (NEW STRUCTURE)
        // ============================================
        
        // Screens
        const welcomeScreen = document.getElementById('welcomeScreen');
        const gameWrapper = document.getElementById('gameWrapper');
        
        // Welcome Buttons
        const btnWelcomeStart = document.getElementById('btnWelcomeStart');
        const btnWelcomeTutorial = document.getElementById('btnWelcomeTutorial');
        const btnWelcomeLeaderboard = document.getElementById('btnWelcomeLeaderboard');
        const btnWelcomeUnlocks = document.getElementById('btnWelcomeUnlocks');
        
        // New Game Modal
        const newGameModal = document.getElementById('newGameModal');
        const playerNameInput = document.getElementById('playerNameInput');
        const difficultySelector = document.getElementById('difficultySelector');
        const btnStartGameModal = document.getElementById('btnStartGameModal');
        const btnCancelStart = document.getElementById('btnCancelStart');

        // Game Bars
        const topBar = document.querySelector('.top-bar');
        const centerArea = document.querySelector('.center-area');
        const bottomBar = document.getElementById('room'); // Bottom bar is the room
        
        // Side Panels
        const relicsPanel = document.getElementById('relicsPanel');
        const relicsList = document.getElementById('relicsList');
        const btnOpenShop = document.getElementById('btnOpenShop');
        const holdAreaContainer = document.getElementById('holdAreaContainer');
        const discardPilePreview = document.getElementById('discardPilePreview');
        const gameTimer = document.getElementById('gameTimer');
        
        // Center Stage
        const messageArea = document.getElementById('messageArea');
        const equippedWeaponEl = document.getElementById('equippedWeapon');
        const btnDrawRoom = document.getElementById('btnDrawRoom');
        const btnAvoidRoom = document.getElementById('btnAvoidRoom');
        const mainScoreValue = document.getElementById('mainScoreValue'); // New Score Element
        
        // Top Bar Stats
        const healthEl = document.getElementById('health');
        const goldEl = document.getElementById('goldAmount');
        // scoreEl removed
        const dungeonCountEl = document.getElementById('dungeonCount');
        const statRoomsEl = document.getElementById('statRooms');
        
        // Achievements
        const achievementsCompact = document.getElementById('achievementsCompact');
        const achievementCounter = document.getElementById('achievementCounter');
        const achievementsModal = document.getElementById('achievementsModal');
        const achievementsList = document.getElementById('achievementsList');
        
        // Top Bar Buttons
        const btnTopSound = document.getElementById('btnTopSound');
        const btnMusicPrev = document.getElementById('btnMusicPrev');
        const btnMusicToggle = document.getElementById('btnMusicToggle');
        const btnMusicNext = document.getElementById('btnMusicNext');
        const btnTopTutorial = document.getElementById('btnTopTutorial');
        const btnTopLeaderboard = document.getElementById('btnTopLeaderboard');
        const btnTopUnlocks = document.getElementById('btnTopUnlocks');
        const btnTopGiveUp = document.getElementById('btnTopGiveUp'); // Give Up Button

        // Modals
        const tutorialModal = document.getElementById('tutorialModal');
        const leaderboardModal = document.getElementById('leaderboardModal');
        const shopModal = document.getElementById('shopModal');
        const eventModal = document.getElementById('eventModal');
        const unlocksModal = document.getElementById('unlocksModal');
        const giveUpModal = document.getElementById('giveUpModal'); // Give Up Modal
        
        // Modal Elements
        const shopGoldAmount = document.getElementById('shopGoldAmount');
        const shopItems = document.getElementById('shopItems');
        const eventTitle = document.getElementById('eventTitle');
        const eventText = document.getElementById('eventText');
        const eventChoices = document.getElementById('eventChoices');
        const btnCancelGiveUp = document.getElementById('btnCancelGiveUp'); // Give Up Modal Buttons
        const btnConfirmGiveUp = document.getElementById('btnConfirmGiveUp');
        
        // Close Modals
        document.getElementById('btnCloseTutorial').onclick = () => tutorialModal.classList.remove('active');
        document.getElementById('btnCloseLeaderboard').onclick = () => leaderboardModal.classList.remove('active');
        document.getElementById('btnCloseShop').onclick = () => closeShop(); // Use wrapper
        document.getElementById('btnCloseUnlocks').onclick = () => unlocksModal.classList.remove('active');
        document.getElementById('btnCloseAchievements').onclick = () => achievementsModal.classList.remove('active');
        
        // Open Achievements Modal
        achievementsCompact.onclick = () => {
            updateAchievementsDisplay();
            achievementsModal.classList.add('active');
        };

        // ============================================
        // GAME STATE
        // ============================================
        const game = {
            deck: [],
            relics: [],
            heldCard: null,
            discardPile: [],
            lastActionWasAvoid: false,
            gameOver: false,
            gameTimerInterval: null,
            gameStartTime: null,
            undoAvailable: false,
            lastGameState: null,
            potionsUsed: 0,
            gameOver: false,
            difficulty: 'normal',
            combo: 0,
            score: 0,
            health: 20,
            maxHealth: 20,
            equippedWeapon: null,
            dungeon: [],
            room: [],
            gameStartTime: 0,
            gameTimerInterval: null,
            lastActionWasAvoid: false,
            gold: 0,
            totalGoldEarned: 0,
            relics: [],
            stats: {},
            settings: {
                soundEnabled: true,
                musicEnabled: false
            },
            dodgeActive: false,
            doubleDamage: false,
            berserkStacks: 0,
            mirrorShield: 0,
            obliterateMode: false,
        };

        // Permanent Stats (LocalStorage)
        let permanentStats = {};
        
        // ============================================
        // INITIALIZATION AND SCREEN FLOW LOGIC
        // ============================================

        function showWelcomeScreen() {
            welcomeScreen.style.display = 'flex';
            gameWrapper.classList.remove('active');
            newGameModal.classList.remove('active');
        }

        function showNewGameModal() {
            newGameModal.classList.add('active');
        }

        function showGameUI() {
            welcomeScreen.style.display = 'none';
            newGameModal.classList.remove('active');
            gameWrapper.classList.add('active');
        }
        
        // Welcome Screen Hooks
        btnWelcomeStart.onclick = showNewGameModal;
        btnWelcomeTutorial.onclick = showTutorial;
        btnWelcomeLeaderboard.onclick = showLeaderboard;
        btnWelcomeUnlocks.onclick = openUnlocks;
        
        // Soundboard will be hooked later after music is created
        
        // New Game Modal Hooks
        const nameError = document.getElementById('nameError');
        
        // Clear error on input
        playerNameInput.oninput = () => {
            nameError.style.display = 'none';
            playerNameInput.style.borderColor = '#667eea';
        };
        
        btnStartGameModal.onclick = () => {
            const name = playerNameInput.value.trim();
            if (name.length < 3) {
                nameError.textContent = '❌ Name must have at least 3 characters!';
                nameError.style.display = 'block';
                playerNameInput.style.borderColor = '#ff6b6b';
                playerNameInput.focus();
                return;
            }
            if (name.length > 10) {
                nameError.textContent = '❌ Name must have maximum 10 characters!';
                nameError.style.display = 'block';
                playerNameInput.style.borderColor = '#ff6b6b';
                playerNameInput.focus();
                return;
            }
            startGame();
        };
        btnCancelStart.onclick = () => {
            newGameModal.classList.remove('active');
            nameError.style.display = 'none';
            playerNameInput.style.borderColor = '#667eea';
        };
        
        // FIXED HOOK: Difficulty Selector
        difficultySelector.addEventListener('click', (e) => {
            const target = e.target.closest('.difficulty-btn');
            if (!target) return;
            
            // Remove 'selected' class from all
            difficultySelector.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('selected');
            });
            
            // Add 'selected' class to the clicked one
            target.classList.add('selected');
        });

        // Top Bar Hooks
        btnTopTutorial.onclick = showTutorial;
        btnTopLeaderboard.onclick = showLeaderboard;
        btnTopUnlocks.onclick = openUnlocks;
        btnOpenShop.onclick = openShop;
        
        // Give Up Hooks
        btnTopGiveUp.onclick = () => {
            if (game.gameOver || game.gameStartTime === 0) return; // Don't show if game not running
            giveUpModal.classList.add('active');
        };
        btnCancelGiveUp.onclick = () => giveUpModal.classList.remove('active');
        btnConfirmGiveUp.onclick = () => {
            giveUpModal.classList.remove('active');
            endGame('death', true); // Pass a flag to show 0 score
        };
        
        // FIXED HOOKS: Action Buttons
        btnDrawRoom.onclick = drawRoom;
        btnAvoidRoom.onclick = avoidRoom;
        
        // Undo Button Hook
        const btnUndo = document.getElementById('btnUndo');
        if (btnUndo) {
            btnUndo.onclick = undoLastMove;
        }
        
        // ============================================
        // ORIENTATION DETECTION (Mobile)
        // ============================================
        const orientationWarning = document.getElementById('orientationWarning');
        let orientationDismissed = false;
        
        function checkOrientation() {
            // Only check on mobile devices
            const isMobile = window.innerWidth <= 768;
            const isPortrait = window.innerHeight > window.innerWidth;
            const isGameActive = document.getElementById('gameWrapper').classList.contains('active');
            
            if (isMobile && isPortrait && isGameActive && !orientationDismissed) {
                orientationWarning.classList.add('active');
            } else {
                orientationWarning.classList.remove('active');
            }
        }
        
        // Check on load and orientation change
        window.addEventListener('load', checkOrientation);
        window.addEventListener('resize', checkOrientation);
        window.addEventListener('orientationchange', checkOrientation);
        
        // Allow dismissing the warning by clicking
        orientationWarning.addEventListener('click', () => {
            orientationDismissed = true;
            orientationWarning.classList.remove('active');
        });


        // ============================================
        // ALL GAME CODE (STARTGAME, HANDLECLICK, ETC)
        // ============================================
        
        // Game State (minimum re-declaration)
        game.stats = {
            monstersSlain: 0,
            totalDamage: 0,
            totalHealing: 0,
            roomsCleared: 0,
            weaponsEquipped: 0,
            potionsUsed: 0,
            maxCombo: 0,
            specialsUsed: 0,
            cardsHeld: 0,
            roomsAvoided: 0,
            gamesWon: 0,
            hardWins: 0,
            minimalistWin: false,
            onePunch: false,
            musicWasOn: false
        };
        
        // Special Cards Types
        const specialCards = [
            { id: 'dodge', name: '🛡️ Dodge', description: 'Avoid next damage', effect: () => { game.dodgeActive = true; showMessage('🛡️ Dodge active!', 'success'); createParticles(window.innerWidth / 2, window.innerHeight / 2, '#4ecdc4', 20); } },
            { id: 'double_damage', name: '⚡ Power', description: 'Weapon 2x stronger', effect: () => { game.doubleDamage = true; showMessage('⚡ Power Strike!', 'success'); createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd93d', 25); } },
            { id: 'super_heal', name: '💊 Super Potion', description: 'Heal to full HP', effect: () => { const healed = game.maxHealth - game.health; game.health = game.maxHealth; showDamageNumber(healed, 'heal'); showMessage('💊 HP Full!', 'success'); createParticles(window.innerWidth / 2, window.innerHeight / 2, '#6bcf7f', 30); } },
            { id: 'treasure', name: '💰 Treasure', description: '+5 Max HP', effect: () => { game.maxHealth += 5; game.health += 5; showDamageNumber('+5 MAX', 'heal'); showMessage('💰 Max HP increased!', 'success'); createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd700', 35); } },
            
            // 🆕 NOVAS CARTAS ESPECIAIS
            { id: 'berserker', name: '🔥 Berserk', description: 'Next 3 attacks +5 damage', effect: () => { 
                game.berserkStacks = 3; 
                showMessage('🔥 BERSERK MODE! Next 3 attacks +5 damage!', 'success'); 
                playSound('special');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff6b6b', 40);
                
                // Track berserk use for achievement
                const saved = localStorage.getItem('scoundrel_lifetime_stats');
                let lifetimeStats = saved ? JSON.parse(saved) : {};
                lifetimeStats.berserkUses = (lifetimeStats.berserkUses || 0) + 1;
                localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
            } },
            { id: 'time_warp', name: '⏰ Time Warp', description: 'Draw 2 extra cards this room', effect: () => {
                if (game.dungeon.length >= 2) {
                    const extraCards = game.dungeon.splice(0, 2);
                    game.room.push(...extraCards);
                    showMessage('⏰ Time Warp! +2 cards drawn!', 'success');
                    playSound('cardDraw');
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, '#a8edea', 30);
                    updateUI();
                    
                    // Track time warp use for achievement
                    const saved = localStorage.getItem('scoundrel_lifetime_stats');
                    let lifetimeStats = saved ? JSON.parse(saved) : {};
                    lifetimeStats.timeWarps = (lifetimeStats.timeWarps || 0) + 1;
                    localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
                } else {
                    showMessage('⏰ Time Warp! Not enough cards in deck!', 'warning');
                }
            } },
            { id: 'card_destroy', name: '💥 Obliterate', description: 'Remove a card permanently', effect: () => {
                if (game.room.length > 0) {
                    showMessage('💥 Choose a card to OBLITERATE (left-click)!', 'warning');
                    game.obliterateMode = true;
                    playSound('special');
                } else {
                    showMessage('💥 No cards to obliterate!', 'warning');
                }
            } },
            { id: 'lucky_draw', name: '🎲 Lucky Draw', description: 'Draw until you get a weapon', effect: () => {
                let drawnCards = [];
                let foundWeapon = false;
                let attempts = 0;
                const maxAttempts = Math.min(10, game.dungeon.length);
                
                while (!foundWeapon && attempts < maxAttempts && game.dungeon.length > 0) {
                    const card = game.dungeon.shift();
                    drawnCards.push(card);
                    attempts++;
                    if (card.suitName === 'diamonds') {
                        foundWeapon = true;
                    }
                }
                
                game.room.push(...drawnCards);
                
                if (foundWeapon) {
                    showMessage(`🎲 Lucky Draw! Found weapon in ${attempts} cards!`, 'success');
                    earnGold(5);
                } else {
                    showMessage('🎲 Lucky Draw! No weapon found, but +10 gold!', 'info');
                    earnGold(10);
                }
                
                playSound('cardDraw');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd93d', 25);
                updateUI();
            } },
            { id: 'mirror_shield', name: '🪞 Mirror', description: 'Reflect next 10 damage (this dungeon only)', effect: () => {
                game.mirrorShield = 10;
                showMessage('🪞 Mirror Shield! Next 10 damage reflected!', 'success');
                playSound('special');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#a8edea', 35);
            } },
            { id: 'gamble', name: '🎰 Gamble', description: '50% chance: +10 HP or -5 HP', effect: () => {
                const win = Math.random() < 0.5;
                if (win) {
                    const heal = Math.min(10, game.maxHealth - game.health);
                    game.health = Math.min(game.maxHealth, game.health + 10);
                    showDamageNumber(heal, 'heal');
                    showMessage('🎰 JACKPOT! +10 HP!', 'success');
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, '#6bcf7f', 50);
                } else {
                    game.health = Math.max(1, game.health - 5);
                    showDamageNumber(5, 'damage');
                    showMessage('🎰 Bad luck... -5 HP!', 'danger');
                    screenShake();
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff6b6b', 30);
                }
                playSound('special');
                updateUI();
                
                // Track gamble use for achievement
                const saved = localStorage.getItem('scoundrel_lifetime_stats');
                let lifetimeStats = saved ? JSON.parse(saved) : {};
                lifetimeStats.gambleCards = (lifetimeStats.gambleCards || 0) + 1;
                localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
            } }
        ];
        
        // Card suits and values
        const suits = {'♠': 'spades', '♣': 'clubs', '♥': 'hearts', '♦': 'diamonds'};
        const values = ['2', '3', '4', '5', '6', '7', '8', '9', '10'];

        // ===== 50 ACHIEVEMENTS SYSTEM =====
        const ACHIEVEMENTS = [
            // 🥉 BRONZE (25) - Fáceis
            { id: 'first_blood', tier: 'bronze', icon: '⚔️', title: 'First Blood', description: 'Defeat your first monster', check: () => getLifetimeStat('monstersSlain') >= 1 },
            { id: 'baby_steps', tier: 'bronze', icon: '👶', title: 'Baby Steps', description: 'Clear your first room', check: () => getLifetimeStat('roomsCleared') >= 1 },
            { id: 'armed', tier: 'bronze', icon: '🗡️', title: 'Armed & Ready', description: 'Equip your first weapon', check: () => getLifetimeStat('weaponsEquipped') >= 1 },
            { id: 'healer', tier: 'bronze', icon: '💊', title: 'Healer', description: 'Use your first potion', check: () => getLifetimeStat('potionsUsed') >= 1 },
            { id: 'gold_digger', tier: 'bronze', icon: '💰', title: 'Gold Digger', description: 'Earn 100 gold (lifetime)', check: () => getLifetimeStat('totalGoldEarned') >= 100 },
            { id: 'shopper', tier: 'bronze', icon: '🛒', title: 'Window Shopper', description: 'Open the shop for the first time', check: () => getLifetimeStat('shopsVisited') >= 1 },
            { id: 'combo_starter', tier: 'bronze', icon: '🔥', title: 'Combo Starter', description: 'Get a 3x combo', check: () => getLifetimeStat('maxCombo') >= 3 },
            { id: 'monster_slayer', tier: 'bronze', icon: '⚔️', title: 'Monster Slayer', description: 'Defeat 10 monsters', check: () => getLifetimeStat('monstersSlain') >= 10 },
            { id: 'room_clearer', tier: 'bronze', icon: '🏰', title: 'Room Clearer', description: 'Clear 5 rooms', check: () => getLifetimeStat('roomsCleared') >= 5 },
            { id: 'warrior', tier: 'bronze', icon: '⚔️', title: 'Warrior', description: 'Equip 5 different weapons', check: () => getLifetimeStat('weaponsEquipped') >= 5 },
            { id: 'healthy', tier: 'bronze', icon: '💚', title: 'Healthy', description: 'Use 5 potions (lifetime)', check: () => getLifetimeStat('potionsUsed') >= 5 },
            { id: 'rich', tier: 'bronze', icon: '💎', title: 'Getting Rich', description: 'Earn 500 gold (lifetime)', check: () => getLifetimeStat('totalGoldEarned') >= 500 },
            { id: 'special_user', tier: 'bronze', icon: '✨', title: 'Special Forces', description: 'Use 3 special cards', check: () => getLifetimeStat('specialsUsed') >= 3 },
            { id: 'survivor', tier: 'bronze', icon: '❤️', title: 'Survivor', description: 'Complete a run with less than 5 HP', check: () => false }, // Checked during game
            { id: 'avoidance', tier: 'bronze', icon: '🚪', title: 'Avoidance', description: 'Avoid 3 dungeons (lifetime)', check: () => getLifetimeStat('roomsAvoided') >= 3 },
            { id: 'collector', tier: 'bronze', icon: '🔮', title: 'Collector', description: 'Have 3 relics in a single run', check: () => false }, // Checked during game
            { id: 'hoarder', tier: 'bronze', icon: '📌', title: 'Card Hoarder', description: 'Use hold mechanic 10 times', check: () => getLifetimeStat('cardsHeld') >= 10 },
            { id: 'easy_win', tier: 'bronze', icon: '🟢', title: 'Easy Victory', description: 'Win a game on Easy difficulty', check: () => getLifetimeStat('easyWins') >= 1 },
            { id: 'first_win', tier: 'bronze', icon: '🏆', title: 'First Victory', description: 'Win your first game', check: () => getLifetimeStat('gamesWon') >= 1 },
            { id: 'adventurer', tier: 'bronze', icon: '🗺️', title: 'Adventurer', description: 'Clear 20 rooms (lifetime)', check: () => getLifetimeStat('roomsCleared') >= 20 },
            { id: 'music_lover', tier: 'bronze', icon: '🎵', title: 'Music Lover', description: 'Win a game with music ON', check: () => false }, // Checked during game
            { id: 'gambler', tier: 'bronze', icon: '🎰', title: 'Gambler', description: 'Use the Gamble card 5 times', check: () => getLifetimeStat('gambleCards') >= 5 },
            { id: 'destroyer', tier: 'bronze', icon: '💥', title: 'Destroyer', description: 'Obliterate 3 cards (lifetime)', check: () => getLifetimeStat('cardsObliterated') >= 3 },
            { id: 'time_traveler', tier: 'bronze', icon: '⏰', title: 'Time Traveler', description: 'Use Time Warp card', check: () => getLifetimeStat('timeWarps') >= 1 },
            { id: 'berserker', tier: 'bronze', icon: '🔥', title: 'Berserker', description: 'Use Berserk mode 3 times', check: () => getLifetimeStat('berserkUses') >= 3 },
            
            // 🥈 SILVER (15) - Médias
            { id: 'veteran', tier: 'silver', icon: '🎖️', title: 'Veteran', description: 'Win 5 games', check: () => getLifetimeStat('gamesWon') >= 5 },
            { id: 'massacre', tier: 'silver', icon: '⚔️', title: 'Massacre', description: 'Defeat 50 monsters', check: () => getLifetimeStat('monstersSlain') >= 50 },
            { id: 'dungeon_master', tier: 'silver', icon: '🏰', title: 'Dungeon Master', description: 'Clear 50 rooms', check: () => getLifetimeStat('roomsCleared') >= 50 },
            { id: 'normal_win', tier: 'silver', icon: '🟡', title: 'Normal Victory', description: 'Win on Normal difficulty', check: () => getLifetimeStat('normalWins') >= 1 },
            { id: 'combo_master', tier: 'silver', icon: '🔥', title: 'Combo Master', description: 'Get a 7x combo', check: () => getLifetimeStat('maxCombo') >= 7 },
            { id: 'wealthy', tier: 'silver', icon: '💰', title: 'Wealthy', description: 'Earn 2000 gold (lifetime)', check: () => getLifetimeStat('totalGoldEarned') >= 2000 },
            { id: 'relic_hunter', tier: 'silver', icon: '🔮', title: 'Relic Hunter', description: 'Have 5 relics in a single run', check: () => false }, // Checked during game
            { id: 'arsenal', tier: 'silver', icon: '⚔️', title: 'Arsenal', description: 'Equip 25 weapons (lifetime)', check: () => getLifetimeStat('weaponsEquipped') >= 25 },
            { id: 'pharmacist', tier: 'silver', icon: '💊', title: 'Pharmacist', description: 'Use 25 potions (lifetime)', check: () => getLifetimeStat('potionsUsed') >= 25 },
            { id: 'special_ops', tier: 'silver', icon: '✨', title: 'Special Ops', description: 'Use 15 special cards', check: () => getLifetimeStat('specialsUsed') >= 15 },
            { id: 'speedrun', tier: 'silver', icon: '⏱️', title: 'Speedrunner', description: 'Win a game in under 10 minutes', check: () => false }, // Checked during game
            { id: 'iron_will', tier: 'silver', icon: '💪', title: 'Iron Will', description: 'Win with exactly 1 HP', check: () => false }, // Checked during game
            { id: 'perfect_run', tier: 'silver', icon: '✨', title: 'Perfect Run', description: 'Clear 10 rooms with 10x combo', check: () => false }, // Checked during game
            { id: 'shopaholic', tier: 'silver', icon: '🛍️', title: 'Shopaholic', description: 'Buy 30 items from shop (lifetime)', check: () => getLifetimeStat('itemsBought') >= 30 },
            { id: 'event_master', tier: 'silver', icon: '🎲', title: 'Event Master', description: 'Complete 20 events', check: () => getLifetimeStat('eventsCompleted') >= 20 },
            
            // 🥇 GOLD (9) - Difíceis (5 secretas)
            { id: 'legend', tier: 'gold', icon: '👑', title: 'Legend', description: 'Win 10 games', check: () => getLifetimeStat('gamesWon') >= 10 },
            { id: 'hard_win', tier: 'gold', icon: '🔴', title: 'Hard Victory', description: 'Win on Hard difficulty', check: () => getLifetimeStat('hardWins') >= 1 },
            { id: 'genocide', tier: 'gold', icon: '☠️', title: 'Genocide', description: 'Defeat 200 monsters', check: () => getLifetimeStat('monstersSlain') >= 200 },
            { id: 'conqueror', tier: 'gold', icon: '🏆', title: 'Conqueror', description: 'Clear 100 rooms', check: () => getLifetimeStat('roomsCleared') >= 100 },
            
            // 🔒 SECRET GOLDS (5)
            { id: 'secret_1', tier: 'gold', icon: '🎯', title: 'One Shot Wonder', description: 'Defeat a 10-value monster with a 2-value weapon', check: () => false, secret: true },
            { id: 'secret_2', tier: 'gold', icon: '🍀', title: 'Lucky 7', description: 'Win with exactly 7 HP, 7 cards left, and 777 score', check: () => false, secret: true },
            { id: 'secret_3', tier: 'gold', icon: '🎰', title: 'High Roller', description: 'Win 10 Gamble cards in a row', check: () => false, secret: true },
            { id: 'secret_4', tier: 'gold', icon: '💎', title: 'Minimalist', description: 'Win with only 1 relic', check: () => false, secret: true },
            { id: 'secret_5', tier: 'gold', icon: '🌟', title: 'Untouchable', description: 'Win without taking any damage', check: () => false, secret: true },
            
            // 💎 PLATINUM (1) - Todas as outras
            { id: 'platinum', tier: 'platinum', icon: '💎', title: 'Master Scoundrel', description: 'Unlock ALL other achievements', check: () => {
                const unlockedAchs = JSON.parse(localStorage.getItem('dungeon_scoundrel_achievements') || '[]');
                return unlockedAchs.length >= 49; // All except platinum itself
            }}
        ];

        // ===== ADVANCED SOUND EFFECTS SYSTEM =====
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        // Master gain for all sound effects
        const sfxMasterGain = audioContext.createGain();
        sfxMasterGain.connect(audioContext.destination);
        sfxMasterGain.gain.value = 0.3;

        const soundEffects = {
            cardDraw: (ctx, time) => {
                for (let i = 0; i < 8; i++) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.value = 200 + Math.random() * 400;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + (i * 0.03);
                    gain.gain.setValueAtTime(0.03, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.05);
                    osc.start(startTime);
                    osc.stop(startTime + 0.05);
                }
            },
            cardFlip: (ctx, time) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(600, time);
                osc.frequency.exponentialRampToValueAtTime(800, time + 0.1);
                osc.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.15, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
                osc.start(time);
                osc.stop(time + 0.15);
            },
            attack: (ctx, time) => {
                const noise = ctx.createBufferSource();
                const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) { data[i] = (Math.random() * 2 - 1) * (1 - i / data.length); }
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 1000;
                const gain = ctx.createGain();
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.2, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
                const clang = ctx.createOscillator();
                const clangGain = ctx.createGain();
                clang.type = 'square';
                clang.frequency.value = 800;
                clang.connect(clangGain);
                clangGain.connect(sfxMasterGain);
                clangGain.gain.setValueAtTime(0.15, time + 0.1);
                clangGain.gain.exponentialRampToValueAtTime(0.001, time + 0.25);
                noise.start(time);
                clang.start(time + 0.1);
                clang.stop(time + 0.25);
            },
            damage: (ctx, time) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(50, time + 0.4);
                osc.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.3, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.4);
                osc.start(time);
                osc.stop(time + 0.4);
                const crack = ctx.createOscillator();
                const crackGain = ctx.createGain();
                crack.type = 'square';
                crack.frequency.value = 200;
                crack.connect(crackGain);
                crackGain.connect(sfxMasterGain);
                crackGain.gain.setValueAtTime(0.1, time + 0.05);
                crackGain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
                crack.start(time + 0.05);
                crack.stop(time + 0.15);
            },
            heal: (ctx, time) => {
                const notes = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + (i * 0.08);
                    gain.gain.setValueAtTime(0.1, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);
                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                });
            },
            equip: (ctx, time) => {
                const osc1 = ctx.createOscillator();
                const osc2 = ctx.createOscillator();
                const gain = ctx.createGain();
                osc1.type = 'square';
                osc2.type = 'square';
                osc1.frequency.value = 400;
                osc2.frequency.value = 600;
                osc1.connect(gain);
                osc2.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.15, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
                osc1.start(time);
                osc2.start(time);
                osc1.stop(time + 0.2);
                osc2.stop(time + 0.2);
            },
            hold: (ctx, time) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(400, time);
                osc.frequency.exponentialRampToValueAtTime(600, time + 0.1);
                osc.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.2, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.15);
                osc.start(time);
                osc.stop(time + 0.15);
            },
            special: (ctx, time) => {
                for (let i = 0; i < 6; i++) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = 800 + (i * 200) + (Math.random() * 100);
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + (i * 0.05);
                    gain.gain.setValueAtTime(0.08, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);
                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                }
            },
            combo: (ctx, time) => {
                const chord = [659.25, 783.99, 987.77]; // E5, G5, B5
                chord.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    gain.gain.setValueAtTime(0.12, time);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.4);
                    osc.start(time);
                    osc.stop(time + 0.4);
                });
            },
            roomClear: (ctx, time) => {
                const melody = [523.25, 659.25, 783.99]; // C5, E5, G5
                melody.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + (i * 0.12);
                    gain.gain.setValueAtTime(0.15, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.3);
                    osc.start(startTime);
                    osc.stop(startTime + 0.3);
                });
            },
            avoid: (ctx, time) => {
                const noise = ctx.createBufferSource();
                const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.4, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) { data[i] = (Math.random() * 2 - 1) * (1 - i / data.length); }
                noise.buffer = buffer;
                const filter = ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(2000, time);
                filter.frequency.exponentialRampToValueAtTime(200, time + 0.4);
                const gain = ctx.createGain();
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.2, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.4);
                noise.start(time);
            },
            victory: (ctx, time) => {
                const fanfare = [{freq: 523.25, start: 0}, {freq: 659.25, start: 0.15}, {freq: 783.99, start: 0.3}, {freq: 1046.50, start: 0.45}];
                fanfare.forEach(note => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = note.freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + note.start;
                    gain.gain.setValueAtTime(0.2, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);
                    osc.start(startTime);
                    osc.stop(startTime + 0.5);
                });
            },
            defeat: (ctx, time) => {
                const descent = [{freq: 493.88, start: 0}, {freq: 440.00, start: 0.2}, {freq: 392.00, start: 0.4}, {freq: 293.66, start: 0.6}];
                descent.forEach(note => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'triangle';
                    osc.frequency.value = note.freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + note.start;
                    gain.gain.setValueAtTime(0.15, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.6);
                    osc.start(startTime);
                    osc.stop(startTime + 0.6);
                });
            },
            start: (ctx, time) => {
                const notes = [523.25, 659.25, 783.99]; // C5, E5, G5
                notes.forEach((freq, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'sine';
                    osc.frequency.value = freq;
                    osc.connect(gain);
                    gain.connect(sfxMasterGain);
                    const startTime = time + (i * 0.1);
                    gain.gain.setValueAtTime(0.12, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);
                    osc.start(startTime);
                    osc.stop(startTime + 0.5);
                });
            },
            error: (ctx, time) => {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.type = 'sawtooth';
                osc.frequency.value = 150;
                osc.connect(gain);
                gain.connect(sfxMasterGain);
                gain.gain.setValueAtTime(0.2, time);
                gain.gain.setValueAtTime(0, time + 0.1);
                gain.gain.setValueAtTime(0.2, time + 0.2);
                gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
                osc.start(time);
                osc.stop(time + 0.3);
            }
        };

        // Unified playSound function
        function playSound(soundName) {
            if (!game.settings.soundEnabled || !audioContext) return;
            const soundFn = soundEffects[soundName];
            if (!soundFn) {
                console.warn('Sound not found:', soundName);
                return;
            }
            try {
                const time = audioContext.currentTime;
                soundFn(audioContext, time);
            } catch (e) {
                // console.warn("Audio context error", e);
            }
        }
        
        // ============================================
// DARK ATMOSPHERIC MUSIC SYSTEM
// ============================================
// Substitui Epic8BitMusic por atmosfera dark medieval
// Inspirado em Heretic, Zelda, Diablo

class DarkAtmosphericMusic {
    constructor() {
        this.context = audioContext;
        this.masterGain = this.context.createGain();
        this.masterGain.connect(this.context.destination);
        this.masterGain.gain.value = 0.15; // Mais baixo que 8-bit
        
        this.isPlaying = false;
        this.currentContext = 'menu'; // menu, gameplay, shop, victory, defeat
        this.oscillators = [];
        this.intervals = [];
        this.gainNodes = [];
        
        this.contextNames = {
            menu: '🏰 Dark Awakening',
            gameplay: '⚔️ Into the Depths',
            shop: '🛍️ Merchant\'s Shadow',
            victory: '👑 Triumph in Darkness',
            defeat: '💀 The Final Darkness'
        };
    }
    
    getCurrentTrackName() {
        return this.contextNames[this.currentContext];
    }
    
    start() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.playContext(this.currentContext);
        this.updateNowPlayingDisplay();
    }
    
    stop() {
        this.isPlaying = false;
        this.stopAll();
        this.updateNowPlayingDisplay();
    }
    
    stopAll() {
        this.oscillators.forEach(osc => { try { osc.stop(); } catch(e) {} });
        this.intervals.forEach(id => clearInterval(id));
        this.oscillators = [];
        this.intervals = [];
        this.gainNodes = [];
    }
    
    // Sistema de troca automática de contexto
    switchContext(newContext) {
        if (this.currentContext === newContext) return;
        console.log(`🎵 Music: ${this.currentContext} → ${newContext}`);
        
        this.currentContext = newContext;
        
        if (this.isPlaying) {
            this.fadeOut(0.5, () => {
                this.stopAll();
                this.playContext(newContext);
                this.fadeIn(0.5);
            });
        }
        
        this.updateNowPlayingDisplay();
    }
    
    fadeOut(duration, callback) {
        this.masterGain.gain.exponentialRampToValueAtTime(
            0.001,
            this.context.currentTime + duration
        );
        setTimeout(callback, duration * 1000);
    }
    
    fadeIn(duration) {
        this.masterGain.gain.setValueAtTime(0.001, this.context.currentTime);
        this.masterGain.gain.exponentialRampToValueAtTime(
            0.15,
            this.context.currentTime + duration
        );
    }
    
    playContext(context) {
        switch(context) {
            case 'menu': this.playMenuTheme(); break;
            case 'gameplay': this.playGameplayTheme(); break;
            case 'shop': this.playShopTheme(); break;
            case 'victory': this.playVictoryTheme(); break;
            case 'defeat': this.playDefeatTheme(); break;
        }
    }
    
    updateNowPlayingDisplay() {
        const display = document.getElementById('nowPlayingDisplay');
        if (display) {
            display.textContent = this.isPlaying ? 
                this.getCurrentTrackName() : 
                '🎵 Music Paused';
        }
    }
    
    // ============================================
    // TRACK 1: MENU THEME - Dark Awakening
    // ============================================
    playMenuTheme() {
        // Drone grave contínuo (80 Hz)
        this.playDrone(80, 0.20, 'sine');
        this.playDrone(120, 0.15, 'triangle'); // Harmônico
        
        // Pad atmosférico dark
        this.playAtmosphericPad([196, 246.94, 293.66], 0.08); // G3, B3, D4 (menor)
        
        // Bells medievais espaçados (a cada 4 segundos)
        const bellPattern = [523.25, 392, 493.88, 440]; // C5, G4, B4, A4
        let bellIndex = 0;
        const bellTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playBell(bellPattern[bellIndex % bellPattern.length], 0.08, 2.0);
            bellIndex++;
        }, 4000);
        this.intervals.push(bellTimer);
    }
    
    // ============================================
    // TRACK 2: GAMEPLAY THEME - Into the Depths
    // ============================================
    playGameplayTheme() {
        // Drone + Bass pulsante (90 Hz, 2 batidas por segundo)
        this.playDrone(90, 0.18, 'sine');
        
        const bassInterval = 500; // 120 BPM = 500ms
        const bassPattern = [90, 90, 135, 90]; // Tônica, tônica, quinta, tônica
        let bassIndex = 0;
        const bassTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playPercussiveBass(bassPattern[bassIndex % bassPattern.length], 0.22, 0.15);
            bassIndex++;
        }, bassInterval);
        this.intervals.push(bassTimer);
        
        // Melodia menor misteriosa (escala frígia de E)
        const melody = [164.81, 174.61, 196, 220, 246.94, 261.63, 293.66]; // E, F, G, A, B, C, D
        const melPattern = [4, 3, 2, 0, 2, 3, 4, 2]; // Padrão misterioso
        let melIndex = 0;
        const melInterval = 1000;
        const melTimer = setInterval(() => {
            if (!this.isPlaying) return;
            const freq = melody[melPattern[melIndex % melPattern.length]];
            this.playNote(freq * 2, 0.10, 0.8, 'triangle');
            melIndex++;
        }, melInterval);
        this.intervals.push(melTimer);
        
        // Percussão dark sutil
        this.playDarkPercussion(bassInterval * 2);
    }
    
    // ============================================
    // TRACK 3: SHOP THEME - Merchant's Shadow
    // ============================================
    playShopTheme() {
        // Drone mais enérgico
        this.playDrone(110, 0.14, 'sine');
        
        // Bass rítmico (dá movimento)
        const bassPattern = [110, 110, 165, 110]; // Root, root, fifth, root
        let bassIndex = 0;
        const bassInterval = 400; // Mais rápido
        const bassTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playPercussiveBass(bassPattern[bassIndex % bassPattern.length], 0.16, 0.12);
            bassIndex++;
        }, bassInterval);
        this.intervals.push(bassTimer);
        
        // Arpejos medievais com ritmo
        const arpNotes = [261.63, 329.63, 392, 493.88]; // C4, E4, G4, B4
        let arpIndex = 0;
        const arpInterval = 400; // Mais rápido (sincronizado com bass)
        const arpTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playNote(arpNotes[arpIndex % arpNotes.length] * 2, 0.10, 0.35, 'triangle');
            arpIndex++;
        }, arpInterval);
        this.intervals.push(arpTimer);
        
        // Bells com mais presença e ritmo
        const bellPattern = [523.25, 659.25, 783.99, 659.25]; // C5, E5, G5, E5
        let bellIndex = 0;
        const bellTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playBell(bellPattern[bellIndex % bellPattern.length], 0.12, 1.2);
            bellIndex++;
        }, 1600); // Mais frequente
        this.intervals.push(bellTimer);
        
        // Percussão sutil para ritmo
        const percTimer = setInterval(() => {
            if (!this.isPlaying) return;
            this.playDarkPercussion(800);
        }, 800);
        this.intervals.push(percTimer);
    }
    
    // ============================================
    // TRACK 4: VICTORY THEME - Triumph in Darkness
    // ============================================
    playVictoryTheme() {
        // Fanfarra épica ascendente e empolgante
        const fanfare = [
            {freq: 261.63, time: 0, duration: 0.3},      // C4
            {freq: 329.63, time: 0.3, duration: 0.3},    // E4
            {freq: 392, time: 0.6, duration: 0.3},       // G4
            {freq: 523.25, time: 0.9, duration: 0.5},    // C5
            {freq: 659.25, time: 1.5, duration: 0.4},    // E5
            {freq: 783.99, time: 2.0, duration: 1.0},    // G5 (final triunfante!)
        ];
        
        fanfare.forEach(note => {
            setTimeout(() => {
                if (!this.isPlaying) return;
                this.playNote(note.freq, 0.20, note.duration, 'square');
                this.playNote(note.freq * 2, 0.12, note.duration, 'triangle');
                this.playBell(note.freq, 0.08, note.duration * 2);
                // Percussão triunfante e rápida
                this.playDarkPercussion(80);
            }, note.time * 1000);
        });
        
        // Arpejo final celebratório
        const arpeggio = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6
        arpeggio.forEach((freq, index) => {
            setTimeout(() => {
                if (!this.isPlaying) return;
                this.playNote(freq, 0.15, 0.3, 'sine');
            }, (3000 + index * 150));
        });
        
        // Drone victorioso
        setTimeout(() => {
            if (!this.isPlaying) return;
            this.playDrone(523.25, 0.12, 'triangle');
        }, 2000);
    }
    
    // ============================================
    // TRACK 5: DEFEAT THEME - The Final Darkness
    // ============================================
    playDefeatTheme() {
        // Descida cromática sombria
        const descent = [
            {freq: 293.66, time: 0},    // D4
            {freq: 277.18, time: 0.6},  // C#4
            {freq: 261.63, time: 1.2},  // C4
            {freq: 246.94, time: 1.8},  // B3
            {freq: 220, time: 2.4},     // A3
        ];
        
        descent.forEach(note => {
            setTimeout(() => {
                if (!this.isPlaying) return;
                this.playNote(note.freq, 0.15, 0.8, 'sine');
            }, note.time * 1000);
        });
        
        // Bells fúnebres
        setTimeout(() => {
            if (!this.isPlaying) return;
            this.playBell(523.25, 0.08, 3.0); // C5
        }, 1000);
        
        setTimeout(() => {
            if (!this.isPlaying) return;
            this.playBell(392, 0.08, 3.0); // G4
        }, 2000);
        
        // Fade to silence
        setTimeout(() => {
            this.fadeOut(2.0, () => {});
        }, 3000);
    }
    
    // ============================================
    // HELPER FUNCTIONS
    // ============================================
    
    playDrone(freq, volume, waveType = 'sine') {
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        const filter = this.context.createBiquadFilter();
        
        osc.type = waveType;
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = freq * 4; // Filtro suave
        filter.Q.value = 1;
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        gain.gain.setValueAtTime(0, this.context.currentTime);
        gain.gain.exponentialRampToValueAtTime(volume, this.context.currentTime + 1.0);
        
        osc.start(this.context.currentTime);
        
        this.oscillators.push(osc);
        this.gainNodes.push(gain);
    }
    
    playNote(freq, volume, duration, waveType = 'sine') {
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        const reverb = this.context.createConvolver();
        
        // Criar impulse response simples para reverb
        const reverbTime = 2.0;
        const reverbDecay = 2.0;
        const sampleRate = this.context.sampleRate;
        const length = sampleRate * reverbTime;
        const impulse = this.context.createBuffer(2, length, sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
            const channelData = impulse.getChannelData(channel);
            for (let i = 0; i < length; i++) {
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, reverbDecay);
            }
        }
        reverb.buffer = impulse;
        
        osc.type = waveType;
        osc.frequency.value = freq;
        
        osc.connect(gain);
        gain.connect(reverb);
        reverb.connect(this.masterGain);
        
        const now = this.context.currentTime;
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        
        osc.start(now);
        osc.stop(now + duration);
        
        this.oscillators.push(osc);
    }
    
    playBell(freq, volume, duration) {
        // Bell com harmônicos
        const harmonics = [1, 2.76, 5.4, 8.93]; // Proporções de sino
        
        harmonics.forEach((harmonic, index) => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = freq * harmonic;
            
            osc.connect(gain);
            gain.connect(this.masterGain);
            
            const now = this.context.currentTime;
            const vol = volume / (index + 1); // Harmônicos mais baixos
            gain.gain.setValueAtTime(vol, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            osc.start(now);
            osc.stop(now + duration);
            
            this.oscillators.push(osc);
        });
    }
    
    playPercussiveBass(freq, volume, duration) {
        const osc = this.context.createOscillator();
        const gain = this.context.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, this.context.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq * 0.5, this.context.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        
        const now = this.context.currentTime;
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
        
        osc.start(now);
        osc.stop(now + duration);
        
        this.oscillators.push(osc);
    }
    
    playAtmosphericPad(freqs, volume) {
        freqs.forEach(freq => {
            const osc = this.context.createOscillator();
            const gain = this.context.createGain();
            const filter = this.context.createBiquadFilter();
            
            osc.type = 'sawtooth';
            osc.frequency.value = freq;
            
            filter.type = 'lowpass';
            filter.frequency.value = freq * 2;
            filter.Q.value = 0.7;
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.masterGain);
            
            gain.gain.setValueAtTime(0, this.context.currentTime);
            gain.gain.linearRampToValueAtTime(volume, this.context.currentTime + 2.0);
            
            osc.start(this.context.currentTime);
            
            this.oscillators.push(osc);
        });
    }
    
    playDarkPercussion(interval) {
        const percTimer = setInterval(() => {
            if (!this.isPlaying) return;
            
            // Kick drum grave
            const kick = this.context.createOscillator();
            const kickGain = this.context.createGain();
            
            kick.frequency.setValueAtTime(150, this.context.currentTime);
            kick.frequency.exponentialRampToValueAtTime(40, this.context.currentTime + 0.1);
            
            kick.connect(kickGain);
            kickGain.connect(this.masterGain);
            
            kickGain.gain.setValueAtTime(0.15, this.context.currentTime);
            kickGain.gain.exponentialRampToValueAtTime(0.001, this.context.currentTime + 0.1);
            
            kick.start(this.context.currentTime);
            kick.stop(this.context.currentTime + 0.1);
        }, interval);
        
        this.intervals.push(percTimer);
    }
    
    // Métodos de compatibilidade com código existente
    nextTrack() {
        // No sistema novo, não há "next track" manual
        // Mas mantém compatibilidade
        playSound('cardFlip');
    }
    
    prevTrack() {
        // Compatibilidade
        playSound('cardFlip');
    }
}
        const music = new DarkAtmosphericMusic();

        // Sound/Music Hooks
        btnTopSound.onclick = function() {
            game.settings.soundEnabled = !game.settings.soundEnabled;
            this.classList.toggle('active', game.settings.soundEnabled);
            this.textContent = game.settings.soundEnabled ? '🔊' : '🔇';
            if (game.settings.soundEnabled) playSound('cardFlip');
        };
        btnMusicToggle.onclick = function() {
            game.settings.musicEnabled = !game.settings.musicEnabled;
            this.classList.toggle('active', game.settings.musicEnabled);
            this.textContent = game.settings.musicEnabled ? '⏸️' : '⏯️';

            if (game.settings.musicEnabled) {
                music.start();
            } else {
                music.stop();
            }
        };
        
        // Music Volume Control (Gameplay)
        const musicVolumeSlider = document.getElementById('musicVolume');
        if (musicVolumeSlider) {
            musicVolumeSlider.oninput = (e) => {
                const volume = e.target.value / 100;
                music.masterGain.gain.value = volume;
            };
        }

        // Welcome Screen Music Controls (AFTER music is created)
        const btnWelcomeMusicToggle = document.getElementById('btnWelcomeMusicToggle');
        const btnWelcomeSoundboard = document.getElementById('btnWelcomeSoundboard');
        
        // Update music button visual
        function updateWelcomeMusicButton() {
            if (btnWelcomeMusicToggle) {
                btnWelcomeMusicToggle.textContent = music.isPlaying ? '⏸️' : '⏯️';
                btnWelcomeMusicToggle.style.opacity = music.isPlaying ? '1' : '0.7';
            }
            
            // Update now playing display
            music.updateNowPlayingDisplay();
        }
        
        if (btnWelcomeMusicToggle) {
            btnWelcomeMusicToggle.onclick = () => {
                game.settings.musicEnabled = !game.settings.musicEnabled;
                if (game.settings.musicEnabled) {
                    music.start();
                } else {
                    music.stop();
                }
                updateWelcomeMusicButton();
                playSound('click');
            };
        }
        
        // Music Volume Control (Welcome Screen)
        const welcomeMusicVolumeSlider = document.getElementById('welcomeMusicVolume');
        if (welcomeMusicVolumeSlider) {
            welcomeMusicVolumeSlider.oninput = (e) => {
                const volume = e.target.value / 100;
                music.masterGain.gain.value = volume;
                // Sync with gameplay slider
                if (musicVolumeSlider) musicVolumeSlider.value = e.target.value;
            };
        }
        
        // Soundboard Modal
        const soundboardModal = document.getElementById('soundboardModal');
        const btnCloseSoundboard = document.getElementById('btnCloseSoundboard');
        
        if (btnWelcomeSoundboard) {
            btnWelcomeSoundboard.onclick = () => {
                soundboardModal.classList.add('active');
                playSound('click');
            };
        }
        
        if (btnCloseSoundboard) {
            btnCloseSoundboard.onclick = () => {
                soundboardModal.classList.remove('active');
            };
        }
        
        // Soundboard Buttons
        document.getElementById('btnPlayMenu')?.addEventListener('click', () => {
            game.settings.musicEnabled = true;
            music.switchContext('menu');
            if (!music.isPlaying) music.start();
            playSound('cardFlip');
            updateWelcomeMusicButton();
        });
        
        document.getElementById('btnPlayGameplay')?.addEventListener('click', () => {
            game.settings.musicEnabled = true;
            music.switchContext('gameplay');
            if (!music.isPlaying) music.start();
            playSound('cardFlip');
            updateWelcomeMusicButton();
        });
        
        document.getElementById('btnPlayShop')?.addEventListener('click', () => {
            game.settings.musicEnabled = true;
            music.switchContext('shop');
            if (!music.isPlaying) music.start();
            playSound('cardFlip');
            updateWelcomeMusicButton();
        });
        
        document.getElementById('btnPlayVictory')?.addEventListener('click', () => {
            game.settings.musicEnabled = true;
            music.switchContext('victory');
            if (!music.isPlaying) music.start();
            playSound('cardFlip');
            updateWelcomeMusicButton();
        });
        
        document.getElementById('btnPlayDefeat')?.addEventListener('click', () => {
            game.settings.musicEnabled = true;
            music.switchContext('defeat');
            if (!music.isPlaying) music.start();
            playSound('cardFlip');
            updateWelcomeMusicButton();
        });
        
        // Initialize welcome music button state
        updateWelcomeMusicButton();

        // Particles System
        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.cssText = `
                    left: ${x}px;
                    top: ${y}px;
                    width: ${Math.random() * 8 + 4}px;
                    height: ${Math.random() * 8 + 4}px;
                    background: ${color};
                    border-radius: 50%;
                    animation: particleFade ${Math.random() * 0.5 + 0.5}s ease-out forwards;
                    transform: translate(${(Math.random() - 0.5) * 100}px, ${(Math.random() - 0.5) * 100}px);
                `;
                document.body.appendChild(particle);
                setTimeout(() => particle.remove(), 1000);
            }
        }
        
        // Add particle animation CSS
        if (!document.getElementById('particleStyles')) {
            const style = document.createElement('style');
            style.id = 'particleStyles';
            style.textContent = `
                .particle {
                    position: fixed;
                    pointer-events: none;
                    z-index: 9999;
                }
                @keyframes particleFade {
                    0% { opacity: 1; transform: translateY(0) scale(1); }
                    100% { opacity: 0; transform: translateY(-100px) scale(0); }
                }
                @keyframes shake {
                    0%, 100% { transform: translateX(0); }
                    25% { transform: translateX(-10px); }
                    75% { transform: translateX(10px); }
                }
                .shake { animation: shake 0.4s ease; }
                
                @keyframes slideInRight {
                    0% { 
                        opacity: 0; 
                        transform: translateX(400px) scale(0.8); 
                    }
                    50% { 
                        transform: translateX(-20px) scale(1.05); 
                    }
                    100% { 
                        opacity: 1; 
                        transform: translateX(0) scale(1); 
                    }
                }
                
                .achievement-toast {
                    transition: opacity 0.5s ease, transform 0.5s ease;
                }
                
                .damage-number {
                    position: fixed;
                    font-size: 2.5em;
                    font-weight: bold;
                    pointer-events: none;
                    z-index: 9999;
                    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
                    animation: damageFloat 1.5s ease-out forwards;
                }
                @keyframes damageFloat {
                    0% { opacity: 1; transform: translateY(0) scale(0.5); }
                    50% { transform: translateY(-60px) scale(1.2); }
                    100% { opacity: 0; transform: translateY(-120px) scale(0.8); }
                }
                .damage-number.damage { color: #ff6b6b; }
                .damage-number.heal { color: #6bcf7f; }
                .damage-number.combo { color: #ffd93d; }
                .damage-number.score { color: #ffd700; font-size: 3em; }
                
                .combo-counter {
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%) scale(0);
                    font-size: 5em;
                    font-weight: bold;
                    color: #ffd93d;
                    text-shadow: 0 0 30px rgba(255, 217, 61, 0.8);
                    pointer-events: none;
                    z-index: 9998;
                    animation: comboPopup 1s ease-out forwards;
                }
                @keyframes comboPopup {
                    0% { transform: translate(-50%, -50%) scale(0) rotate(-10deg); opacity: 0; }
                    50% { transform: translate(-50%, -50%) scale(1.3) rotate(5deg); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(0.8) rotate(0deg); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Damage Numbers System
        function showDamageNumber(amount, type = 'damage') {
            const x = window.innerWidth / 2 + (Math.random() - 0.5) * 200;
            const y = window.innerHeight / 2 + (Math.random() - 0.5) * 200;
            
            const damageEl = document.createElement('div');
            damageEl.className = `damage-number ${type}`;
            damageEl.textContent = typeof amount === 'number' ? (type === 'heal' ? `+${amount}` : `-${amount}`) : amount;
            damageEl.style.left = x + 'px';
            damageEl.style.top = y + 'px';
            
            document.body.appendChild(damageEl);
            setTimeout(() => damageEl.remove(), 1500);
            
            // Particles
            const color = type === 'heal' ? '#6bcf7f' : (type === 'damage' ? '#ff6b6b' : '#ffd93d');
            createParticles(x, y, color, 15);
        }
        
        function showCombo(count) {
            const comboEl = document.createElement('div');
            comboEl.className = 'combo-counter';
            comboEl.textContent = `${count}x COMBO!`;
            document.body.appendChild(comboEl);
            setTimeout(() => comboEl.remove(), 1000);
            
            createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd93d', 30);
        }
        
        function screenShake() {
            const gameWrapper = document.getElementById('gameWrapper');
            if (gameWrapper) {
                gameWrapper.classList.add('shake');
                setTimeout(() => gameWrapper.classList.remove('shake'), 400);
            }
        }

        // Hold System
        function holdCard(card, sourceIndex) {
            if (game.heldCard) {
                showMessage('❌ You already have a held card! Use it first.', 'warning');
                playSound('error');
                return;
            }
            
            game.heldCard = { ...card, sourceIndex };
            game.room.splice(sourceIndex, 1);
            game.stats.cardsHeld++;
            
            const cardType = getCardType(card);
            const typeEmoji = {
                'monster': '👹',
                'weapon': '⚔️',
                'potion': '💊',
                'special': '✨'
            };
            
            playSound('hold');
            addLog(`Held ${card.value}${card.suit}`, 'info');
            showMessage(`📌 ${typeEmoji[cardType]} Held for later use!`, 'info');
            createParticles(window.innerWidth / 2, window.innerHeight / 3, '#ffd93d', 20);
            updateUI();
        }

        function useHeldCard() {
            if (!game.heldCard) return;
            
            const card = game.heldCard;
            game.heldCard = null;
            
            game.room.unshift(card); // Adds back to the start of the room
            
            updateUI();
            
            // Simulates clicking the card that just returned
            setTimeout(() => {
                const firstCardEl = bottomBar.querySelector('.card');
                if (firstCardEl) {
                    firstCardEl.click();
                }
            }, 100);
        }
        
        // Tooltip Generation
        function generateTooltip(card) {
            const type = getCardType(card);
            
            // Obliterate mode
            if (game.obliterateMode) {
                return `<span class="tooltip-negative">💥 OBLITERATE: Remove this card permanently!</span>`;
            }
            
            const powerBonus = getRelicBonus('power') + getRelicBonus('bigPower');
            
            if (type === 'monster') {
                const baseWeapon = game.equippedWeapon?.numValue || 0;
                const berserkBonus = game.berserkStacks > 0 ? 5 : 0;
                const totalWeapon = baseWeapon + powerBonus + berserkBonus;
                const effectiveWeapon = game.doubleDamage ? totalWeapon * 2 : totalWeapon;

                if (baseWeapon === 0) {
                    return `<span class="tooltip-negative">⚠️ No weapon! Damage: -${card.numValue} HP</span>`;
                }
                
                let actualDamage = card.numValue - effectiveWeapon;
                
                // Add info about active buffs
                let buffInfo = '';
                if (game.berserkStacks > 0) buffInfo += `🔥+${berserkBonus} `;
                if (game.doubleDamage) buffInfo += `⚡2x `;
                if (game.mirrorShield > 0) buffInfo += `🪞${game.mirrorShield} `;
                
                if (game.dodgeActive) return `<span class="tooltip-positive">🛡️ Dodge: No damage! ${buffInfo}</span>`;
                
                if (game.mirrorShield > 0 && actualDamage > 0) {
                    const reflected = Math.min(actualDamage, game.mirrorShield);
                    const remaining = actualDamage - reflected;
                    if (remaining <= 0) {
                        return `<span class="tooltip-positive">🪞 Mirror blocks all! ${buffInfo}</span>`;
                    } else {
                        return `<span class="tooltip-warning">🪞 Mirror -${reflected}, Take -${remaining} ${buffInfo}</span>`;
                    }
                }
                
                if (actualDamage > 0) return `<span class="tooltip-negative">⚔️ Fight: -${actualDamage} HP ${buffInfo}</span>`;
                else return `<span class="tooltip-positive">⚔️ Perfect! No damage! ${buffInfo}</span>`;
                
            } else if (type === 'weapon') {
                const current = (game.equippedWeapon?.numValue || 0) + powerBonus;
                const cardValue = card.numValue + powerBonus;

                if (cardValue > current) return `<span class="tooltip-positive">⬆️ Better Weapon! (${current} → ${cardValue})</span>`;
                else if (cardValue < current) return `<span class="tooltip-negative">⬇️ Worse Weapon (${current} → ${cardValue})</span>`;
                else return `<span class="tooltip-neutral">↔️ Same Weapon (${cardValue})</span>`;
                
            } else if (type === 'potion') {
                if (game.potionsUsed >= 1) return `<span class="tooltip-negative">❌ Potion already used in dungeon</span>`;
                
                const healBonus = getRelicBonus('healBonus');
                const heal = Math.min(card.numValue + healBonus, game.maxHealth - game.health);

                if (heal > 0) return `<span class="tooltip-positive">💚 Heal: +${heal} HP</span>`;
                else return `<span class="tooltip-neutral">💚 HP Full</span>`;
                
            } else if (card.special) {
                return `<span class="tooltip-positive">✨ ${card.special.description}</span>`;
            }
            return '';
        }
        
        // ===== ACHIEVEMENT SYSTEM =====
        function checkAchievements() {
            // Check achievements in real-time during gameplay
            checkAllAchievements();
            
            // Check in-game achievements that can't be checked via lifetime stats
            const unlocked = loadAchievements();
            
            // Collector - 3 relics in single run
            if (game.relics.length >= 3 && !unlocked.includes('collector')) {
                unlockAchievement('collector');
            }
            
            // Relic Hunter - 5 relics in single run
            if (game.relics.length >= 5 && !unlocked.includes('relic_hunter')) {
                unlockAchievement('relic_hunter');
            }
        }

        // Game Log (now in a modal or sidebar? For now, no visible log)
        function addLog(message, type = 'info') {
            console.log(`LOG [${type}]: ${message}`);
            // (The log UI was removed for a cleaner layout)
        }
        
        // Initialize deck
        function createDeck() {
            const deck = [];
            for (let suit in suits) {
                for (let value of values) {
                    deck.push({ value, suit, numValue: parseInt(value), suitName: suits[suit] });
                }
            }
            const specialCount = 2 + Math.floor(Math.random() * 3);
            for (let i = 0; i < specialCount; i++) {
                deck.push({ value: '✨', suit: '', numValue: 0, suitName: 'special', special: specialCards[Math.floor(Math.random() * specialCards.length)] });
            }
            return shuffleDeck(deck);
        }

        function shuffleDeck(deck) {
            let shuffled = [...deck];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }

        // ============================================
        // MAIN GAME LOGIC
        // ============================================

        function startGame() {
            // 1. Load Stats and Unlocks
            loadPermanentStats();
            loadUnlocks();
            
            // 2. Configure Game State
            game.difficulty = document.querySelector('.difficulty-btn.selected').dataset.difficulty;
            const healthMap = { easy: 20, normal: 15, hard: 10, endless: 15 };
            let startHealthBonus = permanentUnlocks.startHealth ? 5 : 0;

            game.maxHealth = healthMap[game.difficulty] + startHealthBonus;
            game.health = game.maxHealth;
            
            game.deck = createDeck();
            game.dungeon = [...game.deck];
            game.room = [];
            game.discardPile = [];
            game.equippedWeapon = null;
            game.heldCard = null;
            game.potionsUsed = 0;
            game.gameOver = false;
            game.score = 0;
            game.combo = permanentUnlocks.comboMaster ? 1 : 0;
            game.dodgeActive = false;
            game.doubleDamage = false;
            game.berserkStacks = 0;
            game.mirrorShield = 0;
            game.obliterateMode = false;
            game.gameStartTime = Date.now();
            
            // Run Stats
            game.stats = {
                monstersSlain: 0, totalDamage: 0, totalHealing: 0, roomsCleared: 0,
                weaponsEquipped: 0, potionsUsed: 0, maxCombo: 0, specialsUsed: 0,
                cardsHeld: 0, roomsAvoided: 0, gamesWon: 0, hardWins: 0,
                minimalistWin: false, onePunch: false, musicWasOn: game.settings.musicEnabled
            };
            
            // Initial Gold and Relics
            const startingGoldMap = { easy: 30, normal: 15, hard: 0, endless: 15 };
            game.gold = startingGoldMap[game.difficulty] || 0;
            game.totalGoldEarned = 0;
            game.relics = [];
            applyPermanentUnlocks(); // Applies initial gold/relics

            // 3. Update UI
            addLog(`Game started on ${game.difficulty.toUpperCase()} difficulty!`, 'info');
            showMessage(`Game started! Enter a dungeon to begin.`, 'info');
            
            btnStartGameModal.disabled = true; // Prevent double click
            btnDrawRoom.disabled = false;
            btnAvoidRoom.disabled = false;
            
            // Start Timer
            if (game.gameTimerInterval) clearInterval(game.gameTimerInterval);
            game.gameTimerInterval = setInterval(() => {
                const elapsed = Math.floor((Date.now() - game.gameStartTime) / 1000);
                const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
                const seconds = (elapsed % 60).toString().padStart(2, '0');
                gameTimer.textContent = `⏱️ ${minutes}:${seconds}`;
            }, 1000);
            
            updateUI();
            updateRelicsDisplay();
            
            // 4. Change Screens
            showGameUI();
            
            playSound('start');
            
            // Switch to gameplay music
            music.switchContext('gameplay');
        }

        function drawRoom() {
            if (game.dungeon.length === 0) {
                // Endless mode: reload deck instead of ending
                if (game.difficulty === 'endless') {
                    game.dungeon = createDeck();
                    showMessage('♾️ ENDLESS MODE: Deck reloaded! The dungeon never ends!', 'info');
                    playSound('special');
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, '#a8edea', 50);
                } else {
                    endGame('victory');
                    return;
                }
            }

            // Check if it's a boss room (every 10 rooms)
            const nextRoomNumber = game.stats.roomsCleared + 1;
            const isBossRoom = nextRoomNumber % 10 === 0;
            
            if (isBossRoom) {
                // BOSS BATTLE!
                const bossNumber = Math.floor(nextRoomNumber / 10);
                const bossHP = 12 + (bossNumber * 3); // Boss 1: 15HP, Boss 2: 18HP, Boss 3: 21HP, Boss 4: 24HP
                const bossCard = {
                    suit: '👹',
                    value: '👹',
                    numValue: bossHP,
                    isBoss: true,
                    bossNumber: bossNumber
                };
                
                const numToDraw = Math.min(3, game.dungeon.length);
                const drawnCards = game.dungeon.splice(0, numToDraw);
                game.room.push(bossCard, ...drawnCards);
                game.lastActionWasAvoid = false;
                
                playSound('special');
                addLog(`⚔️ BOSS BATTLE! Boss has ${bossHP} HP!`, 'danger');
                showMessage(`👹 BOSS ROOM! Defeat the boss for massive rewards!`, 'danger');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff6b6b', 60);
            } else {
                const numToDraw = Math.min(4, game.dungeon.length);
                const drawnCards = game.dungeon.splice(0, numToDraw);
                game.room.push(...drawnCards);
                game.lastActionWasAvoid = false;
                
                playSound('cardDraw');
                addLog(`Entered dungeon with ${game.room.length} cards`, 'info');
                showMessage(`You entered a dungeon with ${game.room.length} cards!`, 'info');
            }
            
            updateUI();
            btnDrawRoom.disabled = true;
            btnAvoidRoom.disabled = true;
        }

        function avoidRoom() {
            if (game.lastActionWasAvoid) {
                showMessage('❌ You cannot avoid 2 dungeons in a row!', 'warning');
                playSound('error');
                return;
            }
            if (game.dungeon.length < 3) {
                showMessage('Not enough cards to avoid!', 'warning');
                return;
            }

            const discarded = game.dungeon.splice(0, 3);
            game.discardPile.push(...discarded);
            game.stats.roomsAvoided++;
            game.lastActionWasAvoid = true;
            
            playSound('avoid');
            addLog('Avoided dungeon, 3 cards discarded', 'info');
            showMessage('You avoided the dungeon! 3 cards discarded.', 'info');
            updateUI();

            if (game.dungeon.length === 0) {
                endGame('victory');
            }
        }

        // Undo System - Save game state before action
        function saveGameState() {
            game.lastGameState = {
                health: game.health,
                gold: game.gold,
                room: [...game.room],
                dungeon: [...game.dungeon],
                discardPile: [...game.discardPile],
                equippedWeapon: game.equippedWeapon ? {...game.equippedWeapon} : null,
                potionsUsed: game.potionsUsed,
                combo: game.combo,
                heldCard: game.heldCard ? {...game.heldCard} : null
            };
            game.undoAvailable = true;
        }
        
        function undoLastMove() {
            if (!game.undoAvailable || !game.lastGameState) {
                showMessage('❌ No move to undo!', 'warning');
                return;
            }
            
            // Restore game state
            game.health = game.lastGameState.health;
            game.gold = game.lastGameState.gold;
            game.room = [...game.lastGameState.room];
            game.dungeon = [...game.lastGameState.dungeon];
            game.discardPile = [...game.lastGameState.discardPile];
            game.equippedWeapon = game.lastGameState.equippedWeapon ? {...game.lastGameState.equippedWeapon} : null;
            game.potionsUsed = game.lastGameState.potionsUsed;
            game.combo = game.lastGameState.combo;
            game.heldCard = game.lastGameState.heldCard ? {...game.lastGameState.heldCard} : null;
            
            game.undoAvailable = false;
            game.lastGameState = null;
            
            showMessage('↩️ Move undone!', 'info');
            playSound('cardFlip');
            updateUI();
        }

        function handleCardClick(card, index) {
            if (game.gameOver) return;
            
            // Save state for undo (Easy/Normal only)
            if (game.difficulty === 'easy' || game.difficulty === 'normal') {
                saveGameState();
            }

            // Obliterate mode - remove ANY card permanently
            if (game.obliterateMode) {
                game.room.splice(index, 1);
                // Don't add to discard - it's obliterated!
                game.obliterateMode = false;
                showMessage('💥 Card OBLITERATED from existence!', 'success');
                playSound('special');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ff6b6b', 40);
                
                // Track obliteration for achievement
                const saved = localStorage.getItem('scoundrel_lifetime_stats');
                let lifetimeStats = saved ? JSON.parse(saved) : {};
                lifetimeStats.cardsObliterated = (lifetimeStats.cardsObliterated || 0) + 1;
                localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
                
                updateUI();
                checkGameState();
                checkAchievements();
                return;
            }

            const cardType = getCardType(card);

            if (cardType === 'monster') handleMonster(card, index);
            else if (cardType === 'weapon') handleWeapon(card, index);
            else if (cardType === 'potion') handlePotion(card, index);
            else if (cardType === 'special') handleSpecial(card, index);
        }

        function getCardType(card) {
            if (card.special) return 'special';
            if (card.isBoss) return 'monster'; // Boss is a monster!
            if (card.suitName === 'clubs' || card.suitName === 'spades') return 'monster';
            if (card.suitName === 'diamonds') return 'weapon';
            if (card.suitName === 'hearts') return 'potion';
        }
        
        function handleSpecial(card, index) {
            game.room.splice(index, 1);
            game.discardPile.push(card);
            game.stats.specialsUsed++;
            
            playSound('special');
            addLog(`Used special: ${card.special.name}`, 'heal');
            card.special.effect();
            
            updateUI();
            checkGameState();
            checkAchievements();
        }

        function handleMonster(monster, index) {
            const powerBonus = getRelicBonus('power') + getRelicBonus('bigPower');
            const baseWeapon = game.equippedWeapon ? game.equippedWeapon.numValue : 0;
            
            // Add berserk bonus
            const berserkBonus = game.berserkStacks > 0 ? 5 : 0;
            const totalWeapon = baseWeapon + powerBonus + berserkBonus;
            
            const effectiveWeapon = game.doubleDamage ? totalWeapon * 2 : totalWeapon;
            
            // Boss battle: reduce HP instead of instant kill
            if (monster.isBoss) {
                monster.numValue -= effectiveWeapon;
                
                if (monster.numValue <= 0) {
                    // Boss defeated!
                    game.stats.monstersSlain++;
                    game.room.splice(index, 1);
                    game.discardPile.push(monster);
                    
                    const bossGold = (Math.floor(Math.random() * 21) + 30);
                    earnGold(bossGold);
                    showMessage(`👹 BOSS DEFEATED! +${bossGold} GOLD!`, 'success');
                    createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd700', 80);
                    playSound('special');
                    
                    updateUI();
                    checkGameState();
                    checkAchievements();
                    return;
                } else {
                    // Boss still alive, take damage
                    showMessage(`⚔️ Hit boss for ${effectiveWeapon} damage! Boss HP: ${monster.numValue}`, 'info');
                    playSound('attack');
                    updateUI();
                    return;
                }
            }
            
            let damage = Math.max(0, monster.numValue - effectiveWeapon);
            
            // Consume berserk stack
            if (game.berserkStacks > 0 && berserkBonus > 0) {
                game.berserkStacks--;
                showMessage(`🔥 Berserk +5 damage! (${game.berserkStacks} left)`, 'info');
            }
            
            playSound('attack');
            
            // Dodge
            if (game.dodgeActive && damage > 0) {
                game.dodgeActive = false;
                playSound('special');
                addLog(`Dodged attack from ${monster.value}${monster.suit}!`, 'heal');
                showMessage('🛡️ Dodged! No damage!', 'success');
            } 
            // Mirror Shield - Reflect damage
            else if (damage > 0 && game.mirrorShield > 0) {
                const reflected = Math.min(damage, game.mirrorShield);
                game.mirrorShield -= reflected;
                const remaining = damage - reflected;
                
                if (remaining > 0) {
                    game.health -= remaining;
                    game.stats.totalDamage += remaining;
                    showDamageNumber(remaining, 'damage');
                    playSound('damage');
                }
                
                showMessage(`🪞 Mirror reflected ${reflected} damage! Shield: ${game.mirrorShield}`, 'success');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#a8edea', 30);
                
                if (remaining <= 0) {
                    game.combo++;
                    game.stats.maxCombo = Math.max(game.stats.maxCombo, game.combo);
                } else {
                    game.combo = permanentUnlocks.comboMaster ? 1 : 0;
                }
            }
            // Relic Shield
            else if (damage > 0) {
                let shieldRelic = game.relics.find(r => r.id === 'tank' && !r.shieldUsed);
                if (shieldRelic) {
                    shieldRelic.shieldUsed = true;
                    const actualDamage = Math.max(0, damage - 1);
                    showMessage(`🛡️ Shield absorbed 1 damage! Received ${actualDamage}.`, 'success');
                    if (actualDamage > 0) {
                        game.health -= actualDamage;
                        game.stats.totalDamage += actualDamage;
                        showDamageNumber(actualDamage, 'damage');
                        playSound('damage');
                        game.combo = permanentUnlocks.comboMaster ? 1 : 0;
                    }
                } else {
                    // Normal Damage
                    game.health -= damage;
                    game.stats.totalDamage += damage;
                    game.combo = permanentUnlocks.comboMaster ? 1 : 0; // Reset combo
                    showDamageNumber(damage, 'damage');
                    playSound('damage');
                    screenShake();
                    addLog(`Took ${damage} damage from ${monster.value}${monster.suit}`, 'damage');
                    showMessage(`⚔️ Took ${damage} damage!`, 'danger');
                }
            } 
            // Perfect Kill
            else {
                game.combo++;
                game.stats.maxCombo = Math.max(game.stats.maxCombo, game.combo);
                if (game.combo >= 2) {
                    showCombo(game.combo);
                    playSound('combo');
                }
                
                // Lifesteal
                const lifesteal = game.relics.filter(r => r.id === 'vampire').length * 2;
                if (lifesteal > 0) {
                    game.health = Math.min(game.maxHealth, game.health + lifesteal);
                    showMessage(`🧛 +${lifesteal} HP from Vampirism!`, 'success');
                }
                
                addLog(`Defeated ${monster.value}${monster.suit}! (Combo: ${game.combo})`, 'info');
                showMessage(`⚔️ Perfect kill! ${game.combo}x COMBO!`, 'success');
            }
            
            if (game.doubleDamage) game.doubleDamage = false;
            
            // Weapon durability system
            if (game.equippedWeapon && game.equippedWeapon.durability < 999) {
                game.equippedWeapon.durability--;
                
                if (game.equippedWeapon.durability <= 0) {
                    // Weapon broke!
                    showMessage(`💔 Your weapon broke!`, 'danger');
                    playSound('error');
                    game.discardPile.push(game.equippedWeapon);
                    game.equippedWeapon = null;
                } else {
                    // Show remaining durability
                    const emoji = game.equippedWeapon.durability === 1 ? '⚠️' : '⚔️';
                    addLog(`${emoji} Weapon: ${game.equippedWeapon.durability}/${game.equippedWeapon.maxDurability} uses left`, 'info');
                }
            }
            
            game.stats.monstersSlain++;
            game.room.splice(index, 1);
            game.discardPile.push(monster);
            
            // Monster gold (difficulty-based, with boss bonus)
            if (monster.isBoss) {
                // Boss gold rewards (much more generous!)
                const bossGoldByDifficulty = {
                    easy: Math.floor(Math.random() * 16) + 25,    // 25-40 gold
                    normal: Math.floor(Math.random() * 11) + 20,  // 20-30 gold
                    hard: Math.floor(Math.random() * 11) + 15,    // 15-25 gold
                    endless: Math.floor(Math.random() * 11) + 20  // 20-30 gold
                };
                const bossGold = bossGoldByDifficulty[game.difficulty] || 20;
                earnGold(bossGold);
                showMessage(`👹 BOSS DEFEATED! +${bossGold} gold!`, 'success');
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#d4af37', 50);
            } else {
                // Normal monster gold
                const goldByDifficulty = {
                    easy: Math.floor(Math.random() * 4) + 3,    // 3-6 gold
                    normal: Math.floor(Math.random() * 3) + 2,  // 2-4 gold
                    hard: Math.floor(Math.random() * 2) + 1,    // 1-2 gold
                    endless: Math.floor(Math.random() * 3) + 2  // 2-4 gold
                };
                const baseGold = goldByDifficulty[game.difficulty] || 2;
                earnGold(baseGold);
            }
            
            // Revive
            if (game.health <= 0) {
                const phoenix = game.relics.find(r => r.id === 'phoenix' && !r.used);
                if (phoenix) {
                    phoenix.used = true;
                    game.health = 10;
                    showMessage('🐦 Phoenix Feather activated! Revived with 10 HP!', 'success');
                    playSound('special');
                    updateRelicsDisplay();
                }
            }
            
            updateRunningScore(); // Update score
            updateUI();
            checkGameState();
            checkAchievements();
        }

        function handleWeapon(weapon, index) {
            if (game.equippedWeapon) {
                game.discardPile.push(game.equippedWeapon);
            }
            
            game.equippedWeapon = weapon;
            game.room.splice(index, 1);
            game.stats.weaponsEquipped++;
            
            // Set weapon durability based on difficulty and relics
            const durabilityMap = { easy: 3, normal: 2, hard: 1, endless: 2 };
            game.equippedWeapon.maxDurability = durabilityMap[game.difficulty] || 2;
            game.equippedWeapon.durability = game.equippedWeapon.maxDurability;
            
            // Check for Durable Weapons relic
            if (game.relics.some(r => r.id === 'durable_weapons')) {
                game.equippedWeapon.maxDurability = 999; // Infinite durability
                game.equippedWeapon.durability = 999;
            }
            
            playSound('equip');
            const powerBonus = getRelicBonus('power') + getRelicBonus('bigPower');
            addLog(`Equipped ${weapon.value}${weapon.suit}!`, 'equip');
            showMessage(`⚔️ Equipped weapon with value ${weapon.numValue + powerBonus}! (${game.equippedWeapon.durability}/${game.equippedWeapon.maxDurability} uses)`, 'success');
            
            updateUI();
            checkGameState();
            checkAchievements();
        }

        function handlePotion(potion, index) {
            if (game.potionsUsed >= 1) {
                showMessage('Only 1 potion per dungeon! Discarding...', 'warning');
                game.room.splice(index, 1);
                game.discardPile.push(potion);
                addLog(`Discarded potion ${potion.value}${potion.suit}`, 'info');
                updateUI();
                checkGameState();
                return;
            }

            const healBonus = getRelicBonus('healBonus');
            const heal = potion.numValue + healBonus;
            
            const oldHealth = game.health;
            game.health = Math.min(game.health + heal, game.maxHealth);
            const actualHeal = game.health - oldHealth;
            
            if (actualHeal > 0) {
                game.potionsUsed++;
                game.stats.potionsUsed++;
                game.stats.totalHealing += actualHeal;
                showDamageNumber(actualHeal, 'heal');
                playSound('heal');
                addLog(`Used ${potion.value}${potion.suit}, healed ${actualHeal} HP`, 'heal');
                showMessage(`💚 Healed ${actualHeal} HP!`, 'success');
            } else {
                 showMessage(`💚 HP is full!`, 'info');
            }
            
            game.room.splice(index, 1);
            game.discardPile.push(potion);
            updateUI();
            checkGameState();
            checkAchievements();
        }

        function checkGameState() {
            // Room Cleared?
            if (game.room.length === 0 && !game.gameOver) {
                game.potionsUsed = 0;
                game.stats.roomsCleared++;
                if (game.combo >= 3) showMessage(`🔥 ${game.combo}x COMBO! DUNGEON CLEAR!`, 'success');
                
                game.combo = permanentUnlocks.comboMaster ? 1 : 0; // Reset combo
                game.undoAvailable = false; // Reset undo for new room
                game.lastGameState = null;
                
                playSound('roomClear');
                addLog(`Dungeon cleared! Total: ${game.stats.roomsCleared}`, 'info');
                
                // Victory particles!
                createParticles(window.innerWidth / 2, window.innerHeight / 2, '#ffd700', 40);
                setTimeout(() => createParticles(window.innerWidth / 2 + 100, window.innerHeight / 2, '#6bcf7f', 30), 150);
                setTimeout(() => createParticles(window.innerWidth / 2 - 100, window.innerHeight / 2, '#4ecdc4', 30), 300);
                
                btnDrawRoom.disabled = false;
                btnAvoidRoom.disabled = game.lastActionWasAvoid;
                
                // Room Clear Relics
                game.relics.forEach(r => { if (r.id === 'tank') r.shieldUsed = false; });
                
                // Gold per room from relics
                let goldPerRoom = 0;
                goldPerRoom += game.relics.filter(r => r.id === 'coin_pouch').length * 2;
                goldPerRoom += game.relics.filter(r => r.id === 'greedy').length * 3;
                if (goldPerRoom > 0) earnGold(goldPerRoom);
                
                // Passive healing from relics
                let passiveHeal = 0;
                passiveHeal += game.relics.filter(r => r.id === 'bandage').length * 0.5;
                passiveHeal += game.relics.filter(r => r.id === 'meditation').length * 1;
                if (passiveHeal > 0) game.health = Math.min(game.maxHealth, game.health + Math.floor(passiveHeal));
                
                // Reset Mirror Shield at room clear (only for current dungeon)
                game.mirrorShield = 0;
                
                // Reset weapon durability at room clear (Master Smith relic)
                if (game.equippedWeapon && game.relics.some(r => r.id === 'master_smith')) {
                    game.equippedWeapon.durability = game.equippedWeapon.maxDurability;
                    showMessage('🔨 Master Smith repaired your weapon!', 'success');
                }
                
                // Room clear bonus (difficulty-based)
                const roomBonusByDifficulty = {
                    easy: Math.floor(Math.random() * 4) + 5,    // 5-8 gold
                    normal: Math.floor(Math.random() * 3) + 4,  // 4-6 gold
                    hard: Math.floor(Math.random() * 3) + 2,    // 2-4 gold
                    endless: Math.floor(Math.random() * 3) + 4  // 4-6 gold
                };
                const bonusGold = roomBonusByDifficulty[game.difficulty] || 3;
                earnGold(bonusGold);
                
                updateRunningScore(); // Update score
                updateUI(); // Update stats
                checkAchievements();

                // Event Chance (difficulty-based)
                const eventChanceByDifficulty = {
                    easy: 0.40,      // 40% chance
                    normal: 0.30,    // 30% chance
                    hard: 0.20,      // 20% chance
                    endless: 0.25    // 25% chance
                };
                const eventChance = eventChanceByDifficulty[game.difficulty] || 0.30;
                
                setTimeout(() => {
                    if (!game.gameOver && Math.random() < eventChance) {
                        triggerRandomEvent();
                    }
                }, 800);
            }

            if (game.health <= 0) {
                endGame('death');
            }

            // Don't end game on victory in endless mode
            if (game.dungeon.length === 0 && game.room.length === 0 && game.difficulty !== 'endless') {
                endGame('victory');
            }
        }

        function endGame(reason, gaveUp = false) {
            if (game.gameStartTime === 0 || game.gameOver) return;
            
            game.gameOver = true;
            if (game.gameTimerInterval) clearInterval(game.gameTimerInterval); // Stop clock
            
            // Switch music based on outcome
            if (reason === 'victory') {
                music.switchContext('victory');
            } else {
                music.switchContext('defeat');
            }
            
            const gameTime = Math.floor((Date.now() - game.gameStartTime) / 1000);
            let title, message, score, scoreLabel, isVictory = false;

            if (reason === 'death') {
                title = '💀 DEFEAT';
                message = gaveUp ? 'You gave up the run.' : 'Your health reached zero!';
                score = gaveUp ? 0 : calculateDeathScore(); // Score is 0 if gave up
                scoreLabel = '💀 Final Score:';
                playSound('defeat');
            } else if (reason === 'victory') {
                isVictory = true;
                title = '🏆 VICTORY';
                message = 'You conquered the dungeon!';
                score = calculateWinScore();
                scoreLabel = '🏆 Final Score:';
                playSound('victory');
                
                // Epic victory particle explosion!
                for (let i = 0; i < 5; i++) {
                    setTimeout(() => {
                        const x = window.innerWidth / 2 + (Math.random() - 0.5) * 400;
                        const y = window.innerHeight / 2 + (Math.random() - 0.5) * 300;
                        const colors = ['#ffd700', '#6bcf7f', '#4ecdc4', '#ff6b6b', '#ffd93d'];
                        createParticles(x, y, colors[i % colors.length], 50);
                    }, i * 200);
                }
                
                game.stats.gamesWon = 1;
                permanentStats.gamesWon = (permanentStats.gamesWon || 0) + 1;
                if (game.difficulty === 'hard') {
                    game.stats.hardWins = 1;
                    permanentStats.hardWins = (permanentStats.hardWins || 0) + 1;
                }
                if (permanentStats.fastestWin === 0 || gameTime < permanentStats.fastestWin) {
                    permanentStats.fastestWin = gameTime;
                }
                setTimeout(() => showDamageNumber(score, 'score'), 500);
            }
            
            // Update permanent stats
            updateLifetimeStats(); // Save stats
            checkAchievements(); // Check one last time
            savePermanentStats(); // Save progress
            saveUnlocks(); // Save unlocks

            showGameOver(title, message, score, scoreLabel, isVictory, gameTime);
        }
        
        // Ported Score Functions
        function calculateWinScore() {
            const timeInSeconds = Math.max(1, Math.floor((Date.now() - game.gameStartTime) / 1000));
            
            let difficultyMultiplier = 1;
            if (game.difficulty === 'normal') difficultyMultiplier = 1.5;
            if (game.difficulty === 'hard') difficultyMultiplier = 2.5;

            const baseScore = 1000; // Win bonus
            const healthBonus = game.health * 20;
            const goldBonus = game.totalGoldEarned * 5;
            const comboBonus = game.stats.maxCombo * 10;
            const monsterBonus = game.stats.monstersSlain * 2;
            
            const timePenalty = timeInSeconds * 2;
            
            const totalScore = Math.floor(
                ((baseScore + healthBonus + goldBonus + comboBonus + monsterBonus) - timePenalty) * difficultyMultiplier
            );
            
            return Math.max(1, totalScore); // Score must be at least 1
        }
        
        function calculateDeathScore() {
            // Original logic from Letterboard
            const monstersInDiscard = game.discardPile.filter(c => 
                c.suitName === 'clubs' || c.suitName === 'spades'
            );
            const totalValue = monstersInDiscard.reduce((sum, card) => sum + card.numValue, 0);
            return game.health - totalValue; // Will be a negative number
        }

        function showGameOver(title, message, score, scoreLabel, isVictory, gameTime) {
            const overlay = document.createElement('div');
            overlay.className = 'modal-overlay active game-over'; // Use modal class
            
            const submitButtonHTML = isVictory ? 
                `<button class="btn btn-success" id="btnSubmitScore">🚀 Submit Score</button>` : '';
            
            // Score Breakdown
            let scoreBreakdownHTML = '';
            if (isVictory) {
                const timeInSeconds = Math.max(1, gameTime);
                let difficultyMultiplier = 1;
                if (game.difficulty === 'normal') difficultyMultiplier = 1.5;
                if (game.difficulty === 'hard') difficultyMultiplier = 2.5;

                const baseScore = 1000;
                const healthBonus = game.health * 20;
                const goldBonus = game.totalGoldEarned * 5;
                const comboBonus = game.stats.maxCombo * 10;
                const monsterBonus = game.stats.monstersSlain * 2;
                const timePenalty = timeInSeconds * 2;
                const subTotal = (baseScore + healthBonus + goldBonus + comboBonus + monsterBonus) - timePenalty;

                scoreBreakdownHTML = `
                    <div class="game-over-stats" style="background: rgba(0,0,0,0.4); border: 1px solid #ffd700; margin-bottom: 15px; text-align: left;">
                        <p style="color: #ffd700; font-weight: bold; font-size: 1.1em; margin-bottom: 10px;">Score Breakdown:</p>
                        <p>Win Bonus: +1000</p>
                        <p>Health Bonus (${game.health} HP): +${healthBonus}</p>
                        <p>Gold Bonus (${game.totalGoldEarned} 🪙): +${goldBonus}</p>
                        <p>Combo Bonus (${game.stats.maxCombo}x): +${comboBonus}</p>
                        <p>Monster Bonus (${game.stats.monstersSlain} ⚔️): +${monsterBonus}</p>
                        <p style="color: #ff6b6b;">Time Penalty (${timeInSeconds}s): -${timePenalty}</p>
                        <hr style="border-color: rgba(255,255,255,0.2); margin: 5px 0;">
                        <p>Subtotal (${subTotal}) x ${difficultyMultiplier} (Difficulty) = <strong>${score}</strong></p>
                    </div>
                `;
            }
            
            overlay.innerHTML = `
                <div class="game-over-content ${isVictory ? 'victory' : ''}">
                    <h2>${title}</h2>
                    <p>${message}</p>
                    ${scoreBreakdownHTML}
                    <p class="game-over-score">${scoreLabel} ${score}</p>
                    <div class="game-over-stats">
                        <p>📊 <strong>Run Statistics:</strong></p>
                        <p>⏱️ Time: ${gameTime}s</p>
                        <p>⚔️ Monsters Slain: ${game.stats.monstersSlain}</p>
                        <p>🗡️ Weapons Used: ${game.stats.weaponsEquipped}</p>
                        <p>💔 Damage Taken: ${game.stats.totalDamage}</p>
                        <p>💚 Healing Received: ${game.stats.totalHealing}</p>
                        <p>🏰 Rooms Cleared: ${game.stats.roomsCleared}</p>
                        <p>🔥 Max Combo: ${game.stats.maxCombo}x</p>
                        <p>🪙 Gold Earned: ${game.totalGoldEarned}</p>
                    </div>
                    <div class="game-over-controls">
                        <button class="btn btn-primary" id="btnPlayAgain">🔄 Play Again</button>
                        ${submitButtonHTML}
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);
            
            document.getElementById('btnPlayAgain').onclick = () => {
                overlay.remove();
                btnStartGameModal.disabled = false; // Reset button
                music.switchContext('menu'); // Return to menu music
                showWelcomeScreen(); // Back to welcome screen
            };
            
            if (isVictory) {
                document.getElementById('btnSubmitScore').addEventListener('click', async (e) => {
                    const btn = e.target;
                    btn.disabled = true;
                    btn.textContent = 'Submitting...';
                    
                    try {
                        await submitScoreToLeaderboard(score, gameTime);
                        btn.textContent = '✅ Submitted!';
                    } catch (err) {
                        btn.textContent = 'Submission Failed';
                        btn.disabled = false;
                        console.error("Score submission error:", err);
                    }
                });
            }
        }

        function showMessage(text, type) {
            const msgEl = document.createElement('div');
            msgEl.className = `message ${type}`;
            msgEl.textContent = text;
            messageArea.appendChild(msgEl);
            
            setTimeout(() => {
                msgEl.style.opacity = '0';
                setTimeout(() => msgEl.remove(), 500);
            }, 3000);
        }

        // ============================================
        // UI UPDATE
        // ============================================
        
        function updateRunningScore() {
            game.score = (game.stats.monstersSlain * 10) + (game.stats.roomsCleared * 50) + game.totalGoldEarned;
            mainScoreValue.textContent = game.score;
        }
        
        function updateUI() {
            // HP Critical Warning
            if (game.health > 0 && game.health <= 5) {
                document.body.classList.add('hp-critical');
            } else {
                document.body.classList.remove('hp-critical');
            }
            
            // Top Bar
            healthEl.textContent = `${game.health} / ${game.maxHealth}`;
            goldEl.textContent = game.gold;
            dungeonCountEl.textContent = game.dungeon.length;
            statRoomsEl.textContent = game.stats.roomsCleared;
            mainScoreValue.textContent = game.score; // Update main score
            
            // Undo button visibility (Easy/Normal only)
            const btnUndo = document.getElementById('btnUndo');
            if (btnUndo && (game.difficulty === 'easy' || game.difficulty === 'normal')) {
                btnUndo.style.display = 'inline-block';
                btnUndo.disabled = !game.undoAvailable;
            } else if (btnUndo) {
                btnUndo.style.display = 'none';
            }

            // Center Stage - Weapon
            equippedWeaponEl.innerHTML = '';
            if (game.equippedWeapon) {
                const cardEl = createCardElement(game.equippedWeapon);
                cardEl.classList.add('equipped');
                
                const powerBonus = getRelicBonus('power') + getRelicBonus('bigPower');
                if (powerBonus > 0 || game.doubleDamage) {
                    const badge = document.createElement('div');
                    badge.style.cssText = 'position:absolute;top:5px;right:5px;background:#ffd93d;color:#000;padding:3px 8px;border-radius:10px;font-size:0.8em;font-weight:bold;';
                    badge.textContent = game.doubleDamage ? `2x (${game.equippedWeapon.numValue + powerBonus})` : `+${powerBonus}`;
                    cardEl.appendChild(badge);
                }
                
                // Durability indicator
                if (game.equippedWeapon.durability < 999) {
                    const durabilityBar = document.createElement('div');
                    durabilityBar.style.cssText = 'position:absolute;bottom:5px;left:5px;right:5px;height:8px;background:rgba(0,0,0,0.5);border-radius:4px;overflow:hidden;';
                    
                    const durabilityFill = document.createElement('div');
                    const percentage = (game.equippedWeapon.durability / game.equippedWeapon.maxDurability) * 100;
                    let fillColor = '#6bcf7f'; // Green (full)
                    if (percentage <= 33) fillColor = '#ff6b6b'; // Red (low)
                    else if (percentage <= 66) fillColor = '#ffd93d'; // Yellow (medium)
                    
                    durabilityFill.style.cssText = `height:100%;width:${percentage}%;background:${fillColor};transition:all 0.3s ease;`;
                    durabilityBar.appendChild(durabilityFill);
                    
                    const durabilityText = document.createElement('div');
                    const durabilityIcon = game.equippedWeapon.durability === 1 ? '⚠️' : '⚔️';
                    durabilityText.style.cssText = 'position:absolute;bottom:12px;left:50%;transform:translateX(-50%);background:rgba(0,0,0,0.8);color:white;padding:2px 6px;border-radius:8px;font-size:0.7em;font-weight:bold;white-space:nowrap;';
                    durabilityText.textContent = `${durabilityIcon} ${game.equippedWeapon.durability}/${game.equippedWeapon.maxDurability}`;
                    
                    cardEl.appendChild(durabilityBar);
                    cardEl.appendChild(durabilityText);
                }
                
                equippedWeaponEl.appendChild(cardEl);
            } else {
                equippedWeaponEl.innerHTML = '<div class="empty-slot">No Weapon</div>';
            }
            
            // Right Bar - Hold
            holdAreaContainer.innerHTML = '';
            if (game.heldCard) {
                const cardEl = createCardElement(game.heldCard);
                cardEl.classList.add('held');
                cardEl.onclick = useHeldCard;
                holdAreaContainer.appendChild(cardEl);
            } else {
                holdAreaContainer.innerHTML = '<div class="empty-slot" style="font-size: 0.8em;">Right-click to hold</div>';
            }
            
            // Right Bar - Discard
            discardPilePreview.innerHTML = '';
            const lastFive = game.discardPile.slice(-5).reverse();
            if (lastFive.length > 0) {
                lastFive.forEach(card => {
                    discardPilePreview.appendChild(createMiniCardElement(card));
                });
            } else {
                discardPilePreview.innerHTML = '<span style="font-size: 0.8em; opacity: 0.5;">Empty</span>';
            }

            // Bottom Bar - Room
            bottomBar.innerHTML = '';
            if (game.room.length > 0) {
                game.room.forEach((card, index) => {
                    const cardEl = createCardElement(card);
                    
                    const tooltip = generateTooltip(card);
                    if (tooltip) {
                        const tooltipEl = document.createElement('div');
                        tooltipEl.className = 'card-tooltip';
                        tooltipEl.innerHTML = tooltip;
                        cardEl.appendChild(tooltipEl);
                    }
                    
                    // Add preview
                    const type = getCardType(card);
                    const powerBonus = getRelicBonus('power') + getRelicBonus('bigPower');
                    const baseWeaponVal = game.equippedWeapon ? game.equippedWeapon.numValue : 0;
                    const effectiveWeapon = game.doubleDamage ? (baseWeaponVal + powerBonus) * 2 : (baseWeaponVal + powerBonus);

                    if (type === 'monster') {
                        const damage = card.numValue - effectiveWeapon;
                        if (game.dodgeActive || damage <= 0) cardEl.classList.add('preview-safe');
                        else cardEl.classList.add('preview-danger');
                    } else if (type === 'weapon') {
                        const current = baseWeaponVal + powerBonus;
                        const cardValue = card.numValue + powerBonus;
                        if (cardValue > current) cardEl.classList.add('preview-safe');
                        else if (cardValue < current) cardEl.classList.add('preview-danger');
                        else cardEl.classList.add('preview-neutral');
                    } else if (type === 'potion') {
                        if (game.potionsUsed >= 1) cardEl.classList.add('preview-danger');
                        else cardEl.classList.add('preview-safe');
                    } else if (type === 'special') {
                        cardEl.classList.add('preview-safe');
                    }
                    
                    // Click events
                    cardEl.onclick = (e) => {
                        e.stopPropagation();
                        playSound('cardFlip');
                        handleCardClick(card, index);
                    };
                    cardEl.oncontextmenu = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        holdCard(card, index);
                    };
                    
                    // Touch support for mobile (long press to hold)
                    let touchTimer = null;
                    let touchMoved = false;
                    
                    cardEl.addEventListener('touchstart', (e) => {
                        touchMoved = false;
                        touchTimer = setTimeout(() => {
                            if (!touchMoved) {
                                navigator.vibrate && navigator.vibrate(50); // Haptic feedback
                                holdCard(card, index);
                            }
                        }, 500); // 500ms long press
                    }, { passive: true });
                    
                    cardEl.addEventListener('touchmove', () => {
                        touchMoved = true;
                        if (touchTimer) clearTimeout(touchTimer);
                    }, { passive: true });
                    
                    cardEl.addEventListener('touchend', () => {
                        if (touchTimer) clearTimeout(touchTimer);
                    }, { passive: true });
                    
                    cardEl.addEventListener('touchcancel', () => {
                        if (touchTimer) clearTimeout(touchTimer);
                    }, { passive: true });
                    
                    bottomBar.appendChild(cardEl);
                });
            } else if (!game.gameOver) {
                 bottomBar.innerHTML = '<div class="empty-slot">Dungeon Empty. Use controls above.</div>';
            }
        }

        function createCardElement(card) {
            const cardEl = document.createElement('div');
            cardEl.className = 'card';
            const type = getCardType(card);
            cardEl.classList.add(type);
            
            // Boss special styling
            if (card.isBoss) {
                cardEl.classList.add('boss');
                cardEl.style.boxShadow = '0 0 30px rgba(255, 107, 107, 0.8)';
                cardEl.style.borderColor = '#ff6b6b';
                cardEl.style.animation = 'bossPulse 1.5s infinite';
            }

            if (type === 'special') {
                cardEl.innerHTML = `
                    <div class="card-value">${card.special.name.split(' ')[0]}</div>
                    <div style="font-size: 0.8em; padding: 0 5px;">${card.special.name.split(' ').slice(1).join(' ')}</div>
                    <div class="card-suit">✨</div>
                `;
            } else if (card.isBoss) {
                cardEl.innerHTML = `
                    <div class="card-value" style="font-size: 2em;">👹</div>
                    <div style="font-size: 0.9em; color: #ff6b6b; font-weight: bold;">BOSS</div>
                    <div class="card-suit" style="font-size: 1.2em; color: #ff6b6b;">${card.numValue} HP</div>
                `;
            } else {
                cardEl.innerHTML = `
                    <div class="card-value">${card.value}</div>
                    <div class="card-suit">${card.suit}</div>
                `;
            }
            return cardEl;
        }
        
        function createMiniCardElement(card) {
            const cardEl = document.createElement('div');
            cardEl.className = 'mini-card';
            const type = getCardType(card);
            cardEl.classList.add(type);

            if (type === 'special') {
                cardEl.innerHTML = `<span class="card-value">✨</span>`;
            } else {
                cardEl.innerHTML = `
                    <span class="card-value">${card.value}</span>
                    <span class="card-suit">${card.suit}</span>
                `;
            }
            return cardEl;
        }

        // ============================================
        // RELICS, SHOP, EVENTS (Ported Logic)
        // ============================================
        const RELICS = [
            // === COMUM (25) - Efeitos básicos e úteis ===
            { id: 'small_shield', name: '🛡️ Small Shield', description: '+3 maximum health', rarity: 'common', effect: 'smallHealth' },
            { id: 'bronze_ring', name: '💍 Bronze Ring', description: '+1 damage to all weapons', rarity: 'common', effect: 'smallPower' },
            { id: 'heal_charm', name: '💚 Healing Charm', description: 'Potions heal +1 HP', rarity: 'common', effect: 'smallHealBonus' },
            { id: 'coin_pouch', name: '💰 Coin Pouch', description: 'Gain 2 gold per room cleared', rarity: 'common', effect: 'smallGoldPerRoom' },
            { id: 'lucky_penny', name: '🪙 Lucky Penny', description: '+20% gold from all sources', rarity: 'common', effect: 'smallGoldBonus' },
            { id: 'leather_boots', name: '👢 Leather Boots', description: 'Avoid costs 2 cards instead of 3', rarity: 'common', effect: 'betterAvoid' },
            { id: 'bandage', name: '🩹 Bandage', description: 'Heal 0.5 HP per room cleared', rarity: 'common', effect: 'tinyRegen' },
            { id: 'weak_thorns', name: '🌿 Weak Thorns', description: 'Reflect 1 damage to attackers', rarity: 'common', effect: 'weakThorns' },
            { id: 'compass', name: '🧭 Compass', description: '10% more events', rarity: 'common', effect: 'moreEvents' },
            { id: 'dice', name: '🎲 Lucky Dice', description: 'Shop items 5% cheaper', rarity: 'common', effect: 'tinyDiscount' },
            { id: 'feather', name: '🪶 Light Feather', description: 'Hold 2 cards instead of 1', rarity: 'common', effect: 'extraHold' },
            { id: 'candle', name: '🕯️ Candle', description: 'See 1 extra card in deck', rarity: 'common', effect: 'peek' },
            { id: 'rope', name: '🪢 Rope', description: 'Start with 1 extra HP', rarity: 'common', effect: 'tinyHealth' },
            { id: 'stone', name: '🪨 Stone', description: 'Reduce first damage by 1', rarity: 'common', effect: 'firstShield' },
            { id: 'herb', name: '🌱 Herb', description: 'Potions usable twice per dungeon', rarity: 'common', effect: 'doublePot' },
            { id: 'map', name: '🗺️ Map', description: 'See next 3 cards', rarity: 'common', effect: 'cardPreview' },
            { id: 'gloves', name: '🧤 Gloves', description: 'Weapons last 1 extra use', rarity: 'common', effect: 'extraDurability' },
            { id: 'book', name: '📖 Old Book', description: 'Special cards +10% more common', rarity: 'common', effect: 'moreSpecials' },
            { id: 'bell', name: '🔔 Bell', description: 'Gold visible on cards', rarity: 'common', effect: 'goldSight' },
            { id: 'key', name: '🗝️ Old Key', description: 'Unlock 1 free shop item', rarity: 'common', effect: 'freeItem' },
            { id: 'mirror_shard', name: '🪞 Mirror Shard', description: 'Reflect 2 damage once per room', rarity: 'common', effect: 'weakReflect' },
            { id: 'charm', name: '✨ Charm', description: 'Start with 10 extra gold', rarity: 'common', effect: 'startGold' },
            { id: 'tooth', name: '🦷 Monster Tooth', description: 'Monsters give +1 gold', rarity: 'common', effect: 'monsterGold' },
            { id: 'clover', name: '☘️ Four Leaf Clover', description: 'Avoid can be used 2x in row', rarity: 'common', effect: 'doubleAvoid' },
            { id: 'lantern', name: '🏮 Lantern', description: 'Events give +2 gold', rarity: 'common', effect: 'eventGold' },
            
            // === INCOMUM (15) - Efeitos moderados ===
            { id: 'silver_shield', name: '🛡️ Silver Shield', description: '+5 maximum health', rarity: 'uncommon', effect: 'maxHealth' },
            { id: 'silver_ring', name: '💍 Silver Ring', description: '+2 damage to all weapons', rarity: 'uncommon', effect: 'power' },
            { id: 'healer', name: '💚 Healing Amulet', description: 'Potions heal +2 HP', rarity: 'uncommon', effect: 'healBonus' },
            { id: 'greedy', name: '💰 Golden Idol', description: 'Gain 3 gold per room cleared', rarity: 'uncommon', effect: 'goldPerRoom' },
            { id: 'vampire', name: '🧛 Vampiric Fang', description: 'Heal 2 HP when defeating monsters', rarity: 'uncommon', effect: 'lifesteal' },
            { id: 'meditation', name: '🧘 Meditation Stone', description: 'Heal 1 HP per room', rarity: 'uncommon', effect: 'passive_heal' },
            { id: 'armor', name: '🦾 Iron Armor', description: 'Reduce all damage by 1', rarity: 'uncommon', effect: 'damageReduction' },
            { id: 'boots', name: '👟 Speed Boots', description: 'Draw 1 extra card per dungeon', rarity: 'uncommon', effect: 'extraDraw' },
            { id: 'gauntlet', name: '🥊 Power Gauntlet', description: 'First attack each room +3 damage', rarity: 'uncommon', effect: 'firstStrike' },
            { id: 'necklace', name: '📿 Holy Necklace', description: 'Events heal 2 HP', rarity: 'uncommon', effect: 'eventHeal' },
            { id: 'crystal', name: '💎 Crystal', description: 'Shop items 15% cheaper', rarity: 'uncommon', effect: 'discount' },
            { id: 'hourglass', name: '⏳ Hourglass', description: 'Berserk lasts 1 extra turn', rarity: 'uncommon', effect: 'longerBerserk' },
            { id: 'magnet', name: '🧲 Magnet', description: '+40% gold from all sources', rarity: 'uncommon', effect: 'goldBonus' },
            { id: 'ring_fire', name: '🔥 Fire Ring', description: 'Combo damage +1 per stack', rarity: 'uncommon', effect: 'comboBoost' },
            { id: 'cloak', name: '🧥 Cloak', description: 'First damage each room is 0', rarity: 'uncommon', effect: 'firstDodge' },
            
            // === RARA (8) - Efeitos poderosos ===
            { id: 'gold_shield', name: '🛡️ Golden Shield', description: '+10 maximum health', rarity: 'rare', effect: 'bigHealth' },
            { id: 'blade', name: '🗡️ Dancing Blade', description: '+3 weapon damage', rarity: 'rare', effect: 'bigPower' },
            { id: 'lucky', name: '🍀 Lucky Charm', description: '+60% gold from all sources', rarity: 'rare', effect: 'bigGoldBonus' },
            { id: 'warrior', name: '⚡ Thunder Gauntlet', description: '20% chance to deal double damage', rarity: 'rare', effect: 'criticalChance' },
            { id: 'tank', name: '🏰 Fortress Armor', description: 'Start each room with 1 HP shield', rarity: 'rare', effect: 'roomShield' },
            { id: 'master_smith', name: '🔨 Master Smith', description: 'Repairs weapon at end of each room', rarity: 'rare', effect: 'auto_repair' },
            { id: 'crown', name: '👑 Crown', description: 'Double all stat bonuses from relics', rarity: 'rare', effect: 'doubleRelics' },
            { id: 'orb', name: '🔮 Magic Orb', description: 'Special cards appear 2x more', rarity: 'rare', effect: 'manySpecials' },
            
            // === LENDÁRIA (2) - Game-changing ===
            { id: 'phoenix', name: '🐦 Phoenix Feather', description: 'Revive once with 10 HP', rarity: 'legendary', effect: 'revive', oneTime: true, used: false },
            { id: 'durable_weapons', name: '🛠️ Eternal Forge', description: 'Weapons never break', rarity: 'legendary', effect: 'infinite_durability' }
        ];

        const EVENTS = [
            { id: 'shrine', title: '🔮 Mysterious Shrine', text: 'You find a glowing shrine. An ancient voice offers you a choice...',
                choices: [
                    { text: '❤️ Sacrifice 5 HP for +2 weapon damage permanently (Gain Berserker Ring)',
                        effect: () => {
                            if (game.health > 5) { game.health -= 5; game.relics.push({...RELICS.find(r => r.id === 'berserker')}); showMessage('Gained Berserker Ring!', 'success'); updateRelicsDisplay(); } 
                            else { showMessage('Not enough HP!', 'danger'); }
                        }},
                    { text: '💰 Offer 20 gold for +5 max HP',
                        effect: () => {
                            if (game.gold >= 20) { game.gold -= 20; game.maxHealth += 5; game.health += 5; showMessage('+5 Max HP!', 'success'); } 
                            else { showMessage('Not enough gold!', 'danger'); }
                        }},
                    { text: '🚪 Leave quietly', effect: () => { showMessage('You leave the shrine untouched.', 'info'); }}
                ]},
            { id: 'merchant', title: '🎒 Traveling Merchant', text: 'A friendly merchant offers you a deal!',
                choices: [
                    { text: '💊 Buy healing potion for 15 gold (heal 8 HP)',
                        effect: () => {
                            if (game.gold >= 15) { game.gold -= 15; game.health = Math.min(game.maxHealth, game.health + 8); showMessage('Healed 8 HP!', 'success'); } 
                            else { showMessage('Not enough gold!', 'danger'); }
                        }},
                    { text: '🔮 Buy random relic for 30 gold',
                        effect: () => {
                            if (game.gold >= 30) { game.gold -= 30; giveRandomRelic(); } 
                            else { showMessage('Not enough gold!', 'danger'); }
                        }},
                    { text: '👋 Say goodbye', effect: () => { showMessage('Maybe next time!', 'info'); }}
                ]},
            { id: 'fountain', title: '💧 Whispering Fountain', text: 'You find a shimmering fountain. The water looks pure.',
                choices: [
                    { text: 'Drink (Heal 5 HP)', effect: () => { 
                        const heal = Math.min(5, game.maxHealth - game.health);
                        game.health += heal;
                        showMessage(`💧 You feel refreshed! +${heal} HP`, 'success');
                        updateUI();
                    }},
                    { text: 'Ignore', effect: () => { showMessage('You move on.', 'info'); }}
                ]},
            { id: 'gambler', title: '🎲 Shady Gambler', text: 'A figure offers a game. "Bet 10 Gold. Win 25 or lose it all."',
                choices: [
                    { text: 'Bet (Requires 10 Gold)', effect: () => { 
                        if (game.gold < 10) { showMessage('🎲 "You don\'t have enough gold!" he scoffs.', 'warning'); return; }
                        game.gold -= 10;
                        if (Math.random() < 0.4) { showMessage('🎲 You won! +25 Gold!', 'success'); earnGold(25); } 
                        else { showMessage('🎲 You lost! -10 Gold!', 'danger'); }
                        updateUI();
                    }},
                    { text: 'Refuse', effect: () => { showMessage('You walk away from the game.', 'info'); }}
                ]},
            { id: 'treasure', title: '🏺 Cursed Treasure', text: 'A golden chest glimmers before you... but dark energy surrounds it.',
                choices: [
                    { text: '💰 Take the risk (+50 gold, -10 HP)', effect: () => { 
                        if (game.health > 10) { game.health -= 10; earnGold(50); showMessage('💰 +50 gold! But the curse hurts...', 'success'); }
                        else { showMessage('⚠️ Too risky! You need more than 10 HP!', 'danger'); }
                        updateUI();
                    }},
                    { text: '🔮 Try to cleanse it (50% chance)', effect: () => {
                        if (Math.random() < 0.5) { earnGold(60); showMessage('✨ Cleansed! +60 gold with no curse!', 'success'); }
                        else { game.health -= 15; showMessage('💔 The curse backfired! -15 HP!', 'danger'); }
                        updateUI();
                    }},
                    { text: '🚪 Leave it alone', effect: () => { showMessage('Wisdom over greed.', 'info'); }}
                ]},
            { id: 'witch', title: '🧙 Mysterious Witch', text: 'An old witch offers her services: "I can upgrade your equipment... for a price."',
                choices: [
                    { text: '⚔️ Upgrade weapon (+2 damage, 25 gold)', effect: () => {
                        if (game.gold >= 25 && game.equippedWeapon) { game.gold -= 25; game.equippedWeapon.numValue += 2; showMessage('⚔️ Weapon upgraded!', 'success'); updateUI(); }
                        else if (!game.equippedWeapon) { showMessage('No weapon to upgrade!', 'warning'); }
                        else { showMessage('Not enough gold!', 'danger'); }
                    }},
                    { text: '❤️ Restore all HP (30 gold)', effect: () => {
                        if (game.gold >= 30) { game.gold -= 30; game.health = game.maxHealth; showMessage('❤️ Fully healed!', 'success'); updateUI(); }
                        else { showMessage('Not enough gold!', 'danger'); }
                    }},
                    { text: '🏃 Decline', effect: () => { showMessage('"Your loss, scoundrel!"', 'info'); }}
                ]},
            { id: 'library', title: '📚 Ancient Library', text: 'You discover a library filled with magical tomes.',
                choices: [
                    { text: '📖 Study combat techniques (+1 damage permanent)', effect: () => {
                        game.relics.push({ id: 'study_bonus', name: '📖 Combat Study', description: '+1 damage', rarity: 'common', effect: 'smallPower' });
                        showMessage('📖 You learned new techniques!', 'success');
                        updateRelicsDisplay();
                    }},
                    { text: '🔮 Learn healing magic (+1 HP/room)', effect: () => {
                        game.relics.push({ id: 'healing_study', name: '🔮 Healing Magic', description: '+1 HP per room', rarity: 'uncommon', effect: 'passive_heal' });
                        showMessage('🔮 You mastered healing!', 'success');
                        updateRelicsDisplay();
                    }},
                    { text: '🚪 Leave quickly', effect: () => { showMessage('No time for reading!', 'info'); }}
                ]},
            { id: 'beggar', title: '🙏 Poor Beggar', text: 'A starving beggar asks for help. "Please... just 5 gold for food..."',
                choices: [
                    { text: '❤️ Give 5 gold (Karma reward)', effect: () => {
                        if (game.gold >= 5) { 
                            game.gold -= 5; 
                            game.health = Math.min(game.maxHealth, game.health + 3);
                            showMessage('❤️ Good deed! +3 HP (karma)', 'success'); 
                        } else { showMessage('Not enough gold!', 'danger'); }
                        updateUI();
                    }},
                    { text: '💰 Give 20 gold (Great karma)', effect: () => {
                        if (game.gold >= 20) { 
                            game.gold -= 20;
                            giveRandomRelic('uncommon');
                            showMessage('✨ Your kindness is rewarded! (Relic gained)', 'success');
                        } else { showMessage('Not enough gold!', 'danger'); }
                    }},
                    { text: '🚶 Ignore', effect: () => { showMessage('You walk past...', 'info'); }}
                ]},
            { id: 'blacksmith', title: '⚒️ Dwarven Blacksmith', text: 'A skilled dwarf offers to fix your gear. "I can repair or enhance!"',
                choices: [
                    { text: '🔧 Repair weapon (Full durability, 15 gold)', effect: () => {
                        if (game.gold >= 15 && game.equippedWeapon && game.equippedWeapon.durability < game.equippedWeapon.maxDurability) {
                            game.gold -= 15;
                            game.equippedWeapon.durability = game.equippedWeapon.maxDurability;
                            showMessage('🔧 Weapon fully repaired!', 'success');
                            updateUI();
                        } else if (!game.equippedWeapon) { showMessage('No weapon!', 'warning'); }
                        else if (game.equippedWeapon.durability >= game.equippedWeapon.maxDurability) { showMessage('Already at full durability!', 'info'); }
                        else { showMessage('Not enough gold!', 'danger'); }
                    }},
                    { text: '⭐ Enhance durability (+2 max uses, 25 gold)', effect: () => {
                        if (game.gold >= 25 && game.equippedWeapon) {
                            game.gold -= 25;
                            game.equippedWeapon.maxDurability += 2;
                            game.equippedWeapon.durability += 2;
                            showMessage('⭐ Weapon enhanced!', 'success');
                            updateUI();
                        } else if (!game.equippedWeapon) { showMessage('No weapon!', 'warning'); }
                        else { showMessage('Not enough gold!', 'danger'); }
                    }},
                    { text: '👋 No thanks', effect: () => { showMessage('"Suit yourself!"', 'info'); }}
                ]},
            { id: 'dragon', title: '🐉 Sleeping Dragon', text: 'A dragon sleeps atop a massive hoard of gold. Do you dare...?',
                choices: [
                    { text: '💎 Steal carefully (60% success)', effect: () => {
                        if (Math.random() < 0.6) { 
                            earnGold(40); 
                            showMessage('🤫 +40 gold stolen! The dragon sleeps...', 'success'); 
                        } else { 
                            game.health -= 20; 
                            showMessage('🐉 The dragon wakes! -20 HP!', 'danger'); 
                        }
                        updateUI();
                    }},
                    { text: '🗡️ Fight the dragon! (-15 HP, +80 gold)', effect: () => {
                        if (game.health > 15) {
                            game.health -= 15;
                            earnGold(80);
                            showMessage('🐉 Victory! +80 gold!', 'success');
                        } else { showMessage('Too dangerous!', 'danger'); }
                        updateUI();
                    }},
                    { text: '🏃 Run away', effect: () => { showMessage('Discretion is the better part of valor.', 'info'); }}
                ]},
            { id: 'mirror', title: '🪞 Magic Mirror', text: 'A mystical mirror shows your reflection. "Touch me and face yourself..."',
                choices: [
                    { text: '✨ Accept the challenge (Mirror match)', effect: () => {
                        const damage = Math.floor(game.health * 0.3);
                        game.health -= damage;
                        earnGold(30);
                        showMessage(`🪞 You defeat your reflection! -${damage} HP, +30 gold`, 'success');
                        updateUI();
                    }},
                    { text: '🔮 Ask for wisdom (+5 HP)', effect: () => {
                        game.health = Math.min(game.maxHealth, game.health + 5);
                        showMessage('🔮 The mirror grants clarity. +5 HP', 'success');
                        updateUI();
                    }},
                    { text: '🚪 Leave', effect: () => { showMessage('You look away from the mirror.', 'info'); }}
                ]},
            { id: 'ghost', title: '👻 Friendly Ghost', text: 'A spectral figure appears. "I can help you... or hurt you. Your choice!"',
                choices: [
                    { text: '🎁 Accept help (Random buff)', effect: () => {
                        const buffs = ['dodge', 'berserk', 'goldBonus'];
                        const buff = buffs[Math.floor(Math.random() * buffs.length)];
                        if (buff === 'dodge') { game.dodgeActive = true; showMessage('👻 Next attack dodged!', 'success'); }
                        else if (buff === 'berserk') { game.berserkStacks += 3; showMessage('👻 +3 Berserk stacks!', 'success'); }
                        else { earnGold(20); showMessage('👻 +20 gold!', 'success'); }
                        updateUI();
                    }},
                    { text: '⚔️ Attack the ghost (Risk/reward)', effect: () => {
                        if (Math.random() < 0.5) {
                            earnGold(50);
                            showMessage('👻 The ghost vanishes, dropping gold! +50', 'success');
                        } else {
                            game.health -= 8;
                            showMessage('👻 The ghost counterattacks! -8 HP', 'danger');
                        }
                        updateUI();
                    }},
                    { text: '🙏 Show respect', effect: () => { showMessage('👻 "Wise choice, mortal."', 'info'); }}
                ]},
            { id: 'portal', title: '🌀 Mysterious Portal', text: 'A swirling portal appears. Where does it lead?',
                choices: [
                    { text: '🎲 Jump in! (Random outcome)', effect: () => {
                        const outcomes = ['good', 'great', 'bad'];
                        const result = outcomes[Math.floor(Math.random() * outcomes.length)];
                        if (result === 'good') { game.health += 8; showMessage('🌀 Portal leads to healing springs! +8 HP', 'success'); }
                        else if (result === 'great') { giveRandomRelic(); showMessage('🌀 You found a treasure room! Relic gained!', 'success'); }
                        else { game.health -= 5; showMessage('🌀 Ouch! Rough landing. -5 HP', 'danger'); }
                        updateUI();
                    }},
                    { text: '🔍 Study it first (Safer)', effect: () => {
                        earnGold(15);
                        showMessage('🌀 You analyze the portal and find gold nearby. +15', 'success');
                        updateUI();
                    }},
                    { text: '🚫 Avoid it', effect: () => { showMessage('You don\'t trust strange portals.', 'info'); }}
                ]},
            { id: 'altar', title: '🕯️ Sacrificial Altar', text: 'An ancient altar radiates dark power. "Offer something... gain something greater."',
                choices: [
                    { text: '❤️ Sacrifice 10 HP (Rare relic)', effect: () => {
                        if (game.health > 10) {
                            game.health -= 10;
                            giveRandomRelic('rare');
                            showMessage('🕯️ The altar accepts! Rare relic gained!', 'success');
                        } else { showMessage('Not enough HP!', 'danger'); }
                        updateUI();
                    }},
                    { text: '💰 Sacrifice 30 gold (+10 max HP)', effect: () => {
                        if (game.gold >= 30) {
                            game.gold -= 30;
                            game.maxHealth += 10;
                            game.health += 10;
                            showMessage('🕯️ Power flows through you! +10 max HP', 'success');
                        } else { showMessage('Not enough gold!', 'danger'); }
                        updateUI();
                    }},
                    { text: '🏃 Flee', effect: () => { showMessage('You back away slowly.', 'info'); }}
                ]},
            { id: 'trap', title: '⚠️ Hidden Trap Room', text: 'You trigger a trap! Spikes, arrows, or treasure?',
                choices: [
                    { text: '🛡️ Defend (-5 HP, safe)', effect: () => {
                        game.health -= 5;
                        showMessage('⚠️ You block most damage! -5 HP', 'warning');
                        updateUI();
                    }},
                    { text: '🤸 Dodge! (50% avoid all)', effect: () => {
                        if (Math.random() < 0.5) {
                            earnGold(25);
                            showMessage('🤸 Perfect dodge! Found hidden gold! +25', 'success');
                        } else {
                            game.health -= 12;
                            showMessage('⚠️ Failed! Hit by trap! -12 HP', 'danger');
                        }
                        updateUI();
                    }},
                    { text: '💰 Check for treasure (Risk)', effect: () => {
                        if (Math.random() < 0.3) {
                            giveRandomRelic();
                            showMessage('🎁 Trap was a ruse! Relic found!', 'success');
                        } else {
                            game.health -= 15;
                            showMessage('💔 Trap activates! -15 HP', 'danger');
                        }
                        updateUI();
                    }}
                ]}
        ];
        
        // ===================================
        // NEW SHOP_ITEMS LIST
        // ===================================
        const SHOP_ITEMS = [
            {
                id: 'heal_small', name: '💊 Small Potion', description: 'Restore 8 HP', price: 18,
                buy: () => { game.health = Math.min(game.maxHealth, game.health + 8); showMessage('Healed 8 HP!', 'success'); return true; }
            },
            {
                id: 'heal_large', name: '🍾 Large Potion', description: 'Restore 15 HP', price: 30,
                buy: () => { game.health = Math.min(game.maxHealth, game.health + 15); showMessage('Healed 15 HP!', 'success'); return true; }
            },
            {
                id: 'heal_full', name: '✨ Elixir', description: 'Restore to full HP', price: 50,
                buy: () => { game.health = game.maxHealth; showMessage('Fully healed!', 'success'); return true; }
            },
            {
                id: 'max_health', name: '❤️ Heart Container', description: '+5 maximum HP', price: 35,
                buy: () => { game.maxHealth += 5; game.health += 5; showMessage('+5 Max HP!', 'success'); return true; }
            },
            {
                id: 'max_health_big', name: '❤️❤️ Large Heart', description: '+10 maximum HP', price: 60,
                buy: () => { game.maxHealth += 10; game.health += 10; showMessage('+10 Max HP!', 'success'); return true; }
            },
            {
                id: 'weapon_upgrade', name: '⚔️ Weapon Polish', description: 'Upgrade current weapon by +2', price: 40,
                buy: () => {
                    if (game.equippedWeapon) {
                        game.equippedWeapon.numValue += 2;
                        showMessage('Weapon upgraded!', 'success');
                        updateUI();
                        return true;
                    } else {
                        showMessage('No weapon equipped!', 'danger');
                        return false;
                    }
                }
            },
            {
                id: 'weapon_big_upgrade', name: '⚔️⚔️ Master Forge', description: 'Upgrade current weapon by +5', price: 70,
                buy: () => {
                    if (game.equippedWeapon) {
                        game.equippedWeapon.numValue += 5;
                        showMessage('Weapon greatly upgraded!', 'success');
                        updateUI();
                        return true;
                    } else {
                        showMessage('No weapon equipped!', 'danger');
                        return false;
                    }
                }
            },
            {
                id: 'common_relic', name: '⚪ Common Relic', description: 'Gain a random common relic', price: 25,
                buy: () => { giveRelicByRarity('common'); return true; }
            },
            {
                id: 'uncommon_relic', name: '🟢 Uncommon Relic', description: 'Gain a random uncommon relic', price: 50,
                buy: () => { giveRelicByRarity('uncommon'); return true; }
            },
            {
                id: 'rare_relic', name: '🔵 Rare Relic', description: 'Gain a random rare relic', price: 100,
                buy: () => { giveRelicByRarity('rare'); return true; }
            },
            {
                id: 'legendary_relic', name: '🟠 Legendary Relic', description: 'Gain a random legendary relic', price: 200,
                buy: () => { giveRelicByRarity('legendary'); return true; }
            },
            {
                id: 'repair_weapon', name: '🔧 Weapon Repair', description: 'Restore weapon durability to full', price: 25,
                buy: () => {
                    if (game.equippedWeapon && game.equippedWeapon.durability < game.equippedWeapon.maxDurability) {
                        game.equippedWeapon.durability = game.equippedWeapon.maxDurability;
                        showMessage(`🔧 Weapon repaired! (${game.equippedWeapon.durability}/${game.equippedWeapon.maxDurability})`, 'success');
                        updateUI();
                        return true;
                    } else if (!game.equippedWeapon) {
                        showMessage('No weapon equipped!', 'danger');
                        return false;
                    } else {
                        showMessage('Weapon already at full durability!', 'info');
                        return false;
                    }
                }
            },
            {
                id: 'remove_card', name: '🔥 Card Removal', description: 'Remove a card from deck (coming soon)', price: 25,
                buy: () => { showMessage('Feature coming soon!', 'info'); return false; }
            }
        ];
        
        let permanentUnlocks = {
            startHealth: false, startGold: false, betterDrops: false, extraRelic: false,
            strongerWeapons: false, masterHealer: false, richStart: false, comboMaster: false,
            bigStart: false, ultraWeapons: false, godMode: false, relicMaster: false,
            shopDiscount: false, eventLuck: false, survivalBonus: false, speedBonus: false,
            weaponMaster: false, potionMaster: false, goldRush: false, comboGod: false,
            durablePlus: false, startPower: false, megaHealth: false, luckyCharm: false,
            berserkMaster: false, mirrorMaster: false, dodgeMaster: false, criticalStrike: false,
            lifeSteal: false, thornsArmor: false
        };
        const UNLOCKS = [
            // Tier 1: Beginner (Easy)
            { id: 'startHealth', name: '❤️ Tough Start', description: 'Start each run with +5 max HP', requirement: 'Clear 10 rooms', check: () => getTotalStat('roomsCleared') >= 10 },
            { id: 'startGold', name: '💰 Rich Start', description: 'Start each run with 30 gold', requirement: 'Earn 200 gold (lifetime)', check: () => getTotalStat('totalGoldEarned') >= 200 },
            { id: 'strongerWeapons', name: '⚔️ Weapon Expert', description: 'All weapons get +1 damage', requirement: 'Defeat 50 monsters', check: () => getTotalStat('monstersSlain') >= 50 },
            { id: 'masterHealer', name: '💚 Healer', description: 'All potions heal +2 HP', requirement: 'Use 20 potions', check: () => getTotalStat('potionsUsed') >= 20 },
            { id: 'comboMaster', name: '🔥 Combo Start', description: 'Combos start at 1 instead of 0', requirement: 'Get a 5x combo', check: () => getTotalStat('maxCombo') >= 5 },
            
            // Tier 2: Intermediate (Medium)
            { id: 'betterDrops', name: '🍀 Lucky', description: '+30% gold from all sources', requirement: 'Earn 500 gold (lifetime)', check: () => getTotalStat('totalGoldEarned') >= 500 },
            { id: 'extraRelic', name: '🔮 Relic Start', description: 'Start each run with 1 random relic', requirement: 'Clear 30 rooms', check: () => getTotalStat('roomsCleared') >= 30 },
            { id: 'richStart', name: '💎 Wealthy Start', description: 'Start with 50 gold instead of 30', requirement: 'Earn 1000 gold (lifetime)', check: () => getTotalStat('totalGoldEarned') >= 1000 },
            { id: 'weaponMaster', name: '⚔️ Weapon Master', description: 'All weapons get +2 damage (stacks with Expert)', requirement: 'Equip 100 weapons', check: () => getTotalStat('weaponsEquipped') >= 100 },
            { id: 'potionMaster', name: '💊 Potion Master', description: 'All potions heal +4 HP (stacks)', requirement: 'Use 75 potions', check: () => getTotalStat('potionsUsed') >= 75 },
            
            // Tier 3: Advanced (Hard)
            { id: 'bigStart', name: '❤️❤️ Warrior Start', description: 'Start with +10 max HP (stacks)', requirement: 'Clear 75 rooms', check: () => getTotalStat('roomsCleared') >= 75 },
            { id: 'durablePlus', name: '🛠️ Durable Weapons', description: 'Weapons have +1 durability on all difficulties', requirement: 'Win 3 games', check: () => getTotalStat('gamesWon') >= 3 },
            { id: 'goldRush', name: '💰💰 Gold Rush', description: '+50% gold from all sources (stacks)', requirement: 'Earn 3000 gold (lifetime)', check: () => getTotalStat('totalGoldEarned') >= 3000 },
            { id: 'shopDiscount', name: '🏪 Merchant Friend', description: '20% discount in all shops', requirement: 'Buy 50 items from shop', check: () => getTotalStat('itemsBought') >= 50 },
            { id: 'relicMaster', name: '🔮🔮 Double Relic Start', description: 'Start with 2 random relics', requirement: 'Clear 100 rooms', check: () => getTotalStat('roomsCleared') >= 100 },
            
            // Tier 4: Expert (Very Hard)
            { id: 'ultraWeapons', name: '⚔️⚔️⚔️ Weapon God', description: 'All weapons get +4 damage total', requirement: 'Defeat 500 monsters', check: () => getTotalStat('monstersSlain') >= 500 },
            { id: 'startPower', name: '⚡ Power Start', description: 'Start each run with a random weapon', requirement: 'Win 5 games', check: () => getTotalStat('gamesWon') >= 5 },
            { id: 'megaHealth', name: '❤️❤️❤️ Titan Health', description: 'Start with +20 max HP total', requirement: 'Clear 150 rooms', check: () => getTotalStat('roomsCleared') >= 150 },
            { id: 'eventLuck', name: '🎲 Event Master', description: 'Events appear 50% more often', requirement: 'Complete 50 events', check: () => getTotalStat('eventsCompleted') >= 50 },
            { id: 'luckyCharm', name: '🍀🍀 Super Lucky', description: '+60% gold from all sources', requirement: 'Earn 5000 gold (lifetime)', check: () => getTotalStat('totalGoldEarned') >= 5000 },
            
            // Tier 5: Master (Extreme)
            { id: 'comboGod', name: '🔥🔥🔥 Combo God', description: 'Combos start at 2, +2 damage per combo', requirement: 'Get a 15x combo', check: () => getTotalStat('maxCombo') >= 15 },
            { id: 'survivalBonus', name: '💪 Survivor', description: 'Start with +5 HP when below 50% health', requirement: 'Win 10 games', check: () => getTotalStat('gamesWon') >= 10 },
            { id: 'speedBonus', name: '⏱️ Speedrunner', description: 'Gain 2x gold for winning under 5 minutes', requirement: 'Win a game in under 5 minutes', check: () => getTotalStat('fastestWin') > 0 && getTotalStat('fastestWin') < 300 },
            { id: 'berserkMaster', name: '🔥 Berserk God', description: 'Berserk gives +7 damage instead of +5', requirement: 'Use Berserk 50 times', check: () => getTotalStat('berserkUses') >= 50 },
            { id: 'mirrorMaster', name: '🪞 Mirror Master', description: 'Mirror reflects 15 damage instead of 10', requirement: 'Win a game on Hard', check: () => getTotalStat('hardWins') >= 1 },
            
            // Tier 6: Legend (Insane)
            { id: 'godMode', name: '👑 God Mode', description: 'Start with +15 max HP, 100 gold, 2 relics', requirement: 'Win 20 games', check: () => getTotalStat('gamesWon') >= 20 },
            { id: 'dodgeMaster', name: '🛡️ Dodge God', description: 'Dodge cards avoid 2 attacks instead of 1', requirement: 'Clear 200 rooms', check: () => getTotalStat('roomsCleared') >= 200 },
            { id: 'criticalStrike', name: '💥 Critical Master', description: '10% chance to deal 3x damage', requirement: 'Defeat 1000 monsters', check: () => getTotalStat('monstersSlain') >= 1000 },
            { id: 'lifeSteal', name: '🧛 Vampiric', description: 'Heal 1 HP on every perfect kill', requirement: 'Win 15 games', check: () => getTotalStat('gamesWon') >= 15 },
            { id: 'thornsArmor', name: '🌵 Thorns', description: 'Reflect 2 damage to all attackers', requirement: 'Win 3 games on Hard', check: () => getTotalStat('hardWins') >= 3 }
        ];

        // Support Functions (Shop, Relics, etc.)
        function earnGold(amount) {
            let mult = 1.0;
            
            // Gold multipliers from relics
            if (game.relics.some(r => r.id === 'lucky_penny')) mult += 0.2;
            if (game.relics.some(r => r.id === 'magnet')) mult += 0.4;
            if (game.relics.some(r => r.id === 'lucky')) mult += 0.6;
            
            // Permanent unlocks
            if (permanentUnlocks.betterDrops) mult += 0.3;
            if (permanentUnlocks.goldRush) mult += 0.5;
            if (permanentUnlocks.luckyCharm) mult += 0.6;
            
            const actual = Math.floor(amount * mult);
            game.gold += actual;
            game.totalGoldEarned += actual;
            updateRunningScore(); // Update score
            updateUI();
        }

        // Give relic by specific rarity
        function giveRelicByRarity(rarity) {
            let available = RELICS.filter(r => r.rarity === rarity && !game.relics.find(gr => gr.id === r.id));
            
            // If no new relics of this rarity, allow duplicates
            if (available.length === 0) {
                available = RELICS.filter(r => r.rarity === rarity);
            }
            
            if (available.length === 0) {
                showMessage('No relics of this rarity available!', 'warning');
                return;
            }
            
            const randomRelic = available[Math.floor(Math.random() * available.length)];
            game.relics.push({...randomRelic, used: false});
            
            // Apply immediate health effects
            if (randomRelic.effect === 'smallHealth') { game.maxHealth += 3; game.health += 3; }
            if (randomRelic.effect === 'maxHealth') { game.maxHealth += 5; game.health += 5; }
            if (randomRelic.effect === 'bigHealth') { game.maxHealth += 10; game.health += 10; }
            if (randomRelic.effect === 'tinyHealth') { game.maxHealth += 1; game.health += 1; }
            
            const rarityColors = { common: '⚪', uncommon: '🟢', rare: '🔵', legendary: '🟠' };
            showMessage(`${rarityColors[rarity]} Relic: ${randomRelic.name}!`, 'success');
            updateRelicsDisplay();
            updateUI();
        }
        
        // Give random relic (defaults to common for unlocks)
        function giveRandomRelic(rarityFilter = 'common') {
            giveRelicByRarity(rarityFilter);
        }
        
        function giveRareRelic() {
            giveRelicByRarity('rare');
        }

        function updateRelicsDisplay() {
            if (game.relics.length === 0) {
                relicsList.innerHTML = '<div class="relic-effect">No relics yet.</div>';
                return;
            }
            relicsList.innerHTML = game.relics.map(r => `
                <div class="relic-item ${r.used ? 'used' : ''}">
                    <div class="relic-name">${r.name}</div>
                    <div class="relic-effect">${r.description}</div>
                </div>
            `).join('');
        }

        function getRelicBonus(type) {
            let bonus = 0;
            game.relics.forEach(r => {
                if (r.effect === type) {
                    // Power bonuses
                    if (type === 'smallPower') bonus += 1;
                    if (type === 'power') bonus += 2;
                    if (type === 'bigPower') bonus += 3;
                    
                    // Heal bonuses
                    if (type === 'smallHealBonus') bonus += 1;
                    if (type === 'healBonus') bonus += 2;
                    
                    // Gold bonuses
                    if (type === 'smallGoldPerRoom') bonus += 2;
                    if (type === 'goldPerRoom') bonus += 3;
                }
            });
            
            // Permanent unlocks bonuses
            if (type === 'power' && permanentUnlocks.strongerWeapons) bonus += 1;
            if (type === 'healBonus' && permanentUnlocks.masterHealer) bonus += 2;
            
            // Sum all power types for total weapon bonus
            if (type === 'totalPower') {
                bonus += getRelicBonus('smallPower');
                bonus += getRelicBonus('power');
                bonus += getRelicBonus('bigPower');
            }
            
            return bonus;
        }

        function triggerRandomEvent() {
            if (game.gameOver) return;
            const event = EVENTS[Math.floor(Math.random() * EVENTS.length)];
            showEventModal(event);
        }
        
        function showEventModal(event) {
            eventTitle.textContent = event.title;
            eventText.innerHTML = event.text;
            eventChoices.innerHTML = ''; // Clear previous choices
            
            event.choices.forEach(choice => {
                const choiceEl = document.createElement('div');
                choiceEl.className = 'event-choice';
                choiceEl.innerHTML = choice.text;
                choiceEl.onclick = () => {
                    choice.effect();
                    eventModal.classList.remove('active');
                    
                    // Track event completion for achievement
                    const saved = localStorage.getItem('scoundrel_lifetime_stats');
                    let lifetimeStats = saved ? JSON.parse(saved) : {};
                    lifetimeStats.eventsCompleted = (lifetimeStats.eventsCompleted || 0) + 1;
                    localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
                    
                    // Re-enable buttons if room is empty
                    if (game.room.length === 0) {
                        btnDrawRoom.disabled = false;
                        btnAvoidRoom.disabled = game.lastActionWasAvoid;
                    }
                    updateUI();
                    checkGameState();
                    checkAchievements();
                };
                eventChoices.appendChild(choiceEl);
            });
            
            // Disable game buttons while event is active
            btnDrawRoom.disabled = true;
            btnAvoidRoom.disabled = true;
            eventModal.classList.add('active');
        }
        
        function openShop() {
            updateShopDisplay();
            // Disable game buttons
            btnDrawRoom.disabled = true;
            btnAvoidRoom.disabled = true;
            shopModal.classList.add('active');
            
            // Switch to shop music
            music.switchContext('shop');
            
            // Track shop visit for achievement
            const saved = localStorage.getItem('scoundrel_lifetime_stats');
            let lifetimeStats = saved ? JSON.parse(saved) : {};
            lifetimeStats.shopsVisited = (lifetimeStats.shopsVisited || 0) + 1;
            localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
            checkAchievements();
        }

        function updateShopDisplay() {
            shopGoldAmount.textContent = game.gold;
            shopItems.innerHTML = ''; // Clear shop
            
            SHOP_ITEMS.forEach(item => {
                const itemEl = document.createElement('div');
                itemEl.className = 'shop-item';
                
                itemEl.innerHTML = `
                    <div class="item-info">
                        <div class="item-name">${item.name}</div>
                        <div class="item-description">${item.description}</div>
                        <div class="item-price">Price: ${item.price} 🪙</div>
                    </div>
                    <button class="buy-btn" data-item-id="${item.id}">Buy</button>
                `;
                
                const buyBtn = itemEl.querySelector('.buy-btn');
                if (game.gold < item.price) {
                    buyBtn.disabled = true;
                }
                
                buyBtn.onclick = () => buyItem(item);
                
                shopItems.appendChild(itemEl);
            });
        }
        
        function buyItem(item) {
            if (game.gold < item.price) {
                showMessage('Not enough gold!', 'warning');
                return;
            }
            
            const success = item.buy(); // Run the item's function
            if (success) {
                game.gold -= item.price;
                showMessage(`Purchased ${item.name}!`, 'success');
                playSound('special');
                
                // Track item purchase for achievement
                const saved = localStorage.getItem('scoundrel_lifetime_stats');
                let lifetimeStats = saved ? JSON.parse(saved) : {};
                lifetimeStats.itemsBought = (lifetimeStats.itemsBought || 0) + 1;
                localStorage.setItem('scoundrel_lifetime_stats', JSON.stringify(lifetimeStats));
                
                updateUI();
                updateShopDisplay(); // Re-render shop
                checkAchievements();
            } else {
                playSound('error');
            }
        }
        
        function closeShop() {
            shopModal.classList.remove('active');
            // Return to gameplay music
            music.switchContext('gameplay');
            if (game.room.length === 0) {
                btnDrawRoom.disabled = false;
                btnAvoidRoom.disabled = game.lastActionWasAvoid;
            }
        }

        // Modal open/close functions
        function showTutorial() { tutorialModal.classList.add('active'); }
        
        function openUnlocks() { 
            updateUnlocksDisplay();
            unlocksModal.classList.add('active');
        }
        
        function updateUnlocksDisplay() { 
            const unlocksList = document.getElementById('unlocksList');
            unlocksList.innerHTML = UNLOCKS.map(unlock => {
                const isUnlocked = permanentUnlocks[unlock.id];
                const canUnlock = !isUnlocked && unlock.check();
                return `
                <div class="unlock-item ${isUnlocked ? 'unlocked' : (canUnlock ? '' : 'locked')}">
                    <div class="item-info">
                        <div class="item-name">${unlock.name}</div>
                        <div class="item-description">${unlock.description}</div>
                        <div class="unlock-requirement">
                            ${isUnlocked ? '✅ UNLOCKED' : 
                              (canUnlock ? '✨ READY TO UNLOCK!' : `🔒 ${unlock.requirement}`)}
                        </div>
                    </div>
                    ${!isUnlocked && canUnlock ? `
                        <button class="buy-btn" onclick="unlockUpgradeWrapper('${unlock.id}')">
                            Unlock
                        </button>
                    ` : ''}
                </div>
            `}).join('');
        }
        
        window.unlockUpgradeWrapper = (unlockId) => {
            permanentUnlocks[unlockId] = true;
            saveUnlocks();
            showMessage('✨ Unlock activated! Will apply to next run.', 'success');
            playSound('special');
            updateUnlocksDisplay();
        }
        
        function loadUnlocks() {
             const saved = localStorage.getItem('scoundrel_unlocks');
             if(saved) {
                try {
                    const parsed = JSON.parse(saved);
                    permanentUnlocks = { ...permanentUnlocks, ...parsed }; // This merges the saved data into the default structure
                } catch(e) { console.error("Failed to parse unlocks:", e); }
             }
        }
        function saveUnlocks() { 
            UNLOCKS.forEach(unlock => {
                if (!permanentUnlocks[unlock.id] && unlock.check()) {
                    // We don't unlock here, just check. Unlocking is manual.
                }
            });
            localStorage.setItem('scoundrel_unlocks', JSON.stringify(permanentUnlocks)); 
        }
        
        function applyPermanentUnlocks() {
            if (permanentUnlocks.startGold) earnGold(30);
            if (permanentUnlocks.richStart) earnGold(20); // Total 50
            if (permanentUnlocks.extraRelic) giveRandomRelic();
        }

        // ============================================
        // LEADERBOARD (FIREBASE)
        // ============================================
        async function submitScoreToLeaderboard(score, gameTime) {
            if (!db || !appId || !userId) throw new Error("Firebase is not ready");
            
            const playerName = playerNameInput.value.trim() || 'Scoundrel';
            
            // Salvar em collection específica por dificuldade
            const collectionName = `leaderboard_${game.difficulty}`;
            const leaderboardCol = collection(db, `/artifacts/${appId}/public/data/${collectionName}`);
            
            const scoreData = {
                name: playerName.substring(0, 20),
                score: score,
                userId: userId,
                difficulty: game.difficulty,
                time: gameTime,
                health: game.health,
                combo: game.stats.maxCombo,
                gold: game.totalGoldEarned,
                createdAt: new Date().toISOString()
            };
            
            await addDoc(leaderboardCol, scoreData);
            console.log(`Score submitted to ${collectionName}:`, scoreData);
        }

        // Current selected difficulty for leaderboard
        let currentLeaderboardDifficulty = 'easy';

        async function showLeaderboard(difficulty = 'easy') {
            leaderboardModal.classList.add('active');
            currentLeaderboardDifficulty = difficulty;
            await loadLeaderboardForDifficulty(difficulty);
        }

        async function loadLeaderboardForDifficulty(difficulty) {
            const listDiv = document.getElementById('leaderboardList');
            listDiv.innerHTML = '<p style="text-align: center; color: #aaa;">Loading scores...</p>';
            
            // Validate difficulty
            if (!difficulty || typeof difficulty !== 'string') {
                difficulty = 'easy'; // Default fallback
            }
            
            if (!db || !appId) {
                listDiv.innerHTML = `
                    <div style="text-align: center; padding: 40px 20px;">
                        <p style="color: #ffd93d; font-size: 1.2em; margin-bottom: 15px;">📡 Offline Mode</p>
                        <p style="color: #aaa;">Leaderboard requires online connection.</p>
                        <p style="color: #aaa; font-size: 0.9em; margin-top: 10px;">
                            Your progress and achievements are still saved locally!
                        </p>
                    </div>
                `;
                return;
            }

            try {
                // Carregar da collection específica da dificuldade
                const collectionName = `leaderboard_${difficulty}`;
                const leaderboardCol = collection(db, `/artifacts/${appId}/public/data/${collectionName}`);
                const q = query(leaderboardCol, limit(100)); // Get latest 100
                
                const querySnapshot = await getDocs(q);
                let scores = [];
                querySnapshot.forEach(doc => scores.push(doc.data()));
                
                // Sort on client (mandatory)
                scores.sort((a, b) => b.score - a.score);
                
                const top10 = scores.slice(0, 10);
                
                if (top10.length === 0) {
                    const diffIcons = { easy: '🟢', normal: '🟡', hard: '🔴', endless: '♾️' };
                    const diffName = difficulty ? difficulty.toUpperCase() : 'UNKNOWN';
                    listDiv.innerHTML = `<p style="text-align: center; color: #aaa;">No scores yet for ${diffIcons[difficulty] || '❓'} ${diffName}.<br>Be the first!</p>`;
                    return;
                }
                
                listDiv.innerHTML = top10.map((entry, index) => `
                    <div class="leaderboard-entry">
                        <span class="leaderboard-rank">#${index + 1}</span>
                        <div style="flex: 1;">
                            <div class="leaderboard-name">${entry.name || 'Scoundrel'}</div>
                            <div class="leaderboard-details" style="font-size: 0.8em; color: #aaa;">
                                ${entry.time}s | ${entry.combo}x Combo | ${entry.gold}🪙
                            </div>
                        </div>
                        <span class="leaderboard-score">${entry.score}</span>
                    </div>
                `).join('');

            } catch (e) {
                console.error("Error fetching leaderboard:", e);
                listDiv.innerHTML = `<p style="text-align: center; color: #ff6b6b;">Error loading: ${e.message}</p>`;
            }
        }

        // Switch leaderboard difficulty (chamada pelos tabs)
        window.switchLeaderboardDifficulty = async function(difficulty) {
            currentLeaderboardDifficulty = difficulty;
            
            // Update tab active state
            document.querySelectorAll('.difficulty-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.difficulty === difficulty) {
                    tab.classList.add('active');
                }
            });
            
            // Load new leaderboard
            await loadLeaderboardForDifficulty(difficulty);
        }
        
        // ============================================
        // PERMANENT STATS (LOCALSTORAGE)
        // ============================================
        function loadPermanentStats() {
            const saved = localStorage.getItem('scoundrel_permanent_stats');
            if (saved) {
                try {
                    permanentStats = JSON.parse(saved);
                } catch(e) {
                    permanentStats = { gamesWon: 0, hardWins: 0, fastestWin: 0 };
                }
            } else {
                permanentStats = { gamesWon: 0, hardWins: 0, fastestWin: 0 };
            }
        }
        function savePermanentStats() {
            localStorage.setItem('scoundrel_permanent_stats', JSON.stringify(permanentStats));
        }
        
        function getTotalStat(stat) {
            const stats = storage.get('scoundrel_lifetime_stats', {});
            return stats[stat] || 0;
        }

        function updateLifetimeStats() {
            storage.update('scoundrel_lifetime_stats', stats => ({
                ...stats,
                monstersSlain: (stats.monstersSlain || 0) + game.stats.monstersSlain,
                roomsCleared: (stats.roomsCleared || 0) + game.stats.roomsCleared,
                potionsUsed: (stats.potionsUsed || 0) + game.stats.potionsUsed,
                totalGoldEarned: (stats.totalGoldEarned || 0) + game.totalGoldEarned,
                maxCombo: Math.max((stats.maxCombo || 0), game.stats.maxCombo),
                weaponsEquipped: (stats.weaponsEquipped || 0) + game.stats.weaponsEquipped,
                specialsUsed: (stats.specialsUsed || 0) + game.stats.specialsUsed,
                roomsAvoided: (stats.roomsAvoided || 0) + game.stats.roomsAvoided,
                cardsHeld: (stats.cardsHeld || 0) + game.stats.cardsHeld,
                gamesWon: (stats.gamesWon || 0) + game.stats.gamesWon,
                // Difficulty-specific wins
                easyWins: game.stats.gamesWon > 0 && game.difficulty === 'easy' ? (stats.easyWins || 0) + 1 : (stats.easyWins || 0),
                normalWins: game.stats.gamesWon > 0 && game.difficulty === 'normal' ? (stats.normalWins || 0) + 1 : (stats.normalWins || 0),
                hardWins: game.stats.gamesWon > 0 && game.difficulty === 'hard' ? (stats.hardWins || 0) + 1 : (stats.hardWins || 0)
            }));
            
            // Check achievements after updating stats
            checkAllAchievements();
        }

        // ============================================
        // ACHIEVEMENTS SYSTEM
        // ============================================
        function getLifetimeStat(stat) {
            return getTotalStat(stat); // Alias for achievements
        }
        
        function loadAchievements() {
            return storage.get('dungeon_scoundrel_achievements', []);
        }
        
        function saveAchievements(unlockedIds) {
            storage.set('dungeon_scoundrel_achievements', unlockedIds);
        }
        
        function unlockAchievement(achievementId) {
            const unlocked = loadAchievements();
            if (!unlocked.includes(achievementId)) {
                unlocked.push(achievementId);
                saveAchievements(unlocked);
                
                const ach = ACHIEVEMENTS.find(a => a.id === achievementId);
                if (ach) {
                    showAchievementToast(ach);
                    playSound('special');
                    createParticles(window.innerWidth / 2, window.innerHeight / 3, '#ffd700', 50);
                }
                
                updateAchievementCounter();
                return true;
            }
            return false;
        }
        
        // Track active achievement toasts for stacking
        let achievementToastCount = 0;
        
        function showAchievementToast(achievement) {
            const toast = document.createElement('div');
            toast.className = 'message success achievement-toast';
            
            // Position à direita, empilhado progressivamente
            const topPosition = 80 + (achievementToastCount * 130); // 130px de espaço entre toasts
            achievementToastCount++;
            
            toast.style.cssText = `
                position: fixed; 
                top: ${topPosition}px; 
                right: 20px; 
                z-index: 9999; 
                min-width: 320px;
                max-width: 350px;
                animation: slideInRight 0.5s ease;
                box-shadow: 0 10px 40px rgba(255, 215, 0, 0.4);
            `;
            
            toast.innerHTML = `
                <div style="font-size: 1.3em;">🏆 ACHIEVEMENT!</div>
                <div style="font-size: 1.1em; margin-top: 5px;">${achievement.icon} ${achievement.title}</div>
                <div style="font-size: 0.9em; margin-top: 3px; opacity: 0.8;">${achievement.description}</div>
            `;
            
            document.body.appendChild(toast);
            
            setTimeout(() => {
                toast.style.opacity = '0';
                toast.style.transform = 'translateX(400px)';
                setTimeout(() => {
                    toast.remove();
                    achievementToastCount--;
                }, 500);
            }, 4000);
        }
        
        function checkAllAchievements() {
            let newlyUnlocked = [];
            const unlocked = loadAchievements();
            
            ACHIEVEMENTS.forEach(ach => {
                if (!unlocked.includes(ach.id) && ach.check()) {
                    if (unlockAchievement(ach.id)) {
                        newlyUnlocked.push(ach.title);
                    }
                }
            });
            
            return newlyUnlocked;
        }
        
        function updateAchievementCounter() {
            const unlocked = loadAchievements();
            achievementCounter.textContent = `${unlocked.length}/50`;
        }
        
        function updateAchievementsDisplay() {
            const unlocked = loadAchievements();
            
            // Update counters
            const bronze = ACHIEVEMENTS.filter(a => a.tier === 'bronze');
            const silver = ACHIEVEMENTS.filter(a => a.tier === 'silver');
            const gold = ACHIEVEMENTS.filter(a => a.tier === 'gold');
            const platinum = ACHIEVEMENTS.filter(a => a.tier === 'platinum');
            
            const bronzeUnlocked = bronze.filter(a => unlocked.includes(a.id)).length;
            const silverUnlocked = silver.filter(a => unlocked.includes(a.id)).length;
            const goldUnlocked = gold.filter(a => unlocked.includes(a.id)).length;
            const platinumUnlocked = platinum.filter(a => unlocked.includes(a.id)).length;
            
            document.getElementById('achievementStats').textContent = `${unlocked.length}/50 Unlocked`;
            document.getElementById('bronzeCount').textContent = `${bronzeUnlocked}/25`;
            document.getElementById('silverCount').textContent = `${silverUnlocked}/15`;
            document.getElementById('goldCount').textContent = `${goldUnlocked}/9`;
            document.getElementById('platinumCount').textContent = `${platinumUnlocked}/1`;
            
            // Render achievement cards
            achievementsList.innerHTML = ACHIEVEMENTS.map(ach => {
                const isUnlocked = unlocked.includes(ach.id);
                const isSecret = ach.secret && !isUnlocked;
                
                return `
                    <div class="achievement-card ${ach.tier} ${isUnlocked ? 'unlocked' : 'locked'} ${isSecret ? 'secret' : ''}">
                        <div class="achievement-header">
                            <span class="achievement-medal">${ach.icon}</span>
                            <span class="achievement-title">${isSecret ? '???' : ach.title}</span>
                        </div>
                        ${!isSecret ? `<div class="achievement-description">${ach.description}</div>` : ''}
                    </div>
                `;
            }).join('');
        }

        // ============================================
        // INITIALIZATION
        // ============================================
        loadPermanentStats();
        loadUnlocks();
        updateAchievementCounter();
        
        // Initialize menu music (autoplay)
        setTimeout(() => {
            game.settings.musicEnabled = true;
            music.switchContext('menu');
            music.start();
            updateWelcomeMusicButton();
        }, 100);
        
        showWelcomeScreen(); // Show welcome screen on load

    </script>
</body>
</html>

